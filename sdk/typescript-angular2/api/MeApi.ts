/**
 * OrderCloud
 * A full ecommerce backend as a service.
 *
 * OpenAPI spec version: 0.1
 * Contact: ordercloud@four51.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import {Http, Headers, RequestOptionsArgs, Response, URLSearchParams} from '@angular/http';
import {Injectable, Optional} from '@angular/core';
import {Observable} from 'rxjs/Observable';
import * as models from '../model/models';
import 'rxjs/Rx';

/* tslint:disable:no-unused-variable member-ordering */

'use strict';

@Injectable()
export class MeApi {
    protected basePath = 'https://api.ordercloud.io/v1';
    public defaultHeaders : Headers = new Headers();

    constructor(protected http: Http, @Optional() basePath: string) {
        if (basePath) {
            this.basePath = basePath;
        }
    }

    /**
     * 
     * 
     * @param address 
     */
    public createAddress (address: models.BuyerAddress, extraHttpRequestParams?: any ) : Observable<any> {
        const path = this.basePath + '/me/addresses';

        let queryParameters = new URLSearchParams();
        let headerParams = this.defaultHeaders;
        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
            throw new Error('Required parameter address was null or undefined when calling createAddress.');
        }
        let requestOptions: RequestOptionsArgs = {
            method: 'POST',
            headers: headerParams,
            search: queryParameters
        };
        requestOptions.body = JSON.stringify(address);

        return this.http.request(path, requestOptions)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * 
     * @param creditCard 
     */
    public createCreditCard (creditCard: models.BuyerCreditCard, extraHttpRequestParams?: any ) : Observable<any> {
        const path = this.basePath + '/me/creditcards';

        let queryParameters = new URLSearchParams();
        let headerParams = this.defaultHeaders;
        // verify required parameter 'creditCard' is not null or undefined
        if (creditCard === null || creditCard === undefined) {
            throw new Error('Required parameter creditCard was null or undefined when calling createCreditCard.');
        }
        let requestOptions: RequestOptionsArgs = {
            method: 'POST',
            headers: headerParams,
            search: queryParameters
        };
        requestOptions.body = JSON.stringify(creditCard);

        return this.http.request(path, requestOptions)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * 
     * @param addressID ID of the address.
     */
    public deleteAddress (addressID: string, extraHttpRequestParams?: any ) : Observable<{}> {
        const path = this.basePath + '/me/addresses/{addressID}'
            .replace('{' + 'addressID' + '}', String(addressID));

        let queryParameters = new URLSearchParams();
        let headerParams = this.defaultHeaders;
        // verify required parameter 'addressID' is not null or undefined
        if (addressID === null || addressID === undefined) {
            throw new Error('Required parameter addressID was null or undefined when calling deleteAddress.');
        }
        let requestOptions: RequestOptionsArgs = {
            method: 'DELETE',
            headers: headerParams,
            search: queryParameters
        };

        return this.http.request(path, requestOptions)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * 
     * @param creditcardID ID of the creditcard.
     */
    public deleteCreditCard (creditcardID: string, extraHttpRequestParams?: any ) : Observable<{}> {
        const path = this.basePath + '/me/creditcards/{creditcardID}'
            .replace('{' + 'creditcardID' + '}', String(creditcardID));

        let queryParameters = new URLSearchParams();
        let headerParams = this.defaultHeaders;
        // verify required parameter 'creditcardID' is not null or undefined
        if (creditcardID === null || creditcardID === undefined) {
            throw new Error('Required parameter creditcardID was null or undefined when calling deleteCreditCard.');
        }
        let requestOptions: RequestOptionsArgs = {
            method: 'DELETE',
            headers: headerParams,
            search: queryParameters
        };

        return this.http.request(path, requestOptions)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * 
     */
    public get (extraHttpRequestParams?: any ) : Observable<any> {
        const path = this.basePath + '/me';

        let queryParameters = new URLSearchParams();
        let headerParams = this.defaultHeaders;
        let requestOptions: RequestOptionsArgs = {
            method: 'GET',
            headers: headerParams,
            search: queryParameters
        };

        return this.http.request(path, requestOptions)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * 
     * @param addressID ID of the address.
     */
    public getAddress (addressID: string, extraHttpRequestParams?: any ) : Observable<any> {
        const path = this.basePath + '/me/addresses/{addressID}'
            .replace('{' + 'addressID' + '}', String(addressID));

        let queryParameters = new URLSearchParams();
        let headerParams = this.defaultHeaders;
        // verify required parameter 'addressID' is not null or undefined
        if (addressID === null || addressID === undefined) {
            throw new Error('Required parameter addressID was null or undefined when calling getAddress.');
        }
        let requestOptions: RequestOptionsArgs = {
            method: 'GET',
            headers: headerParams,
            search: queryParameters
        };

        return this.http.request(path, requestOptions)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * 
     * @param creditcardID ID of the creditcard.
     */
    public getCreditCard (creditcardID: string, extraHttpRequestParams?: any ) : Observable<any> {
        const path = this.basePath + '/me/creditcards/{creditcardID}'
            .replace('{' + 'creditcardID' + '}', String(creditcardID));

        let queryParameters = new URLSearchParams();
        let headerParams = this.defaultHeaders;
        // verify required parameter 'creditcardID' is not null or undefined
        if (creditcardID === null || creditcardID === undefined) {
            throw new Error('Required parameter creditcardID was null or undefined when calling getCreditCard.');
        }
        let requestOptions: RequestOptionsArgs = {
            method: 'GET',
            headers: headerParams,
            search: queryParameters
        };

        return this.http.request(path, requestOptions)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * 
     * @param orderID ID of the order.
     */
    public getOrder (orderID: string, extraHttpRequestParams?: any ) : Observable<any> {
        const path = this.basePath + '/me/orders/{orderID}'
            .replace('{' + 'orderID' + '}', String(orderID));

        let queryParameters = new URLSearchParams();
        let headerParams = this.defaultHeaders;
        // verify required parameter 'orderID' is not null or undefined
        if (orderID === null || orderID === undefined) {
            throw new Error('Required parameter orderID was null or undefined when calling getOrder.');
        }
        let requestOptions: RequestOptionsArgs = {
            method: 'GET',
            headers: headerParams,
            search: queryParameters
        };

        return this.http.request(path, requestOptions)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * 
     * @param productID ID of the product.
     */
    public getProduct (productID: string, extraHttpRequestParams?: any ) : Observable<any> {
        const path = this.basePath + '/me/products/{productID}'
            .replace('{' + 'productID' + '}', String(productID));

        let queryParameters = new URLSearchParams();
        let headerParams = this.defaultHeaders;
        // verify required parameter 'productID' is not null or undefined
        if (productID === null || productID === undefined) {
            throw new Error('Required parameter productID was null or undefined when calling getProduct.');
        }
        let requestOptions: RequestOptionsArgs = {
            method: 'GET',
            headers: headerParams,
            search: queryParameters
        };

        return this.http.request(path, requestOptions)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * 
     * @param promotionID ID of the promotion.
     */
    public getPromotion (promotionID: string, extraHttpRequestParams?: any ) : Observable<any> {
        const path = this.basePath + '/me/promotions/{promotionID}'
            .replace('{' + 'promotionID' + '}', String(promotionID));

        let queryParameters = new URLSearchParams();
        let headerParams = this.defaultHeaders;
        // verify required parameter 'promotionID' is not null or undefined
        if (promotionID === null || promotionID === undefined) {
            throw new Error('Required parameter promotionID was null or undefined when calling getPromotion.');
        }
        let requestOptions: RequestOptionsArgs = {
            method: 'GET',
            headers: headerParams,
            search: queryParameters
        };

        return this.http.request(path, requestOptions)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * 
     * @param productID ID of the product.
     * @param specID ID of the spec.
     */
    public getSpec (productID: string, specID: string, extraHttpRequestParams?: any ) : Observable<any> {
        const path = this.basePath + '/me/products/{productID}/specs/{specID}'
            .replace('{' + 'productID' + '}', String(productID))
            .replace('{' + 'specID' + '}', String(specID));

        let queryParameters = new URLSearchParams();
        let headerParams = this.defaultHeaders;
        // verify required parameter 'productID' is not null or undefined
        if (productID === null || productID === undefined) {
            throw new Error('Required parameter productID was null or undefined when calling getSpec.');
        }
        // verify required parameter 'specID' is not null or undefined
        if (specID === null || specID === undefined) {
            throw new Error('Required parameter specID was null or undefined when calling getSpec.');
        }
        let requestOptions: RequestOptionsArgs = {
            method: 'GET',
            headers: headerParams,
            search: queryParameters
        };

        return this.http.request(path, requestOptions)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * 
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public listAddresses (search?: string, searchOn?: string, sortBy?: string, page?: number, pageSize?: number, extraHttpRequestParams?: any ) : Observable<any> {
        const path = this.basePath + '/me/addresses';

        let queryParameters = new URLSearchParams();
        let headerParams = this.defaultHeaders;
        if (search !== undefined) {
            queryParameters.set('search', String(search));
        }

        if (searchOn !== undefined) {
            queryParameters.set('searchOn', String(searchOn));
        }

        if (sortBy !== undefined) {
            queryParameters.set('sortBy', String(sortBy));
        }

        if (page !== undefined) {
            queryParameters.set('page', String(page));
        }

        if (pageSize !== undefined) {
            queryParameters.set('pageSize', String(pageSize));
        }

        let requestOptions: RequestOptionsArgs = {
            method: 'GET',
            headers: headerParams,
            search: queryParameters
        };

        return this.http.request(path, requestOptions)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * 
     * @param depth Depth of the category.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public listCategories (depth?: string, search?: string, searchOn?: string, sortBy?: string, page?: number, pageSize?: number, extraHttpRequestParams?: any ) : Observable<any> {
        const path = this.basePath + '/me/categories';

        let queryParameters = new URLSearchParams();
        let headerParams = this.defaultHeaders;
        if (depth !== undefined) {
            queryParameters.set('depth', String(depth));
        }

        if (search !== undefined) {
            queryParameters.set('search', String(search));
        }

        if (searchOn !== undefined) {
            queryParameters.set('searchOn', String(searchOn));
        }

        if (sortBy !== undefined) {
            queryParameters.set('sortBy', String(sortBy));
        }

        if (page !== undefined) {
            queryParameters.set('page', String(page));
        }

        if (pageSize !== undefined) {
            queryParameters.set('pageSize', String(pageSize));
        }

        let requestOptions: RequestOptionsArgs = {
            method: 'GET',
            headers: headerParams,
            search: queryParameters
        };

        return this.http.request(path, requestOptions)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * 
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public listCostCenters (search?: string, searchOn?: string, sortBy?: string, page?: number, pageSize?: number, extraHttpRequestParams?: any ) : Observable<any> {
        const path = this.basePath + '/me/costcenters';

        let queryParameters = new URLSearchParams();
        let headerParams = this.defaultHeaders;
        if (search !== undefined) {
            queryParameters.set('search', String(search));
        }

        if (searchOn !== undefined) {
            queryParameters.set('searchOn', String(searchOn));
        }

        if (sortBy !== undefined) {
            queryParameters.set('sortBy', String(sortBy));
        }

        if (page !== undefined) {
            queryParameters.set('page', String(page));
        }

        if (pageSize !== undefined) {
            queryParameters.set('pageSize', String(pageSize));
        }

        let requestOptions: RequestOptionsArgs = {
            method: 'GET',
            headers: headerParams,
            search: queryParameters
        };

        return this.http.request(path, requestOptions)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * 
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public listCreditCards (search?: string, searchOn?: string, sortBy?: string, page?: number, pageSize?: number, extraHttpRequestParams?: any ) : Observable<any> {
        const path = this.basePath + '/me/creditcards';

        let queryParameters = new URLSearchParams();
        let headerParams = this.defaultHeaders;
        if (search !== undefined) {
            queryParameters.set('search', String(search));
        }

        if (searchOn !== undefined) {
            queryParameters.set('searchOn', String(searchOn));
        }

        if (sortBy !== undefined) {
            queryParameters.set('sortBy', String(sortBy));
        }

        if (page !== undefined) {
            queryParameters.set('page', String(page));
        }

        if (pageSize !== undefined) {
            queryParameters.set('pageSize', String(pageSize));
        }

        let requestOptions: RequestOptionsArgs = {
            method: 'GET',
            headers: headerParams,
            search: queryParameters
        };

        return this.http.request(path, requestOptions)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * 
     * @param from Lower bound of date range that the order was created (if outgoing) or submitted (if incoming).
     * @param to Upper bound of date range that the order was created (if outgoing) or submitted (if incoming).
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public listIncomingOrders (from?: string, to?: string, search?: string, searchOn?: string, sortBy?: string, page?: number, pageSize?: number, extraHttpRequestParams?: any ) : Observable<any> {
        const path = this.basePath + '/me/orders/incoming';

        let queryParameters = new URLSearchParams();
        let headerParams = this.defaultHeaders;
        if (from !== undefined) {
            queryParameters.set('from', String(from));
        }

        if (to !== undefined) {
            queryParameters.set('to', String(to));
        }

        if (search !== undefined) {
            queryParameters.set('search', String(search));
        }

        if (searchOn !== undefined) {
            queryParameters.set('searchOn', String(searchOn));
        }

        if (sortBy !== undefined) {
            queryParameters.set('sortBy', String(sortBy));
        }

        if (page !== undefined) {
            queryParameters.set('page', String(page));
        }

        if (pageSize !== undefined) {
            queryParameters.set('pageSize', String(pageSize));
        }

        let requestOptions: RequestOptionsArgs = {
            method: 'GET',
            headers: headerParams,
            search: queryParameters
        };

        return this.http.request(path, requestOptions)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * 
     * @param from Lower bound of date range that the order was created (if outgoing) or submitted (if incoming).
     * @param to Upper bound of date range that the order was created (if outgoing) or submitted (if incoming).
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public listOutgoingOrders (from?: string, to?: string, search?: string, searchOn?: string, sortBy?: string, page?: number, pageSize?: number, extraHttpRequestParams?: any ) : Observable<any> {
        const path = this.basePath + '/me/orders/outgoing';

        let queryParameters = new URLSearchParams();
        let headerParams = this.defaultHeaders;
        if (from !== undefined) {
            queryParameters.set('from', String(from));
        }

        if (to !== undefined) {
            queryParameters.set('to', String(to));
        }

        if (search !== undefined) {
            queryParameters.set('search', String(search));
        }

        if (searchOn !== undefined) {
            queryParameters.set('searchOn', String(searchOn));
        }

        if (sortBy !== undefined) {
            queryParameters.set('sortBy', String(sortBy));
        }

        if (page !== undefined) {
            queryParameters.set('page', String(page));
        }

        if (pageSize !== undefined) {
            queryParameters.set('pageSize', String(pageSize));
        }

        let requestOptions: RequestOptionsArgs = {
            method: 'GET',
            headers: headerParams,
            search: queryParameters
        };

        return this.http.request(path, requestOptions)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * 
     * @param categoryID ID of the category.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public listProducts (categoryID?: string, search?: string, searchOn?: string, sortBy?: string, page?: number, pageSize?: number, extraHttpRequestParams?: any ) : Observable<any> {
        const path = this.basePath + '/me/products';

        let queryParameters = new URLSearchParams();
        let headerParams = this.defaultHeaders;
        if (categoryID !== undefined) {
            queryParameters.set('categoryID', String(categoryID));
        }

        if (search !== undefined) {
            queryParameters.set('search', String(search));
        }

        if (searchOn !== undefined) {
            queryParameters.set('searchOn', String(searchOn));
        }

        if (sortBy !== undefined) {
            queryParameters.set('sortBy', String(sortBy));
        }

        if (page !== undefined) {
            queryParameters.set('page', String(page));
        }

        if (pageSize !== undefined) {
            queryParameters.set('pageSize', String(pageSize));
        }

        let requestOptions: RequestOptionsArgs = {
            method: 'GET',
            headers: headerParams,
            search: queryParameters
        };

        return this.http.request(path, requestOptions)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * 
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public listPromotions (search?: string, searchOn?: string, sortBy?: string, page?: number, pageSize?: number, extraHttpRequestParams?: any ) : Observable<any> {
        const path = this.basePath + '/me/promotions';

        let queryParameters = new URLSearchParams();
        let headerParams = this.defaultHeaders;
        if (search !== undefined) {
            queryParameters.set('search', String(search));
        }

        if (searchOn !== undefined) {
            queryParameters.set('searchOn', String(searchOn));
        }

        if (sortBy !== undefined) {
            queryParameters.set('sortBy', String(sortBy));
        }

        if (page !== undefined) {
            queryParameters.set('page', String(page));
        }

        if (pageSize !== undefined) {
            queryParameters.set('pageSize', String(pageSize));
        }

        let requestOptions: RequestOptionsArgs = {
            method: 'GET',
            headers: headerParams,
            search: queryParameters
        };

        return this.http.request(path, requestOptions)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * 
     * @param productID ID of the product.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public listSpecs (productID: string, search?: string, searchOn?: string, sortBy?: string, page?: number, pageSize?: number, extraHttpRequestParams?: any ) : Observable<any> {
        const path = this.basePath + '/me/products/{productID}/specs'
            .replace('{' + 'productID' + '}', String(productID));

        let queryParameters = new URLSearchParams();
        let headerParams = this.defaultHeaders;
        // verify required parameter 'productID' is not null or undefined
        if (productID === null || productID === undefined) {
            throw new Error('Required parameter productID was null or undefined when calling listSpecs.');
        }
        if (search !== undefined) {
            queryParameters.set('search', String(search));
        }

        if (searchOn !== undefined) {
            queryParameters.set('searchOn', String(searchOn));
        }

        if (sortBy !== undefined) {
            queryParameters.set('sortBy', String(sortBy));
        }

        if (page !== undefined) {
            queryParameters.set('page', String(page));
        }

        if (pageSize !== undefined) {
            queryParameters.set('pageSize', String(pageSize));
        }

        let requestOptions: RequestOptionsArgs = {
            method: 'GET',
            headers: headerParams,
            search: queryParameters
        };

        return this.http.request(path, requestOptions)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * 
     * @param parentID ID of the parent.
     * @param depth Depth of the category.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public listSubcategories (parentID: string, depth?: string, search?: string, searchOn?: string, sortBy?: string, page?: number, pageSize?: number, extraHttpRequestParams?: any ) : Observable<any> {
        const path = this.basePath + '/me/categories/{parentID}/categories'
            .replace('{' + 'parentID' + '}', String(parentID));

        let queryParameters = new URLSearchParams();
        let headerParams = this.defaultHeaders;
        // verify required parameter 'parentID' is not null or undefined
        if (parentID === null || parentID === undefined) {
            throw new Error('Required parameter parentID was null or undefined when calling listSubcategories.');
        }
        if (depth !== undefined) {
            queryParameters.set('depth', String(depth));
        }

        if (search !== undefined) {
            queryParameters.set('search', String(search));
        }

        if (searchOn !== undefined) {
            queryParameters.set('searchOn', String(searchOn));
        }

        if (sortBy !== undefined) {
            queryParameters.set('sortBy', String(sortBy));
        }

        if (page !== undefined) {
            queryParameters.set('page', String(page));
        }

        if (pageSize !== undefined) {
            queryParameters.set('pageSize', String(pageSize));
        }

        let requestOptions: RequestOptionsArgs = {
            method: 'GET',
            headers: headerParams,
            search: queryParameters
        };

        return this.http.request(path, requestOptions)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * 
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public listUserGroups (search?: string, searchOn?: string, sortBy?: string, page?: number, pageSize?: number, extraHttpRequestParams?: any ) : Observable<any> {
        const path = this.basePath + '/me/usergroups';

        let queryParameters = new URLSearchParams();
        let headerParams = this.defaultHeaders;
        if (search !== undefined) {
            queryParameters.set('search', String(search));
        }

        if (searchOn !== undefined) {
            queryParameters.set('searchOn', String(searchOn));
        }

        if (sortBy !== undefined) {
            queryParameters.set('sortBy', String(sortBy));
        }

        if (page !== undefined) {
            queryParameters.set('page', String(page));
        }

        if (pageSize !== undefined) {
            queryParameters.set('pageSize', String(pageSize));
        }

        let requestOptions: RequestOptionsArgs = {
            method: 'GET',
            headers: headerParams,
            search: queryParameters
        };

        return this.http.request(path, requestOptions)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * 
     * @param user 
     */
    public patch (user: models.User, extraHttpRequestParams?: any ) : Observable<any> {
        const path = this.basePath + '/me';

        let queryParameters = new URLSearchParams();
        let headerParams = this.defaultHeaders;
        // verify required parameter 'user' is not null or undefined
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling patch.');
        }
        let requestOptions: RequestOptionsArgs = {
            method: 'PATCH',
            headers: headerParams,
            search: queryParameters
        };
        requestOptions.body = JSON.stringify(user);

        return this.http.request(path, requestOptions)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * 
     * @param addressID ID of the address.
     * @param address 
     */
    public patchAddress (addressID: string, address: models.BuyerAddress, extraHttpRequestParams?: any ) : Observable<{}> {
        const path = this.basePath + '/me/addresses/{addressID}'
            .replace('{' + 'addressID' + '}', String(addressID));

        let queryParameters = new URLSearchParams();
        let headerParams = this.defaultHeaders;
        // verify required parameter 'addressID' is not null or undefined
        if (addressID === null || addressID === undefined) {
            throw new Error('Required parameter addressID was null or undefined when calling patchAddress.');
        }
        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
            throw new Error('Required parameter address was null or undefined when calling patchAddress.');
        }
        let requestOptions: RequestOptionsArgs = {
            method: 'PATCH',
            headers: headerParams,
            search: queryParameters
        };
        requestOptions.body = JSON.stringify(address);

        return this.http.request(path, requestOptions)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * 
     * @param creditcardID ID of the creditcard.
     * @param creditCard 
     */
    public patchCreditCard (creditcardID: string, creditCard: models.BuyerCreditCard, extraHttpRequestParams?: any ) : Observable<{}> {
        const path = this.basePath + '/me/creditcards/{creditcardID}'
            .replace('{' + 'creditcardID' + '}', String(creditcardID));

        let queryParameters = new URLSearchParams();
        let headerParams = this.defaultHeaders;
        // verify required parameter 'creditcardID' is not null or undefined
        if (creditcardID === null || creditcardID === undefined) {
            throw new Error('Required parameter creditcardID was null or undefined when calling patchCreditCard.');
        }
        // verify required parameter 'creditCard' is not null or undefined
        if (creditCard === null || creditCard === undefined) {
            throw new Error('Required parameter creditCard was null or undefined when calling patchCreditCard.');
        }
        let requestOptions: RequestOptionsArgs = {
            method: 'PATCH',
            headers: headerParams,
            search: queryParameters
        };
        requestOptions.body = JSON.stringify(creditCard);

        return this.http.request(path, requestOptions)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * 
     * @param user 
     */
    public update (user: models.User, extraHttpRequestParams?: any ) : Observable<any> {
        const path = this.basePath + '/me';

        let queryParameters = new URLSearchParams();
        let headerParams = this.defaultHeaders;
        // verify required parameter 'user' is not null or undefined
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling update.');
        }
        let requestOptions: RequestOptionsArgs = {
            method: 'PUT',
            headers: headerParams,
            search: queryParameters
        };
        requestOptions.body = JSON.stringify(user);

        return this.http.request(path, requestOptions)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * 
     * @param addressID ID of the address.
     * @param address 
     */
    public updateAddress (addressID: string, address: models.BuyerAddress, extraHttpRequestParams?: any ) : Observable<any> {
        const path = this.basePath + '/me/addresses/{addressID}'
            .replace('{' + 'addressID' + '}', String(addressID));

        let queryParameters = new URLSearchParams();
        let headerParams = this.defaultHeaders;
        // verify required parameter 'addressID' is not null or undefined
        if (addressID === null || addressID === undefined) {
            throw new Error('Required parameter addressID was null or undefined when calling updateAddress.');
        }
        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
            throw new Error('Required parameter address was null or undefined when calling updateAddress.');
        }
        let requestOptions: RequestOptionsArgs = {
            method: 'PUT',
            headers: headerParams,
            search: queryParameters
        };
        requestOptions.body = JSON.stringify(address);

        return this.http.request(path, requestOptions)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * 
     * @param creditcardID ID of the creditcard.
     * @param creditCard 
     */
    public updateCreditCard (creditcardID: string, creditCard: models.BuyerCreditCard, extraHttpRequestParams?: any ) : Observable<any> {
        const path = this.basePath + '/me/creditcards/{creditcardID}'
            .replace('{' + 'creditcardID' + '}', String(creditcardID));

        let queryParameters = new URLSearchParams();
        let headerParams = this.defaultHeaders;
        // verify required parameter 'creditcardID' is not null or undefined
        if (creditcardID === null || creditcardID === undefined) {
            throw new Error('Required parameter creditcardID was null or undefined when calling updateCreditCard.');
        }
        // verify required parameter 'creditCard' is not null or undefined
        if (creditCard === null || creditCard === undefined) {
            throw new Error('Required parameter creditCard was null or undefined when calling updateCreditCard.');
        }
        let requestOptions: RequestOptionsArgs = {
            method: 'PUT',
            headers: headerParams,
            search: queryParameters
        };
        requestOptions.body = JSON.stringify(creditCard);

        return this.http.request(path, requestOptions)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

}
