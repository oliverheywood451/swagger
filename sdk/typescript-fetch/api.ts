/**
 * OrderCloud
 * A full ecommerce backend as a service.
 *
 * OpenAPI spec version: 0.1
 * Contact: ordercloud@four51.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import * as querystring from "querystring";
import * as url from "url";

import * as isomorphicFetch from "isomorphic-fetch";
import * as assign from "core-js/library/fn/object/assign";

interface Dictionary<T> { [index: string]: T; }
export interface FetchAPI { (url: string, init?: any): Promise<any>; }

const BASE_PATH = "https://api.ordercloud.io/v1";

export interface FetchArgs {
    url: string;
    options: any; 
}

export class BaseAPI {
    basePath: string;
    fetch: FetchAPI;

    constructor(fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) {
        this.basePath = basePath;
        this.fetch = fetch;
    }
}

export interface Address {
    "iD"?: string;
    "companyName"?: string;
    "firstName"?: string;
    "lastName"?: string;
    "street1"?: string;
    "street2"?: string;
    "city"?: string;
    "state"?: string;
    "zip"?: string;
    "country"?: string;
    "phone"?: string;
    "addressName"?: string;
    "xp"?: any;
}

export interface AddressAssignment {
    "addressID"?: string;
    "userID"?: string;
    "userGroupID"?: string;
    "isShipping"?: boolean;
    "isBilling"?: boolean;
}

export interface ApprovalRule {
    "iD"?: string;
    "name"?: string;
    "description"?: string;
    "approvingGroupID"?: string;
    "ruleExpression"?: string;
    "scope"?: string;
    "scopeTimeUnit"?: string;
    "scopeTimeNumber"?: number;
    "scopeStartDate"?: Date;
    "expireAfterTimeUnit"?: string;
    "expireAfterNumber"?: number;
    "approveOnExpire"?: boolean;
    "xp"?: any;
}

export interface Buyer {
    "iD"?: string;
    "name"?: string;
    "active"?: boolean;
    "xp"?: any;
}

export interface BuyerAddress {
    "shipping"?: boolean;
    "billing"?: boolean;
    "companyName"?: string;
    "firstName"?: string;
    "lastName"?: string;
    "street1"?: string;
    "street2"?: string;
    "city"?: string;
    "state"?: string;
    "zip"?: string;
    "country"?: string;
    "phone"?: string;
    "addressName"?: string;
    "xp"?: any;
}

export interface BuyerCreditCard {
    "token"?: string;
    "cardType"?: string;
    "partialAccountNumber"?: string;
    "cardholderName"?: string;
    "expirationDate"?: Date;
    "xp"?: any;
}

export interface Category {
    "iD"?: string;
    "name"?: string;
    "description"?: string;
    "xp"?: any;
    "listOrder"?: number;
    "active"?: boolean;
    "parentID"?: string;
}

export interface CategoryAssignment {
    "categoryID"?: string;
    "userID"?: string;
    "userGroupID"?: string;
}

export interface CategoryProductAssignment {
    "categoryID"?: string;
    "productID"?: string;
    "listOrder"?: number;
}

export interface CostCenter {
    "iD"?: string;
    "name"?: string;
    "description"?: string;
    "xp"?: any;
}

export interface CostCenterAssignment {
    "costCenterID"?: string;
    "userID"?: string;
    "userGroupID"?: string;
}

export interface CreditCard {
    "iD"?: string;
    "token"?: string;
    "cardType"?: string;
    "partialAccountNumber"?: string;
    "cardholderName"?: string;
    "expirationDate"?: Date;
    "xp"?: any;
}

export interface CreditCardAssignment {
    "creditCardID"?: string;
    "userID"?: string;
    "userGroupID"?: string;
}

export interface EmailTemplate {
    "subject"?: string;
    "body"?: string;
    "replyEmail"?: string;
    "sendMessageType"?: boolean;
    "emailFormatType"?: string;
}

export interface ImpersonateTokenRequest {
    "clientID"?: string;
    "claims"?: Array<ShipmentItem>;
}

export interface LineItem {
    "iD"?: string;
    "productID"?: string;
    "quantity"?: number;
    "unitPrice"?: number;
    "costCenter"?: string;
    "dateNeeded"?: Date;
    "shippingAccount"?: string;
    "shippingAddressID"?: string;
    "shipfromAddressID"?: string;
    "shipperID"?: string;
    "specs"?: Array<ShipmentItem>;
    "xp"?: any;
}

export interface Order {
    "iD"?: string;
    "type"?: string;
    "fromUserID"?: string;
    "billingAddressID"?: string;
    "shippingAddressID"?: string;
    "comments"?: string;
    "shippingCost"?: number;
    "taxCost"?: number;
    "xp"?: any;
}

export interface Partial1 {
    "iD"?: string;
    "username"?: string;
    "password"?: string;
    "firstName"?: string;
    "lastName"?: string;
    "email"?: string;
    "phone"?: string;
    "termsAccepted"?: Date;
    "active"?: boolean;
    "xp"?: any;
    "securityProfileID"?: string;
}

export interface PasswordReset {
    "clientID"?: string;
    "username"?: string;
    "password"?: string;
}

export interface PasswordResetRequest {
    "clientID"?: string;
    "email"?: string;
    "username"?: string;
    "uRL"?: string;
}

export interface Payment {
    "iD"?: string;
    "type"?: string;
    "creditCardID"?: string;
    "spendingAccountID"?: string;
    "description"?: string;
    "amount"?: number;
    "xp"?: any;
}

export interface PaymentTransaction {
    "iD"?: string;
    "type"?: string;
    "dateExecuted"?: Date;
    "amount"?: number;
    "succeeded"?: boolean;
    "resultCode"?: string;
    "resultMessage"?: string;
    "xp"?: any;
}

export interface PriceBreak {
    "quantity"?: number;
    "price"?: number;
}

export interface PriceSchedule {
    "iD"?: string;
    "name"?: string;
    "applyTax"?: boolean;
    "applyShipping"?: boolean;
    "maxQuantity"?: number;
    "useCumulativeQuantity"?: boolean;
    "restrictedQuantity"?: boolean;
    "orderType"?: string;
    "priceBreaks"?: Array<ShipmentItem>;
    "xp"?: any;
}

export interface Product {
    "iD"?: string;
    "name"?: string;
    "description"?: string;
    "quantityMultiplier"?: number;
    "shipWeight"?: number;
    "active"?: boolean;
    "type"?: string;
    "inventoryEnabled"?: boolean;
    "inventoryNotificationPoint"?: number;
    "variantLevelInventory"?: boolean;
    "xp"?: any;
    "allowOrderExceedInventory"?: boolean;
    "inventoryVisible"?: boolean;
}

export interface ProductAssignment {
    "productID"?: string;
    "standardPriceScheduleID"?: string;
    "replenishmentPriceScheduleID"?: string;
    "userID"?: string;
    "userGroupID"?: string;
    "buyerID"?: string;
}

export interface Promotion {
    "iD"?: string;
    "code"?: string;
    "name"?: string;
    "usagesRemaining"?: number;
    "description"?: string;
    "finePrint"?: string;
    "startDate"?: Date;
    "expirationDate"?: Date;
    "eligibleExpression"?: string;
    "valueExpression"?: string;
    "canCombine"?: boolean;
    "xp"?: any;
}

export interface PromotionAssignment {
    "promotionID"?: string;
    "buyerID"?: string;
    "userID"?: string;
    "userGroupID"?: string;
}

export interface Shipment {
    "iD"?: string;
    "shipper"?: string;
    "dateShipped"?: Date;
    "trackingNumber"?: string;
    "cost"?: number;
    "items"?: Array<ShipmentItem>;
    "xp"?: any;
}

export interface ShipmentItem {
    "orderID"?: string;
    "lineItemID"?: string;
    "quantityShipped"?: number;
}

export interface Spec {
    "iD"?: string;
    "listOrder"?: number;
    "name"?: string;
    "defaultValue"?: string;
    "required"?: boolean;
    "allowOpenText"?: boolean;
    "defaultOptionID"?: string;
    "xp"?: any;
}

export interface SpecOption {
    "iD"?: string;
    "value"?: string;
    "listOrder"?: number;
    "isOpenText"?: boolean;
    "priceMarkupType"?: string;
    "priceMarkup"?: number;
    "xp"?: any;
}

export interface SpecProductAssignment {
    "specID"?: string;
    "productID"?: string;
    "definesVariant"?: boolean;
}

export interface SpendingAccount {
    "iD"?: string;
    "name"?: string;
    "balance"?: number;
    "allowAsPaymentMethod"?: boolean;
    "redemptionCode"?: string;
    "startDate"?: Date;
    "endDate"?: Date;
    "xp"?: any;
}

export interface SpendingAccountAssignment {
    "spendingAccountID"?: string;
    "userID"?: string;
    "userGroupID"?: string;
    "allowExceed"?: boolean;
}

export interface User {
    "iD"?: string;
    "username"?: string;
    "password"?: string;
    "firstName"?: string;
    "lastName"?: string;
    "email"?: string;
    "phone"?: string;
    "termsAccepted"?: Date;
    "active"?: boolean;
    "xp"?: any;
    "securityProfileID"?: string;
}

export interface UserGroup {
    "iD"?: string;
    "name"?: string;
    "description"?: string;
    "xp"?: any;
}

export interface UserGroupAssignment {
    "userGroupID"?: string;
    "userID"?: string;
}

export interface Variant {
    "iD"?: string;
    "name"?: string;
    "description"?: string;
    "active"?: boolean;
    "xp"?: any;
}



/**
 * AddressApi - fetch parameter creator
 */
export const AddressApiFetchParamCreactor = {
    /** 
     * @param buyerID ID of the buyer.
     * @param addressID ID of the address.
     */
    _delete(params: {  buyerID: string; addressID: string; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling _delete");
        }
        // verify required parameter "addressID" is set
        if (params["addressID"] == null) {
            throw new Error("Missing required parameter addressID when calling _delete");
        }
        const baseUrl = `/buyers/{buyerID}/addresses/{addressID}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"addressID"}}`, `${ params.addressID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "DELETE" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param address 
     */
    create(params: {  buyerID: string; address: Address; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling create");
        }
        // verify required parameter "address" is set
        if (params["address"] == null) {
            throw new Error("Missing required parameter address when calling create");
        }
        const baseUrl = `/buyers/{buyerID}/addresses`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["address"]) {
            fetchOptions.body = JSON.stringify(params["address"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param addressID ID of the address.
     * @param userID ID of the user.
     * @param userGroupID ID of the user group.
     */
    deleteAssignment(params: {  buyerID: string; addressID: string; userID?: string; userGroupID?: string; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling deleteAssignment");
        }
        // verify required parameter "addressID" is set
        if (params["addressID"] == null) {
            throw new Error("Missing required parameter addressID when calling deleteAssignment");
        }
        const baseUrl = `/buyers/{buyerID}/addresses/{addressID}/assignments`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"addressID"}}`, `${ params.addressID }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "userID": params.userID,
            "userGroupID": params.userGroupID,
        });
        let fetchOptions: RequestInit = { method: "DELETE" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param addressID ID of the address.
     */
    get(params: {  buyerID: string; addressID: string; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling get");
        }
        // verify required parameter "addressID" is set
        if (params["addressID"] == null) {
            throw new Error("Missing required parameter addressID when calling get");
        }
        const baseUrl = `/buyers/{buyerID}/addresses/{addressID}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"addressID"}}`, `${ params.addressID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    list(params: {  buyerID: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling list");
        }
        const baseUrl = `/buyers/{buyerID}/addresses`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "search": params.search,
            "searchOn": params.searchOn,
            "sortBy": params.sortBy,
            "page": params.page,
            "pageSize": params.pageSize,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param addressID ID of the address.
     * @param userID ID of the user.
     * @param userGroupID ID of the user group.
     * @param level Level of the address.
     * @param isShipping Is shipping of the address.
     * @param isBilling Is billing of the address.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listAssignments(params: {  buyerID: string; addressID?: string; userID?: string; userGroupID?: string; level?: string; isShipping?: boolean; isBilling?: boolean; page?: number; pageSize?: number; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling listAssignments");
        }
        const baseUrl = `/buyers/{buyerID}/addresses/assignments`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "addressID": params.addressID,
            "userID": params.userID,
            "userGroupID": params.userGroupID,
            "level": params.level,
            "isShipping": params.isShipping,
            "isBilling": params.isBilling,
            "page": params.page,
            "pageSize": params.pageSize,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param addressID ID of the address.
     * @param address 
     */
    patch(params: {  buyerID: string; addressID: string; address: Address; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling patch");
        }
        // verify required parameter "addressID" is set
        if (params["addressID"] == null) {
            throw new Error("Missing required parameter addressID when calling patch");
        }
        // verify required parameter "address" is set
        if (params["address"] == null) {
            throw new Error("Missing required parameter address when calling patch");
        }
        const baseUrl = `/buyers/{buyerID}/addresses/{addressID}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"addressID"}}`, `${ params.addressID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PATCH" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["address"]) {
            fetchOptions.body = JSON.stringify(params["address"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param assignment 
     */
    saveAssignment(params: {  buyerID: string; assignment: AddressAssignment; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling saveAssignment");
        }
        // verify required parameter "assignment" is set
        if (params["assignment"] == null) {
            throw new Error("Missing required parameter assignment when calling saveAssignment");
        }
        const baseUrl = `/buyers/{buyerID}/addresses/assignments`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["assignment"]) {
            fetchOptions.body = JSON.stringify(params["assignment"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param addressID ID of the address.
     * @param address 
     */
    update(params: {  buyerID: string; addressID: string; address: Address; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling update");
        }
        // verify required parameter "addressID" is set
        if (params["addressID"] == null) {
            throw new Error("Missing required parameter addressID when calling update");
        }
        // verify required parameter "address" is set
        if (params["address"] == null) {
            throw new Error("Missing required parameter address when calling update");
        }
        const baseUrl = `/buyers/{buyerID}/addresses/{addressID}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"addressID"}}`, `${ params.addressID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PUT" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["address"]) {
            fetchOptions.body = JSON.stringify(params["address"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
}

/**
 * AddressApi - functional programming interface
 */
export const AddressApiFp = {
    /** 
     * @param buyerID ID of the buyer.
     * @param addressID ID of the address.
     */
    _delete(params: { buyerID: string; addressID: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AddressApiFetchParamCreactor._delete(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param address 
     */
    create(params: { buyerID: string; address: Address;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AddressApiFetchParamCreactor.create(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param addressID ID of the address.
     * @param userID ID of the user.
     * @param userGroupID ID of the user group.
     */
    deleteAssignment(params: { buyerID: string; addressID: string; userID?: string; userGroupID?: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AddressApiFetchParamCreactor.deleteAssignment(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param addressID ID of the address.
     */
    get(params: { buyerID: string; addressID: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AddressApiFetchParamCreactor.get(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    list(params: { buyerID: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AddressApiFetchParamCreactor.list(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param addressID ID of the address.
     * @param userID ID of the user.
     * @param userGroupID ID of the user group.
     * @param level Level of the address.
     * @param isShipping Is shipping of the address.
     * @param isBilling Is billing of the address.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listAssignments(params: { buyerID: string; addressID?: string; userID?: string; userGroupID?: string; level?: string; isShipping?: boolean; isBilling?: boolean; page?: number; pageSize?: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AddressApiFetchParamCreactor.listAssignments(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param addressID ID of the address.
     * @param address 
     */
    patch(params: { buyerID: string; addressID: string; address: Address;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AddressApiFetchParamCreactor.patch(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param assignment 
     */
    saveAssignment(params: { buyerID: string; assignment: AddressAssignment;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AddressApiFetchParamCreactor.saveAssignment(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param addressID ID of the address.
     * @param address 
     */
    update(params: { buyerID: string; addressID: string; address: Address;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AddressApiFetchParamCreactor.update(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * AddressApi - object-oriented interface
 */
export class AddressApi extends BaseAPI {
    /** 
     * @param buyerID ID of the buyer.
     * @param addressID ID of the address.
     */
    _delete(params: {  buyerID: string; addressID: string; }) {
        return AddressApiFp._delete(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param address 
     */
    create(params: {  buyerID: string; address: Address; }) {
        return AddressApiFp.create(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param addressID ID of the address.
     * @param userID ID of the user.
     * @param userGroupID ID of the user group.
     */
    deleteAssignment(params: {  buyerID: string; addressID: string; userID?: string; userGroupID?: string; }) {
        return AddressApiFp.deleteAssignment(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param addressID ID of the address.
     */
    get(params: {  buyerID: string; addressID: string; }) {
        return AddressApiFp.get(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    list(params: {  buyerID: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
        return AddressApiFp.list(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param addressID ID of the address.
     * @param userID ID of the user.
     * @param userGroupID ID of the user group.
     * @param level Level of the address.
     * @param isShipping Is shipping of the address.
     * @param isBilling Is billing of the address.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listAssignments(params: {  buyerID: string; addressID?: string; userID?: string; userGroupID?: string; level?: string; isShipping?: boolean; isBilling?: boolean; page?: number; pageSize?: number; }) {
        return AddressApiFp.listAssignments(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param addressID ID of the address.
     * @param address 
     */
    patch(params: {  buyerID: string; addressID: string; address: Address; }) {
        return AddressApiFp.patch(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param assignment 
     */
    saveAssignment(params: {  buyerID: string; assignment: AddressAssignment; }) {
        return AddressApiFp.saveAssignment(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param addressID ID of the address.
     * @param address 
     */
    update(params: {  buyerID: string; addressID: string; address: Address; }) {
        return AddressApiFp.update(params)(this.fetch, this.basePath);
    }
};

/**
 * AddressApi - factory interface
 */
export const AddressApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * @param buyerID ID of the buyer.
         * @param addressID ID of the address.
         */
        _delete(params: {  buyerID: string; addressID: string; }) {
            return AddressApiFp._delete(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param address 
         */
        create(params: {  buyerID: string; address: Address; }) {
            return AddressApiFp.create(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param addressID ID of the address.
         * @param userID ID of the user.
         * @param userGroupID ID of the user group.
         */
        deleteAssignment(params: {  buyerID: string; addressID: string; userID?: string; userGroupID?: string; }) {
            return AddressApiFp.deleteAssignment(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param addressID ID of the address.
         */
        get(params: {  buyerID: string; addressID: string; }) {
            return AddressApiFp.get(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param search Word or phrase to search for.
         * @param searchOn Comma-delimited list of fields to search on.
         * @param sortBy Comma-delimited list of fields to sort by.
         * @param page Page of results to return. Default: 1
         * @param pageSize Number of results to return per page. Default: 20, max: 100.
         */
        list(params: {  buyerID: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
            return AddressApiFp.list(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param addressID ID of the address.
         * @param userID ID of the user.
         * @param userGroupID ID of the user group.
         * @param level Level of the address.
         * @param isShipping Is shipping of the address.
         * @param isBilling Is billing of the address.
         * @param page Page of results to return. Default: 1
         * @param pageSize Number of results to return per page. Default: 20, max: 100.
         */
        listAssignments(params: {  buyerID: string; addressID?: string; userID?: string; userGroupID?: string; level?: string; isShipping?: boolean; isBilling?: boolean; page?: number; pageSize?: number; }) {
            return AddressApiFp.listAssignments(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param addressID ID of the address.
         * @param address 
         */
        patch(params: {  buyerID: string; addressID: string; address: Address; }) {
            return AddressApiFp.patch(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param assignment 
         */
        saveAssignment(params: {  buyerID: string; assignment: AddressAssignment; }) {
            return AddressApiFp.saveAssignment(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param addressID ID of the address.
         * @param address 
         */
        update(params: {  buyerID: string; addressID: string; address: Address; }) {
            return AddressApiFp.update(params)(fetch, basePath);
        },
    }
};


/**
 * AdminUserApi - fetch parameter creator
 */
export const AdminUserApiFetchParamCreactor = {
    /** 
     * @param userID ID of the user.
     */
    _delete(params: {  userID: string; }): FetchArgs {
        // verify required parameter "userID" is set
        if (params["userID"] == null) {
            throw new Error("Missing required parameter userID when calling _delete");
        }
        const baseUrl = `/adminusers/{userID}`
            .replace(`{${"userID"}}`, `${ params.userID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "DELETE" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param user 
     */
    create(params: {  user: User; }): FetchArgs {
        // verify required parameter "user" is set
        if (params["user"] == null) {
            throw new Error("Missing required parameter user when calling create");
        }
        const baseUrl = `/adminusers`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["user"]) {
            fetchOptions.body = JSON.stringify(params["user"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param userID ID of the user.
     */
    get(params: {  userID: string; }): FetchArgs {
        // verify required parameter "userID" is set
        if (params["userID"] == null) {
            throw new Error("Missing required parameter userID when calling get");
        }
        const baseUrl = `/adminusers/{userID}`
            .replace(`{${"userID"}}`, `${ params.userID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    list(params: {  search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }): FetchArgs {
        const baseUrl = `/adminusers`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "search": params.search,
            "searchOn": params.searchOn,
            "sortBy": params.sortBy,
            "page": params.page,
            "pageSize": params.pageSize,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param userID ID of the user.
     * @param user 
     */
    patch(params: {  userID: string; user: User; }): FetchArgs {
        // verify required parameter "userID" is set
        if (params["userID"] == null) {
            throw new Error("Missing required parameter userID when calling patch");
        }
        // verify required parameter "user" is set
        if (params["user"] == null) {
            throw new Error("Missing required parameter user when calling patch");
        }
        const baseUrl = `/adminusers/{userID}`
            .replace(`{${"userID"}}`, `${ params.userID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PATCH" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["user"]) {
            fetchOptions.body = JSON.stringify(params["user"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param userID ID of the user.
     * @param user 
     */
    update(params: {  userID: string; user: User; }): FetchArgs {
        // verify required parameter "userID" is set
        if (params["userID"] == null) {
            throw new Error("Missing required parameter userID when calling update");
        }
        // verify required parameter "user" is set
        if (params["user"] == null) {
            throw new Error("Missing required parameter user when calling update");
        }
        const baseUrl = `/adminusers/{userID}`
            .replace(`{${"userID"}}`, `${ params.userID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PUT" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["user"]) {
            fetchOptions.body = JSON.stringify(params["user"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
}

/**
 * AdminUserApi - functional programming interface
 */
export const AdminUserApiFp = {
    /** 
     * @param userID ID of the user.
     */
    _delete(params: { userID: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AdminUserApiFetchParamCreactor._delete(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param user 
     */
    create(params: { user: User;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AdminUserApiFetchParamCreactor.create(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param userID ID of the user.
     */
    get(params: { userID: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AdminUserApiFetchParamCreactor.get(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    list(params: { search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AdminUserApiFetchParamCreactor.list(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param userID ID of the user.
     * @param user 
     */
    patch(params: { userID: string; user: User;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AdminUserApiFetchParamCreactor.patch(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param userID ID of the user.
     * @param user 
     */
    update(params: { userID: string; user: User;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AdminUserApiFetchParamCreactor.update(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * AdminUserApi - object-oriented interface
 */
export class AdminUserApi extends BaseAPI {
    /** 
     * @param userID ID of the user.
     */
    _delete(params: {  userID: string; }) {
        return AdminUserApiFp._delete(params)(this.fetch, this.basePath);
    }
    /** 
     * @param user 
     */
    create(params: {  user: User; }) {
        return AdminUserApiFp.create(params)(this.fetch, this.basePath);
    }
    /** 
     * @param userID ID of the user.
     */
    get(params: {  userID: string; }) {
        return AdminUserApiFp.get(params)(this.fetch, this.basePath);
    }
    /** 
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    list(params: {  search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
        return AdminUserApiFp.list(params)(this.fetch, this.basePath);
    }
    /** 
     * @param userID ID of the user.
     * @param user 
     */
    patch(params: {  userID: string; user: User; }) {
        return AdminUserApiFp.patch(params)(this.fetch, this.basePath);
    }
    /** 
     * @param userID ID of the user.
     * @param user 
     */
    update(params: {  userID: string; user: User; }) {
        return AdminUserApiFp.update(params)(this.fetch, this.basePath);
    }
};

/**
 * AdminUserApi - factory interface
 */
export const AdminUserApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * @param userID ID of the user.
         */
        _delete(params: {  userID: string; }) {
            return AdminUserApiFp._delete(params)(fetch, basePath);
        },
        /** 
         * @param user 
         */
        create(params: {  user: User; }) {
            return AdminUserApiFp.create(params)(fetch, basePath);
        },
        /** 
         * @param userID ID of the user.
         */
        get(params: {  userID: string; }) {
            return AdminUserApiFp.get(params)(fetch, basePath);
        },
        /** 
         * @param search Word or phrase to search for.
         * @param searchOn Comma-delimited list of fields to search on.
         * @param sortBy Comma-delimited list of fields to sort by.
         * @param page Page of results to return. Default: 1
         * @param pageSize Number of results to return per page. Default: 20, max: 100.
         */
        list(params: {  search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
            return AdminUserApiFp.list(params)(fetch, basePath);
        },
        /** 
         * @param userID ID of the user.
         * @param user 
         */
        patch(params: {  userID: string; user: User; }) {
            return AdminUserApiFp.patch(params)(fetch, basePath);
        },
        /** 
         * @param userID ID of the user.
         * @param user 
         */
        update(params: {  userID: string; user: User; }) {
            return AdminUserApiFp.update(params)(fetch, basePath);
        },
    }
};


/**
 * ApprovalRuleApi - fetch parameter creator
 */
export const ApprovalRuleApiFetchParamCreactor = {
    /** 
     * @param buyerID ID of the buyer.
     * @param approvalRuleID ID of the approval rule.
     */
    _delete(params: {  buyerID: string; approvalRuleID: string; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling _delete");
        }
        // verify required parameter "approvalRuleID" is set
        if (params["approvalRuleID"] == null) {
            throw new Error("Missing required parameter approvalRuleID when calling _delete");
        }
        const baseUrl = `/buyers/{buyerID}/approvalrules/{approvalRuleID}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"approvalRuleID"}}`, `${ params.approvalRuleID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "DELETE" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param approvalRule 
     */
    create(params: {  buyerID: string; approvalRule: ApprovalRule; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling create");
        }
        // verify required parameter "approvalRule" is set
        if (params["approvalRule"] == null) {
            throw new Error("Missing required parameter approvalRule when calling create");
        }
        const baseUrl = `/buyers/{buyerID}/approvalrules`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["approvalRule"]) {
            fetchOptions.body = JSON.stringify(params["approvalRule"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param approvalRuleID ID of the approval rule.
     */
    get(params: {  buyerID: string; approvalRuleID: string; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling get");
        }
        // verify required parameter "approvalRuleID" is set
        if (params["approvalRuleID"] == null) {
            throw new Error("Missing required parameter approvalRuleID when calling get");
        }
        const baseUrl = `/buyers/{buyerID}/approvalrules/{approvalRuleID}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"approvalRuleID"}}`, `${ params.approvalRuleID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    list(params: {  buyerID: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling list");
        }
        const baseUrl = `/buyers/{buyerID}/approvalrules`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "search": params.search,
            "searchOn": params.searchOn,
            "sortBy": params.sortBy,
            "page": params.page,
            "pageSize": params.pageSize,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param approvalRuleID ID of the approval rule.
     * @param partialApprovalRule 
     */
    patch(params: {  buyerID: string; approvalRuleID: string; partialApprovalRule: ApprovalRule; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling patch");
        }
        // verify required parameter "approvalRuleID" is set
        if (params["approvalRuleID"] == null) {
            throw new Error("Missing required parameter approvalRuleID when calling patch");
        }
        // verify required parameter "partialApprovalRule" is set
        if (params["partialApprovalRule"] == null) {
            throw new Error("Missing required parameter partialApprovalRule when calling patch");
        }
        const baseUrl = `/buyers/{buyerID}/approvalrules/{approvalRuleID}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"approvalRuleID"}}`, `${ params.approvalRuleID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PATCH" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["partialApprovalRule"]) {
            fetchOptions.body = JSON.stringify(params["partialApprovalRule"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param approvalRuleID ID of the approval rule.
     * @param approvalRule 
     */
    update(params: {  buyerID: string; approvalRuleID: string; approvalRule: ApprovalRule; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling update");
        }
        // verify required parameter "approvalRuleID" is set
        if (params["approvalRuleID"] == null) {
            throw new Error("Missing required parameter approvalRuleID when calling update");
        }
        // verify required parameter "approvalRule" is set
        if (params["approvalRule"] == null) {
            throw new Error("Missing required parameter approvalRule when calling update");
        }
        const baseUrl = `/buyers/{buyerID}/approvalrules/{approvalRuleID}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"approvalRuleID"}}`, `${ params.approvalRuleID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PUT" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["approvalRule"]) {
            fetchOptions.body = JSON.stringify(params["approvalRule"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
}

/**
 * ApprovalRuleApi - functional programming interface
 */
export const ApprovalRuleApiFp = {
    /** 
     * @param buyerID ID of the buyer.
     * @param approvalRuleID ID of the approval rule.
     */
    _delete(params: { buyerID: string; approvalRuleID: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ApprovalRuleApiFetchParamCreactor._delete(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param approvalRule 
     */
    create(params: { buyerID: string; approvalRule: ApprovalRule;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ApprovalRuleApiFetchParamCreactor.create(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param approvalRuleID ID of the approval rule.
     */
    get(params: { buyerID: string; approvalRuleID: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ApprovalRuleApiFetchParamCreactor.get(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    list(params: { buyerID: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ApprovalRuleApiFetchParamCreactor.list(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param approvalRuleID ID of the approval rule.
     * @param partialApprovalRule 
     */
    patch(params: { buyerID: string; approvalRuleID: string; partialApprovalRule: ApprovalRule;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ApprovalRuleApiFetchParamCreactor.patch(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param approvalRuleID ID of the approval rule.
     * @param approvalRule 
     */
    update(params: { buyerID: string; approvalRuleID: string; approvalRule: ApprovalRule;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ApprovalRuleApiFetchParamCreactor.update(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * ApprovalRuleApi - object-oriented interface
 */
export class ApprovalRuleApi extends BaseAPI {
    /** 
     * @param buyerID ID of the buyer.
     * @param approvalRuleID ID of the approval rule.
     */
    _delete(params: {  buyerID: string; approvalRuleID: string; }) {
        return ApprovalRuleApiFp._delete(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param approvalRule 
     */
    create(params: {  buyerID: string; approvalRule: ApprovalRule; }) {
        return ApprovalRuleApiFp.create(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param approvalRuleID ID of the approval rule.
     */
    get(params: {  buyerID: string; approvalRuleID: string; }) {
        return ApprovalRuleApiFp.get(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    list(params: {  buyerID: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
        return ApprovalRuleApiFp.list(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param approvalRuleID ID of the approval rule.
     * @param partialApprovalRule 
     */
    patch(params: {  buyerID: string; approvalRuleID: string; partialApprovalRule: ApprovalRule; }) {
        return ApprovalRuleApiFp.patch(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param approvalRuleID ID of the approval rule.
     * @param approvalRule 
     */
    update(params: {  buyerID: string; approvalRuleID: string; approvalRule: ApprovalRule; }) {
        return ApprovalRuleApiFp.update(params)(this.fetch, this.basePath);
    }
};

/**
 * ApprovalRuleApi - factory interface
 */
export const ApprovalRuleApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * @param buyerID ID of the buyer.
         * @param approvalRuleID ID of the approval rule.
         */
        _delete(params: {  buyerID: string; approvalRuleID: string; }) {
            return ApprovalRuleApiFp._delete(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param approvalRule 
         */
        create(params: {  buyerID: string; approvalRule: ApprovalRule; }) {
            return ApprovalRuleApiFp.create(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param approvalRuleID ID of the approval rule.
         */
        get(params: {  buyerID: string; approvalRuleID: string; }) {
            return ApprovalRuleApiFp.get(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param search Word or phrase to search for.
         * @param searchOn Comma-delimited list of fields to search on.
         * @param sortBy Comma-delimited list of fields to sort by.
         * @param page Page of results to return. Default: 1
         * @param pageSize Number of results to return per page. Default: 20, max: 100.
         */
        list(params: {  buyerID: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
            return ApprovalRuleApiFp.list(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param approvalRuleID ID of the approval rule.
         * @param partialApprovalRule 
         */
        patch(params: {  buyerID: string; approvalRuleID: string; partialApprovalRule: ApprovalRule; }) {
            return ApprovalRuleApiFp.patch(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param approvalRuleID ID of the approval rule.
         * @param approvalRule 
         */
        update(params: {  buyerID: string; approvalRuleID: string; approvalRule: ApprovalRule; }) {
            return ApprovalRuleApiFp.update(params)(fetch, basePath);
        },
    }
};


/**
 * BuyerApi - fetch parameter creator
 */
export const BuyerApiFetchParamCreactor = {
    /** 
     * @param buyerID ID of the buyer.
     */
    _delete(params: {  buyerID: string; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling _delete");
        }
        const baseUrl = `/buyers/{buyerID}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "DELETE" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param company 
     */
    create(params: {  company: Buyer; }): FetchArgs {
        // verify required parameter "company" is set
        if (params["company"] == null) {
            throw new Error("Missing required parameter company when calling create");
        }
        const baseUrl = `/buyers`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["company"]) {
            fetchOptions.body = JSON.stringify(params["company"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     */
    get(params: {  buyerID: string; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling get");
        }
        const baseUrl = `/buyers/{buyerID}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param search Word or phrase to search for.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    list(params: {  search?: string; page?: number; pageSize?: number; }): FetchArgs {
        const baseUrl = `/buyers`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "search": params.search,
            "page": params.page,
            "pageSize": params.pageSize,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param company 
     */
    update(params: {  buyerID: string; company: Buyer; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling update");
        }
        // verify required parameter "company" is set
        if (params["company"] == null) {
            throw new Error("Missing required parameter company when calling update");
        }
        const baseUrl = `/buyers/{buyerID}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PUT" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["company"]) {
            fetchOptions.body = JSON.stringify(params["company"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
}

/**
 * BuyerApi - functional programming interface
 */
export const BuyerApiFp = {
    /** 
     * @param buyerID ID of the buyer.
     */
    _delete(params: { buyerID: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = BuyerApiFetchParamCreactor._delete(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param company 
     */
    create(params: { company: Buyer;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = BuyerApiFetchParamCreactor.create(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     */
    get(params: { buyerID: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = BuyerApiFetchParamCreactor.get(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param search Word or phrase to search for.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    list(params: { search?: string; page?: number; pageSize?: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = BuyerApiFetchParamCreactor.list(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param company 
     */
    update(params: { buyerID: string; company: Buyer;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = BuyerApiFetchParamCreactor.update(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * BuyerApi - object-oriented interface
 */
export class BuyerApi extends BaseAPI {
    /** 
     * @param buyerID ID of the buyer.
     */
    _delete(params: {  buyerID: string; }) {
        return BuyerApiFp._delete(params)(this.fetch, this.basePath);
    }
    /** 
     * @param company 
     */
    create(params: {  company: Buyer; }) {
        return BuyerApiFp.create(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     */
    get(params: {  buyerID: string; }) {
        return BuyerApiFp.get(params)(this.fetch, this.basePath);
    }
    /** 
     * @param search Word or phrase to search for.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    list(params: {  search?: string; page?: number; pageSize?: number; }) {
        return BuyerApiFp.list(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param company 
     */
    update(params: {  buyerID: string; company: Buyer; }) {
        return BuyerApiFp.update(params)(this.fetch, this.basePath);
    }
};

/**
 * BuyerApi - factory interface
 */
export const BuyerApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * @param buyerID ID of the buyer.
         */
        _delete(params: {  buyerID: string; }) {
            return BuyerApiFp._delete(params)(fetch, basePath);
        },
        /** 
         * @param company 
         */
        create(params: {  company: Buyer; }) {
            return BuyerApiFp.create(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         */
        get(params: {  buyerID: string; }) {
            return BuyerApiFp.get(params)(fetch, basePath);
        },
        /** 
         * @param search Word or phrase to search for.
         * @param page Page of results to return. Default: 1
         * @param pageSize Number of results to return per page. Default: 20, max: 100.
         */
        list(params: {  search?: string; page?: number; pageSize?: number; }) {
            return BuyerApiFp.list(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param company 
         */
        update(params: {  buyerID: string; company: Buyer; }) {
            return BuyerApiFp.update(params)(fetch, basePath);
        },
    }
};


/**
 * CategoryApi - fetch parameter creator
 */
export const CategoryApiFetchParamCreactor = {
    /** 
     * @param buyerID ID of the buyer.
     * @param categoryID ID of the category.
     */
    _delete(params: {  buyerID: string; categoryID: string; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling _delete");
        }
        // verify required parameter "categoryID" is set
        if (params["categoryID"] == null) {
            throw new Error("Missing required parameter categoryID when calling _delete");
        }
        const baseUrl = `/buyers/{buyerID}/categories/{categoryID}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"categoryID"}}`, `${ params.categoryID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "DELETE" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param category 
     */
    create(params: {  buyerID: string; category: Category; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling create");
        }
        // verify required parameter "category" is set
        if (params["category"] == null) {
            throw new Error("Missing required parameter category when calling create");
        }
        const baseUrl = `/buyers/{buyerID}/categories`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["category"]) {
            fetchOptions.body = JSON.stringify(params["category"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param categoryID ID of the category.
     * @param userID ID of the user.
     * @param userGroupID ID of the user group.
     */
    deleteAssignment(params: {  buyerID: string; categoryID: string; userID?: string; userGroupID?: string; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling deleteAssignment");
        }
        // verify required parameter "categoryID" is set
        if (params["categoryID"] == null) {
            throw new Error("Missing required parameter categoryID when calling deleteAssignment");
        }
        const baseUrl = `/buyers/{buyerID}/categories/{categoryID}/assignments`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"categoryID"}}`, `${ params.categoryID }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "userID": params.userID,
            "userGroupID": params.userGroupID,
        });
        let fetchOptions: RequestInit = { method: "DELETE" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param categoryID ID of the category.
     * @param productID ID of the product.
     */
    deleteProductAssignment(params: {  buyerID: string; categoryID: string; productID: string; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling deleteProductAssignment");
        }
        // verify required parameter "categoryID" is set
        if (params["categoryID"] == null) {
            throw new Error("Missing required parameter categoryID when calling deleteProductAssignment");
        }
        // verify required parameter "productID" is set
        if (params["productID"] == null) {
            throw new Error("Missing required parameter productID when calling deleteProductAssignment");
        }
        const baseUrl = `/buyers/{buyerID}/categories/{categoryID}/productassignments/{productID}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"categoryID"}}`, `${ params.categoryID }`)
            .replace(`{${"productID"}}`, `${ params.productID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "DELETE" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param categoryID ID of the category.
     */
    get(params: {  buyerID: string; categoryID: string; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling get");
        }
        // verify required parameter "categoryID" is set
        if (params["categoryID"] == null) {
            throw new Error("Missing required parameter categoryID when calling get");
        }
        const baseUrl = `/buyers/{buyerID}/categories/{categoryID}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"categoryID"}}`, `${ params.categoryID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param parentID ID of the parent.
     * @param depth Depth of the category.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    list(params: {  buyerID: string; parentID?: string; depth?: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling list");
        }
        const baseUrl = `/buyers/{buyerID}/categories`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "parentID": params.parentID,
            "depth": params.depth,
            "search": params.search,
            "searchOn": params.searchOn,
            "sortBy": params.sortBy,
            "page": params.page,
            "pageSize": params.pageSize,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param categoryID ID of the category.
     * @param userID ID of the user.
     * @param userGroupID ID of the user group.
     * @param level Level of the category.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listAssignments(params: {  buyerID: string; categoryID?: string; userID?: string; userGroupID?: string; level?: string; page?: number; pageSize?: number; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling listAssignments");
        }
        const baseUrl = `/buyers/{buyerID}/categories/assignments`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "categoryID": params.categoryID,
            "userID": params.userID,
            "userGroupID": params.userGroupID,
            "level": params.level,
            "page": params.page,
            "pageSize": params.pageSize,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param parentID ID of the parent.
     * @param search Word or phrase to search for.
     * @param depth Depth of the category.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listChildren(params: {  buyerID: string; parentID: string; search?: string; depth?: string; page?: number; pageSize?: number; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling listChildren");
        }
        // verify required parameter "parentID" is set
        if (params["parentID"] == null) {
            throw new Error("Missing required parameter parentID when calling listChildren");
        }
        const baseUrl = `/buyers/{buyerID}/categories/{parentID}/categories`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"parentID"}}`, `${ params.parentID }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "search": params.search,
            "depth": params.depth,
            "page": params.page,
            "pageSize": params.pageSize,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param categoryID ID of the category.
     * @param productID ID of the product.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listProductAssignments(params: {  buyerID: string; categoryID?: string; productID?: string; page?: number; pageSize?: number; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling listProductAssignments");
        }
        const baseUrl = `/buyers/{buyerID}/categories/productassignments`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "categoryID": params.categoryID,
            "productID": params.productID,
            "page": params.page,
            "pageSize": params.pageSize,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param categoryID ID of the category.
     * @param category 
     */
    patch(params: {  buyerID: string; categoryID: string; category: Category; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling patch");
        }
        // verify required parameter "categoryID" is set
        if (params["categoryID"] == null) {
            throw new Error("Missing required parameter categoryID when calling patch");
        }
        // verify required parameter "category" is set
        if (params["category"] == null) {
            throw new Error("Missing required parameter category when calling patch");
        }
        const baseUrl = `/buyers/{buyerID}/categories/{categoryID}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"categoryID"}}`, `${ params.categoryID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PATCH" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["category"]) {
            fetchOptions.body = JSON.stringify(params["category"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param categoryAssignment 
     */
    saveAssignment(params: {  buyerID: string; categoryAssignment: CategoryAssignment; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling saveAssignment");
        }
        // verify required parameter "categoryAssignment" is set
        if (params["categoryAssignment"] == null) {
            throw new Error("Missing required parameter categoryAssignment when calling saveAssignment");
        }
        const baseUrl = `/buyers/{buyerID}/categories/assignments`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["categoryAssignment"]) {
            fetchOptions.body = JSON.stringify(params["categoryAssignment"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param productAssignment 
     */
    saveProductAssignment(params: {  buyerID: string; productAssignment: CategoryProductAssignment; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling saveProductAssignment");
        }
        // verify required parameter "productAssignment" is set
        if (params["productAssignment"] == null) {
            throw new Error("Missing required parameter productAssignment when calling saveProductAssignment");
        }
        const baseUrl = `/buyers/{buyerID}/categories/productassignments`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["productAssignment"]) {
            fetchOptions.body = JSON.stringify(params["productAssignment"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param categoryID ID of the category.
     * @param category 
     */
    update(params: {  buyerID: string; categoryID: string; category: Category; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling update");
        }
        // verify required parameter "categoryID" is set
        if (params["categoryID"] == null) {
            throw new Error("Missing required parameter categoryID when calling update");
        }
        // verify required parameter "category" is set
        if (params["category"] == null) {
            throw new Error("Missing required parameter category when calling update");
        }
        const baseUrl = `/buyers/{buyerID}/categories/{categoryID}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"categoryID"}}`, `${ params.categoryID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PUT" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["category"]) {
            fetchOptions.body = JSON.stringify(params["category"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
}

/**
 * CategoryApi - functional programming interface
 */
export const CategoryApiFp = {
    /** 
     * @param buyerID ID of the buyer.
     * @param categoryID ID of the category.
     */
    _delete(params: { buyerID: string; categoryID: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CategoryApiFetchParamCreactor._delete(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param category 
     */
    create(params: { buyerID: string; category: Category;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CategoryApiFetchParamCreactor.create(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param categoryID ID of the category.
     * @param userID ID of the user.
     * @param userGroupID ID of the user group.
     */
    deleteAssignment(params: { buyerID: string; categoryID: string; userID?: string; userGroupID?: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CategoryApiFetchParamCreactor.deleteAssignment(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param categoryID ID of the category.
     * @param productID ID of the product.
     */
    deleteProductAssignment(params: { buyerID: string; categoryID: string; productID: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CategoryApiFetchParamCreactor.deleteProductAssignment(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param categoryID ID of the category.
     */
    get(params: { buyerID: string; categoryID: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CategoryApiFetchParamCreactor.get(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param parentID ID of the parent.
     * @param depth Depth of the category.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    list(params: { buyerID: string; parentID?: string; depth?: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CategoryApiFetchParamCreactor.list(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param categoryID ID of the category.
     * @param userID ID of the user.
     * @param userGroupID ID of the user group.
     * @param level Level of the category.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listAssignments(params: { buyerID: string; categoryID?: string; userID?: string; userGroupID?: string; level?: string; page?: number; pageSize?: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CategoryApiFetchParamCreactor.listAssignments(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param parentID ID of the parent.
     * @param search Word or phrase to search for.
     * @param depth Depth of the category.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listChildren(params: { buyerID: string; parentID: string; search?: string; depth?: string; page?: number; pageSize?: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CategoryApiFetchParamCreactor.listChildren(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param categoryID ID of the category.
     * @param productID ID of the product.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listProductAssignments(params: { buyerID: string; categoryID?: string; productID?: string; page?: number; pageSize?: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CategoryApiFetchParamCreactor.listProductAssignments(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param categoryID ID of the category.
     * @param category 
     */
    patch(params: { buyerID: string; categoryID: string; category: Category;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CategoryApiFetchParamCreactor.patch(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param categoryAssignment 
     */
    saveAssignment(params: { buyerID: string; categoryAssignment: CategoryAssignment;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CategoryApiFetchParamCreactor.saveAssignment(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param productAssignment 
     */
    saveProductAssignment(params: { buyerID: string; productAssignment: CategoryProductAssignment;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CategoryApiFetchParamCreactor.saveProductAssignment(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param categoryID ID of the category.
     * @param category 
     */
    update(params: { buyerID: string; categoryID: string; category: Category;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CategoryApiFetchParamCreactor.update(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * CategoryApi - object-oriented interface
 */
export class CategoryApi extends BaseAPI {
    /** 
     * @param buyerID ID of the buyer.
     * @param categoryID ID of the category.
     */
    _delete(params: {  buyerID: string; categoryID: string; }) {
        return CategoryApiFp._delete(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param category 
     */
    create(params: {  buyerID: string; category: Category; }) {
        return CategoryApiFp.create(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param categoryID ID of the category.
     * @param userID ID of the user.
     * @param userGroupID ID of the user group.
     */
    deleteAssignment(params: {  buyerID: string; categoryID: string; userID?: string; userGroupID?: string; }) {
        return CategoryApiFp.deleteAssignment(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param categoryID ID of the category.
     * @param productID ID of the product.
     */
    deleteProductAssignment(params: {  buyerID: string; categoryID: string; productID: string; }) {
        return CategoryApiFp.deleteProductAssignment(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param categoryID ID of the category.
     */
    get(params: {  buyerID: string; categoryID: string; }) {
        return CategoryApiFp.get(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param parentID ID of the parent.
     * @param depth Depth of the category.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    list(params: {  buyerID: string; parentID?: string; depth?: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
        return CategoryApiFp.list(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param categoryID ID of the category.
     * @param userID ID of the user.
     * @param userGroupID ID of the user group.
     * @param level Level of the category.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listAssignments(params: {  buyerID: string; categoryID?: string; userID?: string; userGroupID?: string; level?: string; page?: number; pageSize?: number; }) {
        return CategoryApiFp.listAssignments(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param parentID ID of the parent.
     * @param search Word or phrase to search for.
     * @param depth Depth of the category.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listChildren(params: {  buyerID: string; parentID: string; search?: string; depth?: string; page?: number; pageSize?: number; }) {
        return CategoryApiFp.listChildren(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param categoryID ID of the category.
     * @param productID ID of the product.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listProductAssignments(params: {  buyerID: string; categoryID?: string; productID?: string; page?: number; pageSize?: number; }) {
        return CategoryApiFp.listProductAssignments(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param categoryID ID of the category.
     * @param category 
     */
    patch(params: {  buyerID: string; categoryID: string; category: Category; }) {
        return CategoryApiFp.patch(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param categoryAssignment 
     */
    saveAssignment(params: {  buyerID: string; categoryAssignment: CategoryAssignment; }) {
        return CategoryApiFp.saveAssignment(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param productAssignment 
     */
    saveProductAssignment(params: {  buyerID: string; productAssignment: CategoryProductAssignment; }) {
        return CategoryApiFp.saveProductAssignment(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param categoryID ID of the category.
     * @param category 
     */
    update(params: {  buyerID: string; categoryID: string; category: Category; }) {
        return CategoryApiFp.update(params)(this.fetch, this.basePath);
    }
};

/**
 * CategoryApi - factory interface
 */
export const CategoryApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * @param buyerID ID of the buyer.
         * @param categoryID ID of the category.
         */
        _delete(params: {  buyerID: string; categoryID: string; }) {
            return CategoryApiFp._delete(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param category 
         */
        create(params: {  buyerID: string; category: Category; }) {
            return CategoryApiFp.create(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param categoryID ID of the category.
         * @param userID ID of the user.
         * @param userGroupID ID of the user group.
         */
        deleteAssignment(params: {  buyerID: string; categoryID: string; userID?: string; userGroupID?: string; }) {
            return CategoryApiFp.deleteAssignment(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param categoryID ID of the category.
         * @param productID ID of the product.
         */
        deleteProductAssignment(params: {  buyerID: string; categoryID: string; productID: string; }) {
            return CategoryApiFp.deleteProductAssignment(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param categoryID ID of the category.
         */
        get(params: {  buyerID: string; categoryID: string; }) {
            return CategoryApiFp.get(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param parentID ID of the parent.
         * @param depth Depth of the category.
         * @param search Word or phrase to search for.
         * @param searchOn Comma-delimited list of fields to search on.
         * @param sortBy Comma-delimited list of fields to sort by.
         * @param page Page of results to return. Default: 1
         * @param pageSize Number of results to return per page. Default: 20, max: 100.
         */
        list(params: {  buyerID: string; parentID?: string; depth?: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
            return CategoryApiFp.list(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param categoryID ID of the category.
         * @param userID ID of the user.
         * @param userGroupID ID of the user group.
         * @param level Level of the category.
         * @param page Page of results to return. Default: 1
         * @param pageSize Number of results to return per page. Default: 20, max: 100.
         */
        listAssignments(params: {  buyerID: string; categoryID?: string; userID?: string; userGroupID?: string; level?: string; page?: number; pageSize?: number; }) {
            return CategoryApiFp.listAssignments(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param parentID ID of the parent.
         * @param search Word or phrase to search for.
         * @param depth Depth of the category.
         * @param page Page of results to return. Default: 1
         * @param pageSize Number of results to return per page. Default: 20, max: 100.
         */
        listChildren(params: {  buyerID: string; parentID: string; search?: string; depth?: string; page?: number; pageSize?: number; }) {
            return CategoryApiFp.listChildren(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param categoryID ID of the category.
         * @param productID ID of the product.
         * @param page Page of results to return. Default: 1
         * @param pageSize Number of results to return per page. Default: 20, max: 100.
         */
        listProductAssignments(params: {  buyerID: string; categoryID?: string; productID?: string; page?: number; pageSize?: number; }) {
            return CategoryApiFp.listProductAssignments(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param categoryID ID of the category.
         * @param category 
         */
        patch(params: {  buyerID: string; categoryID: string; category: Category; }) {
            return CategoryApiFp.patch(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param categoryAssignment 
         */
        saveAssignment(params: {  buyerID: string; categoryAssignment: CategoryAssignment; }) {
            return CategoryApiFp.saveAssignment(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param productAssignment 
         */
        saveProductAssignment(params: {  buyerID: string; productAssignment: CategoryProductAssignment; }) {
            return CategoryApiFp.saveProductAssignment(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param categoryID ID of the category.
         * @param category 
         */
        update(params: {  buyerID: string; categoryID: string; category: Category; }) {
            return CategoryApiFp.update(params)(fetch, basePath);
        },
    }
};


/**
 * CostCenterApi - fetch parameter creator
 */
export const CostCenterApiFetchParamCreactor = {
    /** 
     * @param buyerID ID of the buyer.
     * @param costCenterID ID of the cost center.
     */
    _delete(params: {  buyerID: string; costCenterID: string; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling _delete");
        }
        // verify required parameter "costCenterID" is set
        if (params["costCenterID"] == null) {
            throw new Error("Missing required parameter costCenterID when calling _delete");
        }
        const baseUrl = `/buyers/{buyerID}/costcenters/{costCenterID}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"costCenterID"}}`, `${ params.costCenterID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "DELETE" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param costCenter 
     */
    create(params: {  buyerID: string; costCenter: CostCenter; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling create");
        }
        // verify required parameter "costCenter" is set
        if (params["costCenter"] == null) {
            throw new Error("Missing required parameter costCenter when calling create");
        }
        const baseUrl = `/buyers/{buyerID}/costcenters`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["costCenter"]) {
            fetchOptions.body = JSON.stringify(params["costCenter"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param costCenterID ID of the cost center.
     * @param userID ID of the user.
     * @param userGroupID ID of the user group.
     */
    deleteAssignment(params: {  buyerID: string; costCenterID: string; userID?: string; userGroupID?: string; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling deleteAssignment");
        }
        // verify required parameter "costCenterID" is set
        if (params["costCenterID"] == null) {
            throw new Error("Missing required parameter costCenterID when calling deleteAssignment");
        }
        const baseUrl = `/buyers/{buyerID}/costcenters/{costCenterID}/assignments`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"costCenterID"}}`, `${ params.costCenterID }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "userID": params.userID,
            "userGroupID": params.userGroupID,
        });
        let fetchOptions: RequestInit = { method: "DELETE" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param costCenterID ID of the cost center.
     */
    get(params: {  buyerID: string; costCenterID: string; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling get");
        }
        // verify required parameter "costCenterID" is set
        if (params["costCenterID"] == null) {
            throw new Error("Missing required parameter costCenterID when calling get");
        }
        const baseUrl = `/buyers/{buyerID}/costcenters/{costCenterID}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"costCenterID"}}`, `${ params.costCenterID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    list(params: {  buyerID: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling list");
        }
        const baseUrl = `/buyers/{buyerID}/costcenters`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "search": params.search,
            "searchOn": params.searchOn,
            "sortBy": params.sortBy,
            "page": params.page,
            "pageSize": params.pageSize,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param costCenterID ID of the cost center.
     * @param userID ID of the user.
     * @param userGroupID ID of the user group.
     * @param level Level of the cost center.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listAssignments(params: {  buyerID: string; costCenterID?: string; userID?: string; userGroupID?: string; level?: string; page?: number; pageSize?: number; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling listAssignments");
        }
        const baseUrl = `/buyers/{buyerID}/costcenters/assignments`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "costCenterID": params.costCenterID,
            "userID": params.userID,
            "userGroupID": params.userGroupID,
            "level": params.level,
            "page": params.page,
            "pageSize": params.pageSize,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param costCenterID ID of the cost center.
     * @param costCenter 
     */
    patch(params: {  buyerID: string; costCenterID: string; costCenter: CostCenter; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling patch");
        }
        // verify required parameter "costCenterID" is set
        if (params["costCenterID"] == null) {
            throw new Error("Missing required parameter costCenterID when calling patch");
        }
        // verify required parameter "costCenter" is set
        if (params["costCenter"] == null) {
            throw new Error("Missing required parameter costCenter when calling patch");
        }
        const baseUrl = `/buyers/{buyerID}/costcenters/{costCenterID}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"costCenterID"}}`, `${ params.costCenterID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PATCH" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["costCenter"]) {
            fetchOptions.body = JSON.stringify(params["costCenter"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param assignment 
     */
    saveAssignment(params: {  buyerID: string; assignment: CostCenterAssignment; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling saveAssignment");
        }
        // verify required parameter "assignment" is set
        if (params["assignment"] == null) {
            throw new Error("Missing required parameter assignment when calling saveAssignment");
        }
        const baseUrl = `/buyers/{buyerID}/costcenters/assignments`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["assignment"]) {
            fetchOptions.body = JSON.stringify(params["assignment"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param costCenterID ID of the cost center.
     * @param costCenter 
     */
    update(params: {  buyerID: string; costCenterID: string; costCenter: CostCenter; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling update");
        }
        // verify required parameter "costCenterID" is set
        if (params["costCenterID"] == null) {
            throw new Error("Missing required parameter costCenterID when calling update");
        }
        // verify required parameter "costCenter" is set
        if (params["costCenter"] == null) {
            throw new Error("Missing required parameter costCenter when calling update");
        }
        const baseUrl = `/buyers/{buyerID}/costcenters/{costCenterID}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"costCenterID"}}`, `${ params.costCenterID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PUT" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["costCenter"]) {
            fetchOptions.body = JSON.stringify(params["costCenter"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
}

/**
 * CostCenterApi - functional programming interface
 */
export const CostCenterApiFp = {
    /** 
     * @param buyerID ID of the buyer.
     * @param costCenterID ID of the cost center.
     */
    _delete(params: { buyerID: string; costCenterID: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CostCenterApiFetchParamCreactor._delete(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param costCenter 
     */
    create(params: { buyerID: string; costCenter: CostCenter;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CostCenterApiFetchParamCreactor.create(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param costCenterID ID of the cost center.
     * @param userID ID of the user.
     * @param userGroupID ID of the user group.
     */
    deleteAssignment(params: { buyerID: string; costCenterID: string; userID?: string; userGroupID?: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CostCenterApiFetchParamCreactor.deleteAssignment(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param costCenterID ID of the cost center.
     */
    get(params: { buyerID: string; costCenterID: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CostCenterApiFetchParamCreactor.get(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    list(params: { buyerID: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CostCenterApiFetchParamCreactor.list(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param costCenterID ID of the cost center.
     * @param userID ID of the user.
     * @param userGroupID ID of the user group.
     * @param level Level of the cost center.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listAssignments(params: { buyerID: string; costCenterID?: string; userID?: string; userGroupID?: string; level?: string; page?: number; pageSize?: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CostCenterApiFetchParamCreactor.listAssignments(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param costCenterID ID of the cost center.
     * @param costCenter 
     */
    patch(params: { buyerID: string; costCenterID: string; costCenter: CostCenter;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CostCenterApiFetchParamCreactor.patch(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param assignment 
     */
    saveAssignment(params: { buyerID: string; assignment: CostCenterAssignment;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CostCenterApiFetchParamCreactor.saveAssignment(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param costCenterID ID of the cost center.
     * @param costCenter 
     */
    update(params: { buyerID: string; costCenterID: string; costCenter: CostCenter;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CostCenterApiFetchParamCreactor.update(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * CostCenterApi - object-oriented interface
 */
export class CostCenterApi extends BaseAPI {
    /** 
     * @param buyerID ID of the buyer.
     * @param costCenterID ID of the cost center.
     */
    _delete(params: {  buyerID: string; costCenterID: string; }) {
        return CostCenterApiFp._delete(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param costCenter 
     */
    create(params: {  buyerID: string; costCenter: CostCenter; }) {
        return CostCenterApiFp.create(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param costCenterID ID of the cost center.
     * @param userID ID of the user.
     * @param userGroupID ID of the user group.
     */
    deleteAssignment(params: {  buyerID: string; costCenterID: string; userID?: string; userGroupID?: string; }) {
        return CostCenterApiFp.deleteAssignment(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param costCenterID ID of the cost center.
     */
    get(params: {  buyerID: string; costCenterID: string; }) {
        return CostCenterApiFp.get(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    list(params: {  buyerID: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
        return CostCenterApiFp.list(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param costCenterID ID of the cost center.
     * @param userID ID of the user.
     * @param userGroupID ID of the user group.
     * @param level Level of the cost center.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listAssignments(params: {  buyerID: string; costCenterID?: string; userID?: string; userGroupID?: string; level?: string; page?: number; pageSize?: number; }) {
        return CostCenterApiFp.listAssignments(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param costCenterID ID of the cost center.
     * @param costCenter 
     */
    patch(params: {  buyerID: string; costCenterID: string; costCenter: CostCenter; }) {
        return CostCenterApiFp.patch(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param assignment 
     */
    saveAssignment(params: {  buyerID: string; assignment: CostCenterAssignment; }) {
        return CostCenterApiFp.saveAssignment(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param costCenterID ID of the cost center.
     * @param costCenter 
     */
    update(params: {  buyerID: string; costCenterID: string; costCenter: CostCenter; }) {
        return CostCenterApiFp.update(params)(this.fetch, this.basePath);
    }
};

/**
 * CostCenterApi - factory interface
 */
export const CostCenterApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * @param buyerID ID of the buyer.
         * @param costCenterID ID of the cost center.
         */
        _delete(params: {  buyerID: string; costCenterID: string; }) {
            return CostCenterApiFp._delete(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param costCenter 
         */
        create(params: {  buyerID: string; costCenter: CostCenter; }) {
            return CostCenterApiFp.create(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param costCenterID ID of the cost center.
         * @param userID ID of the user.
         * @param userGroupID ID of the user group.
         */
        deleteAssignment(params: {  buyerID: string; costCenterID: string; userID?: string; userGroupID?: string; }) {
            return CostCenterApiFp.deleteAssignment(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param costCenterID ID of the cost center.
         */
        get(params: {  buyerID: string; costCenterID: string; }) {
            return CostCenterApiFp.get(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param search Word or phrase to search for.
         * @param searchOn Comma-delimited list of fields to search on.
         * @param sortBy Comma-delimited list of fields to sort by.
         * @param page Page of results to return. Default: 1
         * @param pageSize Number of results to return per page. Default: 20, max: 100.
         */
        list(params: {  buyerID: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
            return CostCenterApiFp.list(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param costCenterID ID of the cost center.
         * @param userID ID of the user.
         * @param userGroupID ID of the user group.
         * @param level Level of the cost center.
         * @param page Page of results to return. Default: 1
         * @param pageSize Number of results to return per page. Default: 20, max: 100.
         */
        listAssignments(params: {  buyerID: string; costCenterID?: string; userID?: string; userGroupID?: string; level?: string; page?: number; pageSize?: number; }) {
            return CostCenterApiFp.listAssignments(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param costCenterID ID of the cost center.
         * @param costCenter 
         */
        patch(params: {  buyerID: string; costCenterID: string; costCenter: CostCenter; }) {
            return CostCenterApiFp.patch(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param assignment 
         */
        saveAssignment(params: {  buyerID: string; assignment: CostCenterAssignment; }) {
            return CostCenterApiFp.saveAssignment(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param costCenterID ID of the cost center.
         * @param costCenter 
         */
        update(params: {  buyerID: string; costCenterID: string; costCenter: CostCenter; }) {
            return CostCenterApiFp.update(params)(fetch, basePath);
        },
    }
};


/**
 * CreditCardApi - fetch parameter creator
 */
export const CreditCardApiFetchParamCreactor = {
    /** 
     * @param buyerID ID of the buyer.
     * @param creditCardID ID of the credit card.
     */
    _delete(params: {  buyerID: string; creditCardID: string; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling _delete");
        }
        // verify required parameter "creditCardID" is set
        if (params["creditCardID"] == null) {
            throw new Error("Missing required parameter creditCardID when calling _delete");
        }
        const baseUrl = `/buyers/{buyerID}/creditcards/{creditCardID}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"creditCardID"}}`, `${ params.creditCardID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "DELETE" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param card 
     */
    create(params: {  buyerID: string; card: CreditCard; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling create");
        }
        // verify required parameter "card" is set
        if (params["card"] == null) {
            throw new Error("Missing required parameter card when calling create");
        }
        const baseUrl = `/buyers/{buyerID}/creditcards`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["card"]) {
            fetchOptions.body = JSON.stringify(params["card"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param creditCardID ID of the credit card.
     * @param userID ID of the user.
     * @param userGroupID ID of the user group.
     */
    deleteAssignment(params: {  buyerID: string; creditCardID: string; userID?: string; userGroupID?: string; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling deleteAssignment");
        }
        // verify required parameter "creditCardID" is set
        if (params["creditCardID"] == null) {
            throw new Error("Missing required parameter creditCardID when calling deleteAssignment");
        }
        const baseUrl = `/buyers/{buyerID}/creditcards/{creditCardID}/assignments`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"creditCardID"}}`, `${ params.creditCardID }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "userID": params.userID,
            "userGroupID": params.userGroupID,
        });
        let fetchOptions: RequestInit = { method: "DELETE" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param creditCardID ID of the credit card.
     */
    get(params: {  buyerID: string; creditCardID: string; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling get");
        }
        // verify required parameter "creditCardID" is set
        if (params["creditCardID"] == null) {
            throw new Error("Missing required parameter creditCardID when calling get");
        }
        const baseUrl = `/buyers/{buyerID}/creditcards/{creditCardID}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"creditCardID"}}`, `${ params.creditCardID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    list(params: {  buyerID: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling list");
        }
        const baseUrl = `/buyers/{buyerID}/creditcards`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "search": params.search,
            "searchOn": params.searchOn,
            "sortBy": params.sortBy,
            "page": params.page,
            "pageSize": params.pageSize,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param creditCardID ID of the credit card.
     * @param userID ID of the user.
     * @param userGroupID ID of the user group.
     * @param level Level of the credit card.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listAssignments(params: {  buyerID: string; creditCardID?: string; userID?: string; userGroupID?: string; level?: string; page?: number; pageSize?: number; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling listAssignments");
        }
        const baseUrl = `/buyers/{buyerID}/creditcards/assignments`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "creditCardID": params.creditCardID,
            "userID": params.userID,
            "userGroupID": params.userGroupID,
            "level": params.level,
            "page": params.page,
            "pageSize": params.pageSize,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param creditCardID ID of the credit card.
     * @param card 
     */
    patch(params: {  buyerID: string; creditCardID: string; card: CreditCard; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling patch");
        }
        // verify required parameter "creditCardID" is set
        if (params["creditCardID"] == null) {
            throw new Error("Missing required parameter creditCardID when calling patch");
        }
        // verify required parameter "card" is set
        if (params["card"] == null) {
            throw new Error("Missing required parameter card when calling patch");
        }
        const baseUrl = `/buyers/{buyerID}/creditcards/{creditCardID}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"creditCardID"}}`, `${ params.creditCardID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PATCH" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["card"]) {
            fetchOptions.body = JSON.stringify(params["card"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param assignment 
     */
    saveAssignment(params: {  buyerID: string; assignment: CreditCardAssignment; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling saveAssignment");
        }
        // verify required parameter "assignment" is set
        if (params["assignment"] == null) {
            throw new Error("Missing required parameter assignment when calling saveAssignment");
        }
        const baseUrl = `/buyers/{buyerID}/creditcards/assignments`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["assignment"]) {
            fetchOptions.body = JSON.stringify(params["assignment"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param creditCardID ID of the credit card.
     * @param card 
     */
    update(params: {  buyerID: string; creditCardID: string; card: CreditCard; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling update");
        }
        // verify required parameter "creditCardID" is set
        if (params["creditCardID"] == null) {
            throw new Error("Missing required parameter creditCardID when calling update");
        }
        // verify required parameter "card" is set
        if (params["card"] == null) {
            throw new Error("Missing required parameter card when calling update");
        }
        const baseUrl = `/buyers/{buyerID}/creditcards/{creditCardID}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"creditCardID"}}`, `${ params.creditCardID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PUT" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["card"]) {
            fetchOptions.body = JSON.stringify(params["card"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
}

/**
 * CreditCardApi - functional programming interface
 */
export const CreditCardApiFp = {
    /** 
     * @param buyerID ID of the buyer.
     * @param creditCardID ID of the credit card.
     */
    _delete(params: { buyerID: string; creditCardID: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CreditCardApiFetchParamCreactor._delete(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param card 
     */
    create(params: { buyerID: string; card: CreditCard;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CreditCardApiFetchParamCreactor.create(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param creditCardID ID of the credit card.
     * @param userID ID of the user.
     * @param userGroupID ID of the user group.
     */
    deleteAssignment(params: { buyerID: string; creditCardID: string; userID?: string; userGroupID?: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CreditCardApiFetchParamCreactor.deleteAssignment(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param creditCardID ID of the credit card.
     */
    get(params: { buyerID: string; creditCardID: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CreditCardApiFetchParamCreactor.get(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    list(params: { buyerID: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CreditCardApiFetchParamCreactor.list(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param creditCardID ID of the credit card.
     * @param userID ID of the user.
     * @param userGroupID ID of the user group.
     * @param level Level of the credit card.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listAssignments(params: { buyerID: string; creditCardID?: string; userID?: string; userGroupID?: string; level?: string; page?: number; pageSize?: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CreditCardApiFetchParamCreactor.listAssignments(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param creditCardID ID of the credit card.
     * @param card 
     */
    patch(params: { buyerID: string; creditCardID: string; card: CreditCard;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CreditCardApiFetchParamCreactor.patch(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param assignment 
     */
    saveAssignment(params: { buyerID: string; assignment: CreditCardAssignment;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CreditCardApiFetchParamCreactor.saveAssignment(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param creditCardID ID of the credit card.
     * @param card 
     */
    update(params: { buyerID: string; creditCardID: string; card: CreditCard;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CreditCardApiFetchParamCreactor.update(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * CreditCardApi - object-oriented interface
 */
export class CreditCardApi extends BaseAPI {
    /** 
     * @param buyerID ID of the buyer.
     * @param creditCardID ID of the credit card.
     */
    _delete(params: {  buyerID: string; creditCardID: string; }) {
        return CreditCardApiFp._delete(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param card 
     */
    create(params: {  buyerID: string; card: CreditCard; }) {
        return CreditCardApiFp.create(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param creditCardID ID of the credit card.
     * @param userID ID of the user.
     * @param userGroupID ID of the user group.
     */
    deleteAssignment(params: {  buyerID: string; creditCardID: string; userID?: string; userGroupID?: string; }) {
        return CreditCardApiFp.deleteAssignment(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param creditCardID ID of the credit card.
     */
    get(params: {  buyerID: string; creditCardID: string; }) {
        return CreditCardApiFp.get(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    list(params: {  buyerID: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
        return CreditCardApiFp.list(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param creditCardID ID of the credit card.
     * @param userID ID of the user.
     * @param userGroupID ID of the user group.
     * @param level Level of the credit card.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listAssignments(params: {  buyerID: string; creditCardID?: string; userID?: string; userGroupID?: string; level?: string; page?: number; pageSize?: number; }) {
        return CreditCardApiFp.listAssignments(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param creditCardID ID of the credit card.
     * @param card 
     */
    patch(params: {  buyerID: string; creditCardID: string; card: CreditCard; }) {
        return CreditCardApiFp.patch(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param assignment 
     */
    saveAssignment(params: {  buyerID: string; assignment: CreditCardAssignment; }) {
        return CreditCardApiFp.saveAssignment(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param creditCardID ID of the credit card.
     * @param card 
     */
    update(params: {  buyerID: string; creditCardID: string; card: CreditCard; }) {
        return CreditCardApiFp.update(params)(this.fetch, this.basePath);
    }
};

/**
 * CreditCardApi - factory interface
 */
export const CreditCardApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * @param buyerID ID of the buyer.
         * @param creditCardID ID of the credit card.
         */
        _delete(params: {  buyerID: string; creditCardID: string; }) {
            return CreditCardApiFp._delete(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param card 
         */
        create(params: {  buyerID: string; card: CreditCard; }) {
            return CreditCardApiFp.create(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param creditCardID ID of the credit card.
         * @param userID ID of the user.
         * @param userGroupID ID of the user group.
         */
        deleteAssignment(params: {  buyerID: string; creditCardID: string; userID?: string; userGroupID?: string; }) {
            return CreditCardApiFp.deleteAssignment(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param creditCardID ID of the credit card.
         */
        get(params: {  buyerID: string; creditCardID: string; }) {
            return CreditCardApiFp.get(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param search Word or phrase to search for.
         * @param searchOn Comma-delimited list of fields to search on.
         * @param sortBy Comma-delimited list of fields to sort by.
         * @param page Page of results to return. Default: 1
         * @param pageSize Number of results to return per page. Default: 20, max: 100.
         */
        list(params: {  buyerID: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
            return CreditCardApiFp.list(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param creditCardID ID of the credit card.
         * @param userID ID of the user.
         * @param userGroupID ID of the user group.
         * @param level Level of the credit card.
         * @param page Page of results to return. Default: 1
         * @param pageSize Number of results to return per page. Default: 20, max: 100.
         */
        listAssignments(params: {  buyerID: string; creditCardID?: string; userID?: string; userGroupID?: string; level?: string; page?: number; pageSize?: number; }) {
            return CreditCardApiFp.listAssignments(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param creditCardID ID of the credit card.
         * @param card 
         */
        patch(params: {  buyerID: string; creditCardID: string; card: CreditCard; }) {
            return CreditCardApiFp.patch(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param assignment 
         */
        saveAssignment(params: {  buyerID: string; assignment: CreditCardAssignment; }) {
            return CreditCardApiFp.saveAssignment(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param creditCardID ID of the credit card.
         * @param card 
         */
        update(params: {  buyerID: string; creditCardID: string; card: CreditCard; }) {
            return CreditCardApiFp.update(params)(fetch, basePath);
        },
    }
};


/**
 * EmailTemplateApi - fetch parameter creator
 */
export const EmailTemplateApiFetchParamCreactor = {
    /** 
     * @param buyerID ID of the buyer.
     * @param emailTemplateType Email template type of the email template. Possible values: OrderSubmittedForApproval, CustomerOrderSubmitted, OrderToApprove, OrderDeclined, OrderApproved, PriceRequestSubmitted, CustomerOrderShipped, ProductRequiresAttachment, InventoryPointReached, LineItemExceedsInventory, PriceRequestResponse, CustomerOrderUpdated, OrderCanceled, PriceRequestCanceled, NewOrderReceived, ApprovalNotification, EmailLoginVerificationCode.
     */
    get(params: {  buyerID: string; emailTemplateType: string; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling get");
        }
        // verify required parameter "emailTemplateType" is set
        if (params["emailTemplateType"] == null) {
            throw new Error("Missing required parameter emailTemplateType when calling get");
        }
        const baseUrl = `/buyers/{buyerID}/emailtemplates/{emailTemplateType}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"emailTemplateType"}}`, `${ params.emailTemplateType }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param emailTemplateType Email template type of the email template. Possible values: OrderSubmittedForApproval, CustomerOrderSubmitted, OrderToApprove, OrderDeclined, OrderApproved, PriceRequestSubmitted, CustomerOrderShipped, ProductRequiresAttachment, InventoryPointReached, LineItemExceedsInventory, PriceRequestResponse, CustomerOrderUpdated, OrderCanceled, PriceRequestCanceled, NewOrderReceived, ApprovalNotification, EmailLoginVerificationCode.
     * @param emailTemplate 
     */
    patch(params: {  buyerID: string; emailTemplateType: string; emailTemplate: EmailTemplate; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling patch");
        }
        // verify required parameter "emailTemplateType" is set
        if (params["emailTemplateType"] == null) {
            throw new Error("Missing required parameter emailTemplateType when calling patch");
        }
        // verify required parameter "emailTemplate" is set
        if (params["emailTemplate"] == null) {
            throw new Error("Missing required parameter emailTemplate when calling patch");
        }
        const baseUrl = `/buyers/{buyerID}/emailtemplates/{emailTemplateType}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"emailTemplateType"}}`, `${ params.emailTemplateType }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PATCH" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["emailTemplate"]) {
            fetchOptions.body = JSON.stringify(params["emailTemplate"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param emailTemplateType Email template type of the email template. Possible values: OrderSubmittedForApproval, CustomerOrderSubmitted, OrderToApprove, OrderDeclined, OrderApproved, PriceRequestSubmitted, CustomerOrderShipped, ProductRequiresAttachment, InventoryPointReached, LineItemExceedsInventory, PriceRequestResponse, CustomerOrderUpdated, OrderCanceled, PriceRequestCanceled, NewOrderReceived, ApprovalNotification, EmailLoginVerificationCode.
     */
    resetToDefault(params: {  buyerID: string; emailTemplateType: string; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling resetToDefault");
        }
        // verify required parameter "emailTemplateType" is set
        if (params["emailTemplateType"] == null) {
            throw new Error("Missing required parameter emailTemplateType when calling resetToDefault");
        }
        const baseUrl = `/buyers/{buyerID}/emailtemplates/{emailTemplateType}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"emailTemplateType"}}`, `${ params.emailTemplateType }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "DELETE" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param emailTemplateType Email template type of the email template. Possible values: OrderSubmittedForApproval, CustomerOrderSubmitted, OrderToApprove, OrderDeclined, OrderApproved, PriceRequestSubmitted, CustomerOrderShipped, ProductRequiresAttachment, InventoryPointReached, LineItemExceedsInventory, PriceRequestResponse, CustomerOrderUpdated, OrderCanceled, PriceRequestCanceled, NewOrderReceived, ApprovalNotification, EmailLoginVerificationCode.
     * @param emailTemplate 
     */
    update(params: {  buyerID: string; emailTemplateType: string; emailTemplate: EmailTemplate; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling update");
        }
        // verify required parameter "emailTemplateType" is set
        if (params["emailTemplateType"] == null) {
            throw new Error("Missing required parameter emailTemplateType when calling update");
        }
        // verify required parameter "emailTemplate" is set
        if (params["emailTemplate"] == null) {
            throw new Error("Missing required parameter emailTemplate when calling update");
        }
        const baseUrl = `/buyers/{buyerID}/emailtemplates/{emailTemplateType}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"emailTemplateType"}}`, `${ params.emailTemplateType }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PUT" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["emailTemplate"]) {
            fetchOptions.body = JSON.stringify(params["emailTemplate"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
}

/**
 * EmailTemplateApi - functional programming interface
 */
export const EmailTemplateApiFp = {
    /** 
     * @param buyerID ID of the buyer.
     * @param emailTemplateType Email template type of the email template. Possible values: OrderSubmittedForApproval, CustomerOrderSubmitted, OrderToApprove, OrderDeclined, OrderApproved, PriceRequestSubmitted, CustomerOrderShipped, ProductRequiresAttachment, InventoryPointReached, LineItemExceedsInventory, PriceRequestResponse, CustomerOrderUpdated, OrderCanceled, PriceRequestCanceled, NewOrderReceived, ApprovalNotification, EmailLoginVerificationCode.
     */
    get(params: { buyerID: string; emailTemplateType: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = EmailTemplateApiFetchParamCreactor.get(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param emailTemplateType Email template type of the email template. Possible values: OrderSubmittedForApproval, CustomerOrderSubmitted, OrderToApprove, OrderDeclined, OrderApproved, PriceRequestSubmitted, CustomerOrderShipped, ProductRequiresAttachment, InventoryPointReached, LineItemExceedsInventory, PriceRequestResponse, CustomerOrderUpdated, OrderCanceled, PriceRequestCanceled, NewOrderReceived, ApprovalNotification, EmailLoginVerificationCode.
     * @param emailTemplate 
     */
    patch(params: { buyerID: string; emailTemplateType: string; emailTemplate: EmailTemplate;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = EmailTemplateApiFetchParamCreactor.patch(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param emailTemplateType Email template type of the email template. Possible values: OrderSubmittedForApproval, CustomerOrderSubmitted, OrderToApprove, OrderDeclined, OrderApproved, PriceRequestSubmitted, CustomerOrderShipped, ProductRequiresAttachment, InventoryPointReached, LineItemExceedsInventory, PriceRequestResponse, CustomerOrderUpdated, OrderCanceled, PriceRequestCanceled, NewOrderReceived, ApprovalNotification, EmailLoginVerificationCode.
     */
    resetToDefault(params: { buyerID: string; emailTemplateType: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = EmailTemplateApiFetchParamCreactor.resetToDefault(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param emailTemplateType Email template type of the email template. Possible values: OrderSubmittedForApproval, CustomerOrderSubmitted, OrderToApprove, OrderDeclined, OrderApproved, PriceRequestSubmitted, CustomerOrderShipped, ProductRequiresAttachment, InventoryPointReached, LineItemExceedsInventory, PriceRequestResponse, CustomerOrderUpdated, OrderCanceled, PriceRequestCanceled, NewOrderReceived, ApprovalNotification, EmailLoginVerificationCode.
     * @param emailTemplate 
     */
    update(params: { buyerID: string; emailTemplateType: string; emailTemplate: EmailTemplate;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = EmailTemplateApiFetchParamCreactor.update(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * EmailTemplateApi - object-oriented interface
 */
export class EmailTemplateApi extends BaseAPI {
    /** 
     * @param buyerID ID of the buyer.
     * @param emailTemplateType Email template type of the email template. Possible values: OrderSubmittedForApproval, CustomerOrderSubmitted, OrderToApprove, OrderDeclined, OrderApproved, PriceRequestSubmitted, CustomerOrderShipped, ProductRequiresAttachment, InventoryPointReached, LineItemExceedsInventory, PriceRequestResponse, CustomerOrderUpdated, OrderCanceled, PriceRequestCanceled, NewOrderReceived, ApprovalNotification, EmailLoginVerificationCode.
     */
    get(params: {  buyerID: string; emailTemplateType: string; }) {
        return EmailTemplateApiFp.get(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param emailTemplateType Email template type of the email template. Possible values: OrderSubmittedForApproval, CustomerOrderSubmitted, OrderToApprove, OrderDeclined, OrderApproved, PriceRequestSubmitted, CustomerOrderShipped, ProductRequiresAttachment, InventoryPointReached, LineItemExceedsInventory, PriceRequestResponse, CustomerOrderUpdated, OrderCanceled, PriceRequestCanceled, NewOrderReceived, ApprovalNotification, EmailLoginVerificationCode.
     * @param emailTemplate 
     */
    patch(params: {  buyerID: string; emailTemplateType: string; emailTemplate: EmailTemplate; }) {
        return EmailTemplateApiFp.patch(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param emailTemplateType Email template type of the email template. Possible values: OrderSubmittedForApproval, CustomerOrderSubmitted, OrderToApprove, OrderDeclined, OrderApproved, PriceRequestSubmitted, CustomerOrderShipped, ProductRequiresAttachment, InventoryPointReached, LineItemExceedsInventory, PriceRequestResponse, CustomerOrderUpdated, OrderCanceled, PriceRequestCanceled, NewOrderReceived, ApprovalNotification, EmailLoginVerificationCode.
     */
    resetToDefault(params: {  buyerID: string; emailTemplateType: string; }) {
        return EmailTemplateApiFp.resetToDefault(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param emailTemplateType Email template type of the email template. Possible values: OrderSubmittedForApproval, CustomerOrderSubmitted, OrderToApprove, OrderDeclined, OrderApproved, PriceRequestSubmitted, CustomerOrderShipped, ProductRequiresAttachment, InventoryPointReached, LineItemExceedsInventory, PriceRequestResponse, CustomerOrderUpdated, OrderCanceled, PriceRequestCanceled, NewOrderReceived, ApprovalNotification, EmailLoginVerificationCode.
     * @param emailTemplate 
     */
    update(params: {  buyerID: string; emailTemplateType: string; emailTemplate: EmailTemplate; }) {
        return EmailTemplateApiFp.update(params)(this.fetch, this.basePath);
    }
};

/**
 * EmailTemplateApi - factory interface
 */
export const EmailTemplateApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * @param buyerID ID of the buyer.
         * @param emailTemplateType Email template type of the email template. Possible values: OrderSubmittedForApproval, CustomerOrderSubmitted, OrderToApprove, OrderDeclined, OrderApproved, PriceRequestSubmitted, CustomerOrderShipped, ProductRequiresAttachment, InventoryPointReached, LineItemExceedsInventory, PriceRequestResponse, CustomerOrderUpdated, OrderCanceled, PriceRequestCanceled, NewOrderReceived, ApprovalNotification, EmailLoginVerificationCode.
         */
        get(params: {  buyerID: string; emailTemplateType: string; }) {
            return EmailTemplateApiFp.get(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param emailTemplateType Email template type of the email template. Possible values: OrderSubmittedForApproval, CustomerOrderSubmitted, OrderToApprove, OrderDeclined, OrderApproved, PriceRequestSubmitted, CustomerOrderShipped, ProductRequiresAttachment, InventoryPointReached, LineItemExceedsInventory, PriceRequestResponse, CustomerOrderUpdated, OrderCanceled, PriceRequestCanceled, NewOrderReceived, ApprovalNotification, EmailLoginVerificationCode.
         * @param emailTemplate 
         */
        patch(params: {  buyerID: string; emailTemplateType: string; emailTemplate: EmailTemplate; }) {
            return EmailTemplateApiFp.patch(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param emailTemplateType Email template type of the email template. Possible values: OrderSubmittedForApproval, CustomerOrderSubmitted, OrderToApprove, OrderDeclined, OrderApproved, PriceRequestSubmitted, CustomerOrderShipped, ProductRequiresAttachment, InventoryPointReached, LineItemExceedsInventory, PriceRequestResponse, CustomerOrderUpdated, OrderCanceled, PriceRequestCanceled, NewOrderReceived, ApprovalNotification, EmailLoginVerificationCode.
         */
        resetToDefault(params: {  buyerID: string; emailTemplateType: string; }) {
            return EmailTemplateApiFp.resetToDefault(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param emailTemplateType Email template type of the email template. Possible values: OrderSubmittedForApproval, CustomerOrderSubmitted, OrderToApprove, OrderDeclined, OrderApproved, PriceRequestSubmitted, CustomerOrderShipped, ProductRequiresAttachment, InventoryPointReached, LineItemExceedsInventory, PriceRequestResponse, CustomerOrderUpdated, OrderCanceled, PriceRequestCanceled, NewOrderReceived, ApprovalNotification, EmailLoginVerificationCode.
         * @param emailTemplate 
         */
        update(params: {  buyerID: string; emailTemplateType: string; emailTemplate: EmailTemplate; }) {
            return EmailTemplateApiFp.update(params)(fetch, basePath);
        },
    }
};


/**
 * FileApi - fetch parameter creator
 */
export const FileApiFetchParamCreactor = {
    /** 
     * @param fileID ID of the file.
     */
    get(params: {  fileID: string; }): FetchArgs {
        // verify required parameter "fileID" is set
        if (params["fileID"] == null) {
            throw new Error("Missing required parameter fileID when calling get");
        }
        const baseUrl = `/files/{fileID}`
            .replace(`{${"fileID"}}`, `${ params.fileID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    list(params: {  page?: number; pageSize?: number; }): FetchArgs {
        const baseUrl = `/files`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "page": params.page,
            "pageSize": params.pageSize,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param filename Filename of the file.
     */
    postFileData(params: {  filename?: string; }): FetchArgs {
        const baseUrl = `/files`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "filename": params.filename,
        });
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
}

/**
 * FileApi - functional programming interface
 */
export const FileApiFp = {
    /** 
     * @param fileID ID of the file.
     */
    get(params: { fileID: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = FileApiFetchParamCreactor.get(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    list(params: { page?: number; pageSize?: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = FileApiFetchParamCreactor.list(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param filename Filename of the file.
     */
    postFileData(params: { filename?: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = FileApiFetchParamCreactor.postFileData(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * FileApi - object-oriented interface
 */
export class FileApi extends BaseAPI {
    /** 
     * @param fileID ID of the file.
     */
    get(params: {  fileID: string; }) {
        return FileApiFp.get(params)(this.fetch, this.basePath);
    }
    /** 
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    list(params: {  page?: number; pageSize?: number; }) {
        return FileApiFp.list(params)(this.fetch, this.basePath);
    }
    /** 
     * @param filename Filename of the file.
     */
    postFileData(params: {  filename?: string; }) {
        return FileApiFp.postFileData(params)(this.fetch, this.basePath);
    }
};

/**
 * FileApi - factory interface
 */
export const FileApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * @param fileID ID of the file.
         */
        get(params: {  fileID: string; }) {
            return FileApiFp.get(params)(fetch, basePath);
        },
        /** 
         * @param page Page of results to return. Default: 1
         * @param pageSize Number of results to return per page. Default: 20, max: 100.
         */
        list(params: {  page?: number; pageSize?: number; }) {
            return FileApiFp.list(params)(fetch, basePath);
        },
        /** 
         * @param filename Filename of the file.
         */
        postFileData(params: {  filename?: string; }) {
            return FileApiFp.postFileData(params)(fetch, basePath);
        },
    }
};


/**
 * LineItemApi - fetch parameter creator
 */
export const LineItemApiFetchParamCreactor = {
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param lineItemID ID of the line item.
     */
    _delete(params: {  buyerID: string; orderID: string; lineItemID: string; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling _delete");
        }
        // verify required parameter "orderID" is set
        if (params["orderID"] == null) {
            throw new Error("Missing required parameter orderID when calling _delete");
        }
        // verify required parameter "lineItemID" is set
        if (params["lineItemID"] == null) {
            throw new Error("Missing required parameter lineItemID when calling _delete");
        }
        const baseUrl = `/buyers/{buyerID}/orders/{orderID}/lineitems/{lineItemID}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"orderID"}}`, `${ params.orderID }`)
            .replace(`{${"lineItemID"}}`, `${ params.lineItemID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "DELETE" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param lineItem 
     */
    create(params: {  buyerID: string; orderID: string; lineItem: LineItem; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling create");
        }
        // verify required parameter "orderID" is set
        if (params["orderID"] == null) {
            throw new Error("Missing required parameter orderID when calling create");
        }
        // verify required parameter "lineItem" is set
        if (params["lineItem"] == null) {
            throw new Error("Missing required parameter lineItem when calling create");
        }
        const baseUrl = `/buyers/{buyerID}/orders/{orderID}/lineitems`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"orderID"}}`, `${ params.orderID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["lineItem"]) {
            fetchOptions.body = JSON.stringify(params["lineItem"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param lineItemID ID of the line item.
     */
    get(params: {  buyerID: string; orderID: string; lineItemID: string; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling get");
        }
        // verify required parameter "orderID" is set
        if (params["orderID"] == null) {
            throw new Error("Missing required parameter orderID when calling get");
        }
        // verify required parameter "lineItemID" is set
        if (params["lineItemID"] == null) {
            throw new Error("Missing required parameter lineItemID when calling get");
        }
        const baseUrl = `/buyers/{buyerID}/orders/{orderID}/lineitems/{lineItemID}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"orderID"}}`, `${ params.orderID }`)
            .replace(`{${"lineItemID"}}`, `${ params.lineItemID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    list(params: {  buyerID: string; orderID: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling list");
        }
        // verify required parameter "orderID" is set
        if (params["orderID"] == null) {
            throw new Error("Missing required parameter orderID when calling list");
        }
        const baseUrl = `/buyers/{buyerID}/orders/{orderID}/lineitems`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"orderID"}}`, `${ params.orderID }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "search": params.search,
            "searchOn": params.searchOn,
            "sortBy": params.sortBy,
            "page": params.page,
            "pageSize": params.pageSize,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param lineItemID ID of the line item.
     * @param partialLineItem 
     */
    patch(params: {  buyerID: string; orderID: string; lineItemID: string; partialLineItem: LineItem; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling patch");
        }
        // verify required parameter "orderID" is set
        if (params["orderID"] == null) {
            throw new Error("Missing required parameter orderID when calling patch");
        }
        // verify required parameter "lineItemID" is set
        if (params["lineItemID"] == null) {
            throw new Error("Missing required parameter lineItemID when calling patch");
        }
        // verify required parameter "partialLineItem" is set
        if (params["partialLineItem"] == null) {
            throw new Error("Missing required parameter partialLineItem when calling patch");
        }
        const baseUrl = `/buyers/{buyerID}/orders/{orderID}/lineitems/{lineItemID}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"orderID"}}`, `${ params.orderID }`)
            .replace(`{${"lineItemID"}}`, `${ params.lineItemID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PATCH" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["partialLineItem"]) {
            fetchOptions.body = JSON.stringify(params["partialLineItem"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param lineItemID ID of the line item.
     * @param address 
     */
    patchShippingAddress(params: {  buyerID: string; orderID: string; lineItemID: string; address: Address; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling patchShippingAddress");
        }
        // verify required parameter "orderID" is set
        if (params["orderID"] == null) {
            throw new Error("Missing required parameter orderID when calling patchShippingAddress");
        }
        // verify required parameter "lineItemID" is set
        if (params["lineItemID"] == null) {
            throw new Error("Missing required parameter lineItemID when calling patchShippingAddress");
        }
        // verify required parameter "address" is set
        if (params["address"] == null) {
            throw new Error("Missing required parameter address when calling patchShippingAddress");
        }
        const baseUrl = `/buyers/{buyerID}/orders/{orderID}/lineitems/{lineItemID}/shipto`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"orderID"}}`, `${ params.orderID }`)
            .replace(`{${"lineItemID"}}`, `${ params.lineItemID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PATCH" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["address"]) {
            fetchOptions.body = JSON.stringify(params["address"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param lineItemID ID of the line item.
     * @param address 
     */
    setShippingAddress(params: {  buyerID: string; orderID: string; lineItemID: string; address: Address; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling setShippingAddress");
        }
        // verify required parameter "orderID" is set
        if (params["orderID"] == null) {
            throw new Error("Missing required parameter orderID when calling setShippingAddress");
        }
        // verify required parameter "lineItemID" is set
        if (params["lineItemID"] == null) {
            throw new Error("Missing required parameter lineItemID when calling setShippingAddress");
        }
        // verify required parameter "address" is set
        if (params["address"] == null) {
            throw new Error("Missing required parameter address when calling setShippingAddress");
        }
        const baseUrl = `/buyers/{buyerID}/orders/{orderID}/lineitems/{lineItemID}/shipto`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"orderID"}}`, `${ params.orderID }`)
            .replace(`{${"lineItemID"}}`, `${ params.lineItemID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PUT" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["address"]) {
            fetchOptions.body = JSON.stringify(params["address"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param lineItemID ID of the line item.
     * @param lineItem 
     */
    update(params: {  buyerID: string; orderID: string; lineItemID: string; lineItem: LineItem; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling update");
        }
        // verify required parameter "orderID" is set
        if (params["orderID"] == null) {
            throw new Error("Missing required parameter orderID when calling update");
        }
        // verify required parameter "lineItemID" is set
        if (params["lineItemID"] == null) {
            throw new Error("Missing required parameter lineItemID when calling update");
        }
        // verify required parameter "lineItem" is set
        if (params["lineItem"] == null) {
            throw new Error("Missing required parameter lineItem when calling update");
        }
        const baseUrl = `/buyers/{buyerID}/orders/{orderID}/lineitems/{lineItemID}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"orderID"}}`, `${ params.orderID }`)
            .replace(`{${"lineItemID"}}`, `${ params.lineItemID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PUT" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["lineItem"]) {
            fetchOptions.body = JSON.stringify(params["lineItem"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
}

/**
 * LineItemApi - functional programming interface
 */
export const LineItemApiFp = {
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param lineItemID ID of the line item.
     */
    _delete(params: { buyerID: string; orderID: string; lineItemID: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = LineItemApiFetchParamCreactor._delete(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param lineItem 
     */
    create(params: { buyerID: string; orderID: string; lineItem: LineItem;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = LineItemApiFetchParamCreactor.create(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param lineItemID ID of the line item.
     */
    get(params: { buyerID: string; orderID: string; lineItemID: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = LineItemApiFetchParamCreactor.get(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    list(params: { buyerID: string; orderID: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = LineItemApiFetchParamCreactor.list(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param lineItemID ID of the line item.
     * @param partialLineItem 
     */
    patch(params: { buyerID: string; orderID: string; lineItemID: string; partialLineItem: LineItem;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = LineItemApiFetchParamCreactor.patch(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param lineItemID ID of the line item.
     * @param address 
     */
    patchShippingAddress(params: { buyerID: string; orderID: string; lineItemID: string; address: Address;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = LineItemApiFetchParamCreactor.patchShippingAddress(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param lineItemID ID of the line item.
     * @param address 
     */
    setShippingAddress(params: { buyerID: string; orderID: string; lineItemID: string; address: Address;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = LineItemApiFetchParamCreactor.setShippingAddress(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param lineItemID ID of the line item.
     * @param lineItem 
     */
    update(params: { buyerID: string; orderID: string; lineItemID: string; lineItem: LineItem;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = LineItemApiFetchParamCreactor.update(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * LineItemApi - object-oriented interface
 */
export class LineItemApi extends BaseAPI {
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param lineItemID ID of the line item.
     */
    _delete(params: {  buyerID: string; orderID: string; lineItemID: string; }) {
        return LineItemApiFp._delete(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param lineItem 
     */
    create(params: {  buyerID: string; orderID: string; lineItem: LineItem; }) {
        return LineItemApiFp.create(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param lineItemID ID of the line item.
     */
    get(params: {  buyerID: string; orderID: string; lineItemID: string; }) {
        return LineItemApiFp.get(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    list(params: {  buyerID: string; orderID: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
        return LineItemApiFp.list(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param lineItemID ID of the line item.
     * @param partialLineItem 
     */
    patch(params: {  buyerID: string; orderID: string; lineItemID: string; partialLineItem: LineItem; }) {
        return LineItemApiFp.patch(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param lineItemID ID of the line item.
     * @param address 
     */
    patchShippingAddress(params: {  buyerID: string; orderID: string; lineItemID: string; address: Address; }) {
        return LineItemApiFp.patchShippingAddress(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param lineItemID ID of the line item.
     * @param address 
     */
    setShippingAddress(params: {  buyerID: string; orderID: string; lineItemID: string; address: Address; }) {
        return LineItemApiFp.setShippingAddress(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param lineItemID ID of the line item.
     * @param lineItem 
     */
    update(params: {  buyerID: string; orderID: string; lineItemID: string; lineItem: LineItem; }) {
        return LineItemApiFp.update(params)(this.fetch, this.basePath);
    }
};

/**
 * LineItemApi - factory interface
 */
export const LineItemApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * @param buyerID ID of the buyer.
         * @param orderID ID of the order.
         * @param lineItemID ID of the line item.
         */
        _delete(params: {  buyerID: string; orderID: string; lineItemID: string; }) {
            return LineItemApiFp._delete(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param orderID ID of the order.
         * @param lineItem 
         */
        create(params: {  buyerID: string; orderID: string; lineItem: LineItem; }) {
            return LineItemApiFp.create(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param orderID ID of the order.
         * @param lineItemID ID of the line item.
         */
        get(params: {  buyerID: string; orderID: string; lineItemID: string; }) {
            return LineItemApiFp.get(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param orderID ID of the order.
         * @param search Word or phrase to search for.
         * @param searchOn Comma-delimited list of fields to search on.
         * @param sortBy Comma-delimited list of fields to sort by.
         * @param page Page of results to return. Default: 1
         * @param pageSize Number of results to return per page. Default: 20, max: 100.
         */
        list(params: {  buyerID: string; orderID: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
            return LineItemApiFp.list(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param orderID ID of the order.
         * @param lineItemID ID of the line item.
         * @param partialLineItem 
         */
        patch(params: {  buyerID: string; orderID: string; lineItemID: string; partialLineItem: LineItem; }) {
            return LineItemApiFp.patch(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param orderID ID of the order.
         * @param lineItemID ID of the line item.
         * @param address 
         */
        patchShippingAddress(params: {  buyerID: string; orderID: string; lineItemID: string; address: Address; }) {
            return LineItemApiFp.patchShippingAddress(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param orderID ID of the order.
         * @param lineItemID ID of the line item.
         * @param address 
         */
        setShippingAddress(params: {  buyerID: string; orderID: string; lineItemID: string; address: Address; }) {
            return LineItemApiFp.setShippingAddress(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param orderID ID of the order.
         * @param lineItemID ID of the line item.
         * @param lineItem 
         */
        update(params: {  buyerID: string; orderID: string; lineItemID: string; lineItem: LineItem; }) {
            return LineItemApiFp.update(params)(fetch, basePath);
        },
    }
};


/**
 * MeApi - fetch parameter creator
 */
export const MeApiFetchParamCreactor = {
    /** 
     * @param address 
     */
    createAddress(params: {  address: BuyerAddress; }): FetchArgs {
        // verify required parameter "address" is set
        if (params["address"] == null) {
            throw new Error("Missing required parameter address when calling createAddress");
        }
        const baseUrl = `/me/addresses`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["address"]) {
            fetchOptions.body = JSON.stringify(params["address"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param creditCard 
     */
    createCreditCard(params: {  creditCard: BuyerCreditCard; }): FetchArgs {
        // verify required parameter "creditCard" is set
        if (params["creditCard"] == null) {
            throw new Error("Missing required parameter creditCard when calling createCreditCard");
        }
        const baseUrl = `/me/creditcards`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["creditCard"]) {
            fetchOptions.body = JSON.stringify(params["creditCard"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param addressID ID of the address.
     */
    deleteAddress(params: {  addressID: string; }): FetchArgs {
        // verify required parameter "addressID" is set
        if (params["addressID"] == null) {
            throw new Error("Missing required parameter addressID when calling deleteAddress");
        }
        const baseUrl = `/me/addresses/{addressID}`
            .replace(`{${"addressID"}}`, `${ params.addressID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "DELETE" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param creditcardID ID of the creditcard.
     */
    deleteCreditCard(params: {  creditcardID: string; }): FetchArgs {
        // verify required parameter "creditcardID" is set
        if (params["creditcardID"] == null) {
            throw new Error("Missing required parameter creditcardID when calling deleteCreditCard");
        }
        const baseUrl = `/me/creditcards/{creditcardID}`
            .replace(`{${"creditcardID"}}`, `${ params.creditcardID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "DELETE" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     */
    get(): FetchArgs {
        const baseUrl = `/me`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param addressID ID of the address.
     */
    getAddress(params: {  addressID: string; }): FetchArgs {
        // verify required parameter "addressID" is set
        if (params["addressID"] == null) {
            throw new Error("Missing required parameter addressID when calling getAddress");
        }
        const baseUrl = `/me/addresses/{addressID}`
            .replace(`{${"addressID"}}`, `${ params.addressID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param creditcardID ID of the creditcard.
     */
    getCreditCard(params: {  creditcardID: string; }): FetchArgs {
        // verify required parameter "creditcardID" is set
        if (params["creditcardID"] == null) {
            throw new Error("Missing required parameter creditcardID when calling getCreditCard");
        }
        const baseUrl = `/me/creditcards/{creditcardID}`
            .replace(`{${"creditcardID"}}`, `${ params.creditcardID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param orderID ID of the order.
     */
    getOrder(params: {  orderID: string; }): FetchArgs {
        // verify required parameter "orderID" is set
        if (params["orderID"] == null) {
            throw new Error("Missing required parameter orderID when calling getOrder");
        }
        const baseUrl = `/me/orders/{orderID}`
            .replace(`{${"orderID"}}`, `${ params.orderID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param productID ID of the product.
     */
    getProduct(params: {  productID: string; }): FetchArgs {
        // verify required parameter "productID" is set
        if (params["productID"] == null) {
            throw new Error("Missing required parameter productID when calling getProduct");
        }
        const baseUrl = `/me/products/{productID}`
            .replace(`{${"productID"}}`, `${ params.productID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param promotionID ID of the promotion.
     */
    getPromotion(params: {  promotionID: string; }): FetchArgs {
        // verify required parameter "promotionID" is set
        if (params["promotionID"] == null) {
            throw new Error("Missing required parameter promotionID when calling getPromotion");
        }
        const baseUrl = `/me/promotions/{promotionID}`
            .replace(`{${"promotionID"}}`, `${ params.promotionID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param productID ID of the product.
     * @param specID ID of the spec.
     */
    getSpec(params: {  productID: string; specID: string; }): FetchArgs {
        // verify required parameter "productID" is set
        if (params["productID"] == null) {
            throw new Error("Missing required parameter productID when calling getSpec");
        }
        // verify required parameter "specID" is set
        if (params["specID"] == null) {
            throw new Error("Missing required parameter specID when calling getSpec");
        }
        const baseUrl = `/me/products/{productID}/specs/{specID}`
            .replace(`{${"productID"}}`, `${ params.productID }`)
            .replace(`{${"specID"}}`, `${ params.specID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listAddresses(params: {  search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }): FetchArgs {
        const baseUrl = `/me/addresses`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "search": params.search,
            "searchOn": params.searchOn,
            "sortBy": params.sortBy,
            "page": params.page,
            "pageSize": params.pageSize,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param depth Depth of the category.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listCategories(params: {  depth?: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }): FetchArgs {
        const baseUrl = `/me/categories`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "depth": params.depth,
            "search": params.search,
            "searchOn": params.searchOn,
            "sortBy": params.sortBy,
            "page": params.page,
            "pageSize": params.pageSize,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listCostCenters(params: {  search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }): FetchArgs {
        const baseUrl = `/me/costcenters`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "search": params.search,
            "searchOn": params.searchOn,
            "sortBy": params.sortBy,
            "page": params.page,
            "pageSize": params.pageSize,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listCreditCards(params: {  search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }): FetchArgs {
        const baseUrl = `/me/creditcards`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "search": params.search,
            "searchOn": params.searchOn,
            "sortBy": params.sortBy,
            "page": params.page,
            "pageSize": params.pageSize,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param from Lower bound of date range that the order was created (if outgoing) or submitted (if incoming).
     * @param to Upper bound of date range that the order was created (if outgoing) or submitted (if incoming).
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listIncomingOrders(params: {  from?: string; to?: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }): FetchArgs {
        const baseUrl = `/me/orders/incoming`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "from": params.from,
            "to": params.to,
            "search": params.search,
            "searchOn": params.searchOn,
            "sortBy": params.sortBy,
            "page": params.page,
            "pageSize": params.pageSize,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param from Lower bound of date range that the order was created (if outgoing) or submitted (if incoming).
     * @param to Upper bound of date range that the order was created (if outgoing) or submitted (if incoming).
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listOutgoingOrders(params: {  from?: string; to?: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }): FetchArgs {
        const baseUrl = `/me/orders/outgoing`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "from": params.from,
            "to": params.to,
            "search": params.search,
            "searchOn": params.searchOn,
            "sortBy": params.sortBy,
            "page": params.page,
            "pageSize": params.pageSize,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param categoryID ID of the category.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listProducts(params: {  categoryID?: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }): FetchArgs {
        const baseUrl = `/me/products`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "categoryID": params.categoryID,
            "search": params.search,
            "searchOn": params.searchOn,
            "sortBy": params.sortBy,
            "page": params.page,
            "pageSize": params.pageSize,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listPromotions(params: {  search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }): FetchArgs {
        const baseUrl = `/me/promotions`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "search": params.search,
            "searchOn": params.searchOn,
            "sortBy": params.sortBy,
            "page": params.page,
            "pageSize": params.pageSize,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param productID ID of the product.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listSpecs(params: {  productID: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }): FetchArgs {
        // verify required parameter "productID" is set
        if (params["productID"] == null) {
            throw new Error("Missing required parameter productID when calling listSpecs");
        }
        const baseUrl = `/me/products/{productID}/specs`
            .replace(`{${"productID"}}`, `${ params.productID }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "search": params.search,
            "searchOn": params.searchOn,
            "sortBy": params.sortBy,
            "page": params.page,
            "pageSize": params.pageSize,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param parentID ID of the parent.
     * @param depth Depth of the category.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listSubcategories(params: {  parentID: string; depth?: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }): FetchArgs {
        // verify required parameter "parentID" is set
        if (params["parentID"] == null) {
            throw new Error("Missing required parameter parentID when calling listSubcategories");
        }
        const baseUrl = `/me/categories/{parentID}/categories`
            .replace(`{${"parentID"}}`, `${ params.parentID }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "depth": params.depth,
            "search": params.search,
            "searchOn": params.searchOn,
            "sortBy": params.sortBy,
            "page": params.page,
            "pageSize": params.pageSize,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listUserGroups(params: {  search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }): FetchArgs {
        const baseUrl = `/me/usergroups`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "search": params.search,
            "searchOn": params.searchOn,
            "sortBy": params.sortBy,
            "page": params.page,
            "pageSize": params.pageSize,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param user 
     */
    patch(params: {  user: User; }): FetchArgs {
        // verify required parameter "user" is set
        if (params["user"] == null) {
            throw new Error("Missing required parameter user when calling patch");
        }
        const baseUrl = `/me`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PATCH" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["user"]) {
            fetchOptions.body = JSON.stringify(params["user"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param addressID ID of the address.
     * @param address 
     */
    patchAddress(params: {  addressID: string; address: BuyerAddress; }): FetchArgs {
        // verify required parameter "addressID" is set
        if (params["addressID"] == null) {
            throw new Error("Missing required parameter addressID when calling patchAddress");
        }
        // verify required parameter "address" is set
        if (params["address"] == null) {
            throw new Error("Missing required parameter address when calling patchAddress");
        }
        const baseUrl = `/me/addresses/{addressID}`
            .replace(`{${"addressID"}}`, `${ params.addressID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PATCH" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["address"]) {
            fetchOptions.body = JSON.stringify(params["address"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param creditcardID ID of the creditcard.
     * @param creditCard 
     */
    patchCreditCard(params: {  creditcardID: string; creditCard: BuyerCreditCard; }): FetchArgs {
        // verify required parameter "creditcardID" is set
        if (params["creditcardID"] == null) {
            throw new Error("Missing required parameter creditcardID when calling patchCreditCard");
        }
        // verify required parameter "creditCard" is set
        if (params["creditCard"] == null) {
            throw new Error("Missing required parameter creditCard when calling patchCreditCard");
        }
        const baseUrl = `/me/creditcards/{creditcardID}`
            .replace(`{${"creditcardID"}}`, `${ params.creditcardID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PATCH" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["creditCard"]) {
            fetchOptions.body = JSON.stringify(params["creditCard"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param user 
     */
    update(params: {  user: User; }): FetchArgs {
        // verify required parameter "user" is set
        if (params["user"] == null) {
            throw new Error("Missing required parameter user when calling update");
        }
        const baseUrl = `/me`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PUT" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["user"]) {
            fetchOptions.body = JSON.stringify(params["user"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param addressID ID of the address.
     * @param address 
     */
    updateAddress(params: {  addressID: string; address: BuyerAddress; }): FetchArgs {
        // verify required parameter "addressID" is set
        if (params["addressID"] == null) {
            throw new Error("Missing required parameter addressID when calling updateAddress");
        }
        // verify required parameter "address" is set
        if (params["address"] == null) {
            throw new Error("Missing required parameter address when calling updateAddress");
        }
        const baseUrl = `/me/addresses/{addressID}`
            .replace(`{${"addressID"}}`, `${ params.addressID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PUT" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["address"]) {
            fetchOptions.body = JSON.stringify(params["address"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param creditcardID ID of the creditcard.
     * @param creditCard 
     */
    updateCreditCard(params: {  creditcardID: string; creditCard: BuyerCreditCard; }): FetchArgs {
        // verify required parameter "creditcardID" is set
        if (params["creditcardID"] == null) {
            throw new Error("Missing required parameter creditcardID when calling updateCreditCard");
        }
        // verify required parameter "creditCard" is set
        if (params["creditCard"] == null) {
            throw new Error("Missing required parameter creditCard when calling updateCreditCard");
        }
        const baseUrl = `/me/creditcards/{creditcardID}`
            .replace(`{${"creditcardID"}}`, `${ params.creditcardID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PUT" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["creditCard"]) {
            fetchOptions.body = JSON.stringify(params["creditCard"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
}

/**
 * MeApi - functional programming interface
 */
export const MeApiFp = {
    /** 
     * @param address 
     */
    createAddress(params: { address: BuyerAddress;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MeApiFetchParamCreactor.createAddress(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param creditCard 
     */
    createCreditCard(params: { creditCard: BuyerCreditCard;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MeApiFetchParamCreactor.createCreditCard(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param addressID ID of the address.
     */
    deleteAddress(params: { addressID: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MeApiFetchParamCreactor.deleteAddress(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param creditcardID ID of the creditcard.
     */
    deleteCreditCard(params: { creditcardID: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MeApiFetchParamCreactor.deleteCreditCard(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     */
    get(): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MeApiFetchParamCreactor.get();
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param addressID ID of the address.
     */
    getAddress(params: { addressID: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MeApiFetchParamCreactor.getAddress(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param creditcardID ID of the creditcard.
     */
    getCreditCard(params: { creditcardID: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MeApiFetchParamCreactor.getCreditCard(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param orderID ID of the order.
     */
    getOrder(params: { orderID: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MeApiFetchParamCreactor.getOrder(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param productID ID of the product.
     */
    getProduct(params: { productID: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MeApiFetchParamCreactor.getProduct(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param promotionID ID of the promotion.
     */
    getPromotion(params: { promotionID: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MeApiFetchParamCreactor.getPromotion(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param productID ID of the product.
     * @param specID ID of the spec.
     */
    getSpec(params: { productID: string; specID: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MeApiFetchParamCreactor.getSpec(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listAddresses(params: { search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MeApiFetchParamCreactor.listAddresses(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param depth Depth of the category.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listCategories(params: { depth?: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MeApiFetchParamCreactor.listCategories(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listCostCenters(params: { search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MeApiFetchParamCreactor.listCostCenters(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listCreditCards(params: { search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MeApiFetchParamCreactor.listCreditCards(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param from Lower bound of date range that the order was created (if outgoing) or submitted (if incoming).
     * @param to Upper bound of date range that the order was created (if outgoing) or submitted (if incoming).
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listIncomingOrders(params: { from?: string; to?: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MeApiFetchParamCreactor.listIncomingOrders(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param from Lower bound of date range that the order was created (if outgoing) or submitted (if incoming).
     * @param to Upper bound of date range that the order was created (if outgoing) or submitted (if incoming).
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listOutgoingOrders(params: { from?: string; to?: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MeApiFetchParamCreactor.listOutgoingOrders(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param categoryID ID of the category.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listProducts(params: { categoryID?: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MeApiFetchParamCreactor.listProducts(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listPromotions(params: { search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MeApiFetchParamCreactor.listPromotions(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param productID ID of the product.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listSpecs(params: { productID: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MeApiFetchParamCreactor.listSpecs(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param parentID ID of the parent.
     * @param depth Depth of the category.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listSubcategories(params: { parentID: string; depth?: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MeApiFetchParamCreactor.listSubcategories(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listUserGroups(params: { search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MeApiFetchParamCreactor.listUserGroups(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param user 
     */
    patch(params: { user: User;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MeApiFetchParamCreactor.patch(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param addressID ID of the address.
     * @param address 
     */
    patchAddress(params: { addressID: string; address: BuyerAddress;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MeApiFetchParamCreactor.patchAddress(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param creditcardID ID of the creditcard.
     * @param creditCard 
     */
    patchCreditCard(params: { creditcardID: string; creditCard: BuyerCreditCard;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MeApiFetchParamCreactor.patchCreditCard(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param user 
     */
    update(params: { user: User;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MeApiFetchParamCreactor.update(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param addressID ID of the address.
     * @param address 
     */
    updateAddress(params: { addressID: string; address: BuyerAddress;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MeApiFetchParamCreactor.updateAddress(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param creditcardID ID of the creditcard.
     * @param creditCard 
     */
    updateCreditCard(params: { creditcardID: string; creditCard: BuyerCreditCard;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MeApiFetchParamCreactor.updateCreditCard(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * MeApi - object-oriented interface
 */
export class MeApi extends BaseAPI {
    /** 
     * @param address 
     */
    createAddress(params: {  address: BuyerAddress; }) {
        return MeApiFp.createAddress(params)(this.fetch, this.basePath);
    }
    /** 
     * @param creditCard 
     */
    createCreditCard(params: {  creditCard: BuyerCreditCard; }) {
        return MeApiFp.createCreditCard(params)(this.fetch, this.basePath);
    }
    /** 
     * @param addressID ID of the address.
     */
    deleteAddress(params: {  addressID: string; }) {
        return MeApiFp.deleteAddress(params)(this.fetch, this.basePath);
    }
    /** 
     * @param creditcardID ID of the creditcard.
     */
    deleteCreditCard(params: {  creditcardID: string; }) {
        return MeApiFp.deleteCreditCard(params)(this.fetch, this.basePath);
    }
    /** 
     */
    get() {
        return MeApiFp.get()(this.fetch, this.basePath);
    }
    /** 
     * @param addressID ID of the address.
     */
    getAddress(params: {  addressID: string; }) {
        return MeApiFp.getAddress(params)(this.fetch, this.basePath);
    }
    /** 
     * @param creditcardID ID of the creditcard.
     */
    getCreditCard(params: {  creditcardID: string; }) {
        return MeApiFp.getCreditCard(params)(this.fetch, this.basePath);
    }
    /** 
     * @param orderID ID of the order.
     */
    getOrder(params: {  orderID: string; }) {
        return MeApiFp.getOrder(params)(this.fetch, this.basePath);
    }
    /** 
     * @param productID ID of the product.
     */
    getProduct(params: {  productID: string; }) {
        return MeApiFp.getProduct(params)(this.fetch, this.basePath);
    }
    /** 
     * @param promotionID ID of the promotion.
     */
    getPromotion(params: {  promotionID: string; }) {
        return MeApiFp.getPromotion(params)(this.fetch, this.basePath);
    }
    /** 
     * @param productID ID of the product.
     * @param specID ID of the spec.
     */
    getSpec(params: {  productID: string; specID: string; }) {
        return MeApiFp.getSpec(params)(this.fetch, this.basePath);
    }
    /** 
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listAddresses(params: {  search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
        return MeApiFp.listAddresses(params)(this.fetch, this.basePath);
    }
    /** 
     * @param depth Depth of the category.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listCategories(params: {  depth?: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
        return MeApiFp.listCategories(params)(this.fetch, this.basePath);
    }
    /** 
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listCostCenters(params: {  search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
        return MeApiFp.listCostCenters(params)(this.fetch, this.basePath);
    }
    /** 
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listCreditCards(params: {  search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
        return MeApiFp.listCreditCards(params)(this.fetch, this.basePath);
    }
    /** 
     * @param from Lower bound of date range that the order was created (if outgoing) or submitted (if incoming).
     * @param to Upper bound of date range that the order was created (if outgoing) or submitted (if incoming).
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listIncomingOrders(params: {  from?: string; to?: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
        return MeApiFp.listIncomingOrders(params)(this.fetch, this.basePath);
    }
    /** 
     * @param from Lower bound of date range that the order was created (if outgoing) or submitted (if incoming).
     * @param to Upper bound of date range that the order was created (if outgoing) or submitted (if incoming).
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listOutgoingOrders(params: {  from?: string; to?: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
        return MeApiFp.listOutgoingOrders(params)(this.fetch, this.basePath);
    }
    /** 
     * @param categoryID ID of the category.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listProducts(params: {  categoryID?: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
        return MeApiFp.listProducts(params)(this.fetch, this.basePath);
    }
    /** 
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listPromotions(params: {  search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
        return MeApiFp.listPromotions(params)(this.fetch, this.basePath);
    }
    /** 
     * @param productID ID of the product.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listSpecs(params: {  productID: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
        return MeApiFp.listSpecs(params)(this.fetch, this.basePath);
    }
    /** 
     * @param parentID ID of the parent.
     * @param depth Depth of the category.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listSubcategories(params: {  parentID: string; depth?: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
        return MeApiFp.listSubcategories(params)(this.fetch, this.basePath);
    }
    /** 
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listUserGroups(params: {  search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
        return MeApiFp.listUserGroups(params)(this.fetch, this.basePath);
    }
    /** 
     * @param user 
     */
    patch(params: {  user: User; }) {
        return MeApiFp.patch(params)(this.fetch, this.basePath);
    }
    /** 
     * @param addressID ID of the address.
     * @param address 
     */
    patchAddress(params: {  addressID: string; address: BuyerAddress; }) {
        return MeApiFp.patchAddress(params)(this.fetch, this.basePath);
    }
    /** 
     * @param creditcardID ID of the creditcard.
     * @param creditCard 
     */
    patchCreditCard(params: {  creditcardID: string; creditCard: BuyerCreditCard; }) {
        return MeApiFp.patchCreditCard(params)(this.fetch, this.basePath);
    }
    /** 
     * @param user 
     */
    update(params: {  user: User; }) {
        return MeApiFp.update(params)(this.fetch, this.basePath);
    }
    /** 
     * @param addressID ID of the address.
     * @param address 
     */
    updateAddress(params: {  addressID: string; address: BuyerAddress; }) {
        return MeApiFp.updateAddress(params)(this.fetch, this.basePath);
    }
    /** 
     * @param creditcardID ID of the creditcard.
     * @param creditCard 
     */
    updateCreditCard(params: {  creditcardID: string; creditCard: BuyerCreditCard; }) {
        return MeApiFp.updateCreditCard(params)(this.fetch, this.basePath);
    }
};

/**
 * MeApi - factory interface
 */
export const MeApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * @param address 
         */
        createAddress(params: {  address: BuyerAddress; }) {
            return MeApiFp.createAddress(params)(fetch, basePath);
        },
        /** 
         * @param creditCard 
         */
        createCreditCard(params: {  creditCard: BuyerCreditCard; }) {
            return MeApiFp.createCreditCard(params)(fetch, basePath);
        },
        /** 
         * @param addressID ID of the address.
         */
        deleteAddress(params: {  addressID: string; }) {
            return MeApiFp.deleteAddress(params)(fetch, basePath);
        },
        /** 
         * @param creditcardID ID of the creditcard.
         */
        deleteCreditCard(params: {  creditcardID: string; }) {
            return MeApiFp.deleteCreditCard(params)(fetch, basePath);
        },
        /** 
         */
        get() {
            return MeApiFp.get()(fetch, basePath);
        },
        /** 
         * @param addressID ID of the address.
         */
        getAddress(params: {  addressID: string; }) {
            return MeApiFp.getAddress(params)(fetch, basePath);
        },
        /** 
         * @param creditcardID ID of the creditcard.
         */
        getCreditCard(params: {  creditcardID: string; }) {
            return MeApiFp.getCreditCard(params)(fetch, basePath);
        },
        /** 
         * @param orderID ID of the order.
         */
        getOrder(params: {  orderID: string; }) {
            return MeApiFp.getOrder(params)(fetch, basePath);
        },
        /** 
         * @param productID ID of the product.
         */
        getProduct(params: {  productID: string; }) {
            return MeApiFp.getProduct(params)(fetch, basePath);
        },
        /** 
         * @param promotionID ID of the promotion.
         */
        getPromotion(params: {  promotionID: string; }) {
            return MeApiFp.getPromotion(params)(fetch, basePath);
        },
        /** 
         * @param productID ID of the product.
         * @param specID ID of the spec.
         */
        getSpec(params: {  productID: string; specID: string; }) {
            return MeApiFp.getSpec(params)(fetch, basePath);
        },
        /** 
         * @param search Word or phrase to search for.
         * @param searchOn Comma-delimited list of fields to search on.
         * @param sortBy Comma-delimited list of fields to sort by.
         * @param page Page of results to return. Default: 1
         * @param pageSize Number of results to return per page. Default: 20, max: 100.
         */
        listAddresses(params: {  search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
            return MeApiFp.listAddresses(params)(fetch, basePath);
        },
        /** 
         * @param depth Depth of the category.
         * @param search Word or phrase to search for.
         * @param searchOn Comma-delimited list of fields to search on.
         * @param sortBy Comma-delimited list of fields to sort by.
         * @param page Page of results to return. Default: 1
         * @param pageSize Number of results to return per page. Default: 20, max: 100.
         */
        listCategories(params: {  depth?: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
            return MeApiFp.listCategories(params)(fetch, basePath);
        },
        /** 
         * @param search Word or phrase to search for.
         * @param searchOn Comma-delimited list of fields to search on.
         * @param sortBy Comma-delimited list of fields to sort by.
         * @param page Page of results to return. Default: 1
         * @param pageSize Number of results to return per page. Default: 20, max: 100.
         */
        listCostCenters(params: {  search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
            return MeApiFp.listCostCenters(params)(fetch, basePath);
        },
        /** 
         * @param search Word or phrase to search for.
         * @param searchOn Comma-delimited list of fields to search on.
         * @param sortBy Comma-delimited list of fields to sort by.
         * @param page Page of results to return. Default: 1
         * @param pageSize Number of results to return per page. Default: 20, max: 100.
         */
        listCreditCards(params: {  search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
            return MeApiFp.listCreditCards(params)(fetch, basePath);
        },
        /** 
         * @param from Lower bound of date range that the order was created (if outgoing) or submitted (if incoming).
         * @param to Upper bound of date range that the order was created (if outgoing) or submitted (if incoming).
         * @param search Word or phrase to search for.
         * @param searchOn Comma-delimited list of fields to search on.
         * @param sortBy Comma-delimited list of fields to sort by.
         * @param page Page of results to return. Default: 1
         * @param pageSize Number of results to return per page. Default: 20, max: 100.
         */
        listIncomingOrders(params: {  from?: string; to?: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
            return MeApiFp.listIncomingOrders(params)(fetch, basePath);
        },
        /** 
         * @param from Lower bound of date range that the order was created (if outgoing) or submitted (if incoming).
         * @param to Upper bound of date range that the order was created (if outgoing) or submitted (if incoming).
         * @param search Word or phrase to search for.
         * @param searchOn Comma-delimited list of fields to search on.
         * @param sortBy Comma-delimited list of fields to sort by.
         * @param page Page of results to return. Default: 1
         * @param pageSize Number of results to return per page. Default: 20, max: 100.
         */
        listOutgoingOrders(params: {  from?: string; to?: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
            return MeApiFp.listOutgoingOrders(params)(fetch, basePath);
        },
        /** 
         * @param categoryID ID of the category.
         * @param search Word or phrase to search for.
         * @param searchOn Comma-delimited list of fields to search on.
         * @param sortBy Comma-delimited list of fields to sort by.
         * @param page Page of results to return. Default: 1
         * @param pageSize Number of results to return per page. Default: 20, max: 100.
         */
        listProducts(params: {  categoryID?: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
            return MeApiFp.listProducts(params)(fetch, basePath);
        },
        /** 
         * @param search Word or phrase to search for.
         * @param searchOn Comma-delimited list of fields to search on.
         * @param sortBy Comma-delimited list of fields to sort by.
         * @param page Page of results to return. Default: 1
         * @param pageSize Number of results to return per page. Default: 20, max: 100.
         */
        listPromotions(params: {  search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
            return MeApiFp.listPromotions(params)(fetch, basePath);
        },
        /** 
         * @param productID ID of the product.
         * @param search Word or phrase to search for.
         * @param searchOn Comma-delimited list of fields to search on.
         * @param sortBy Comma-delimited list of fields to sort by.
         * @param page Page of results to return. Default: 1
         * @param pageSize Number of results to return per page. Default: 20, max: 100.
         */
        listSpecs(params: {  productID: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
            return MeApiFp.listSpecs(params)(fetch, basePath);
        },
        /** 
         * @param parentID ID of the parent.
         * @param depth Depth of the category.
         * @param search Word or phrase to search for.
         * @param searchOn Comma-delimited list of fields to search on.
         * @param sortBy Comma-delimited list of fields to sort by.
         * @param page Page of results to return. Default: 1
         * @param pageSize Number of results to return per page. Default: 20, max: 100.
         */
        listSubcategories(params: {  parentID: string; depth?: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
            return MeApiFp.listSubcategories(params)(fetch, basePath);
        },
        /** 
         * @param search Word or phrase to search for.
         * @param searchOn Comma-delimited list of fields to search on.
         * @param sortBy Comma-delimited list of fields to sort by.
         * @param page Page of results to return. Default: 1
         * @param pageSize Number of results to return per page. Default: 20, max: 100.
         */
        listUserGroups(params: {  search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
            return MeApiFp.listUserGroups(params)(fetch, basePath);
        },
        /** 
         * @param user 
         */
        patch(params: {  user: User; }) {
            return MeApiFp.patch(params)(fetch, basePath);
        },
        /** 
         * @param addressID ID of the address.
         * @param address 
         */
        patchAddress(params: {  addressID: string; address: BuyerAddress; }) {
            return MeApiFp.patchAddress(params)(fetch, basePath);
        },
        /** 
         * @param creditcardID ID of the creditcard.
         * @param creditCard 
         */
        patchCreditCard(params: {  creditcardID: string; creditCard: BuyerCreditCard; }) {
            return MeApiFp.patchCreditCard(params)(fetch, basePath);
        },
        /** 
         * @param user 
         */
        update(params: {  user: User; }) {
            return MeApiFp.update(params)(fetch, basePath);
        },
        /** 
         * @param addressID ID of the address.
         * @param address 
         */
        updateAddress(params: {  addressID: string; address: BuyerAddress; }) {
            return MeApiFp.updateAddress(params)(fetch, basePath);
        },
        /** 
         * @param creditcardID ID of the creditcard.
         * @param creditCard 
         */
        updateCreditCard(params: {  creditcardID: string; creditCard: BuyerCreditCard; }) {
            return MeApiFp.updateCreditCard(params)(fetch, basePath);
        },
    }
};


/**
 * OrderApi - fetch parameter creator
 */
export const OrderApiFetchParamCreactor = {
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     */
    _delete(params: {  buyerID: string; orderID: string; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling _delete");
        }
        // verify required parameter "orderID" is set
        if (params["orderID"] == null) {
            throw new Error("Missing required parameter orderID when calling _delete");
        }
        const baseUrl = `/buyers/{buyerID}/orders/{orderID}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"orderID"}}`, `${ params.orderID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "DELETE" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param promoCode Promo code of the order.
     */
    addPromotion(params: {  buyerID: string; orderID: string; promoCode: string; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling addPromotion");
        }
        // verify required parameter "orderID" is set
        if (params["orderID"] == null) {
            throw new Error("Missing required parameter orderID when calling addPromotion");
        }
        // verify required parameter "promoCode" is set
        if (params["promoCode"] == null) {
            throw new Error("Missing required parameter promoCode when calling addPromotion");
        }
        const baseUrl = `/buyers/{buyerID}/orders/{orderID}/promotions/{promoCode}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"orderID"}}`, `${ params.orderID }`)
            .replace(`{${"promoCode"}}`, `${ params.promoCode }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param comments Comments to be saved with the order approval.
     */
    approve(params: {  buyerID: string; orderID: string; comments?: string; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling approve");
        }
        // verify required parameter "orderID" is set
        if (params["orderID"] == null) {
            throw new Error("Missing required parameter orderID when calling approve");
        }
        const baseUrl = `/buyers/{buyerID}/orders/{orderID}/approve`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"orderID"}}`, `${ params.orderID }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "comments": params.comments,
        });
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     */
    cancel(params: {  buyerID: string; orderID: string; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling cancel");
        }
        // verify required parameter "orderID" is set
        if (params["orderID"] == null) {
            throw new Error("Missing required parameter orderID when calling cancel");
        }
        const baseUrl = `/buyers/{buyerID}/orders/{orderID}/cancel`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"orderID"}}`, `${ params.orderID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param order 
     */
    create(params: {  buyerID: string; order: Order; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling create");
        }
        // verify required parameter "order" is set
        if (params["order"] == null) {
            throw new Error("Missing required parameter order when calling create");
        }
        const baseUrl = `/buyers/{buyerID}/orders`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["order"]) {
            fetchOptions.body = JSON.stringify(params["order"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param comments Comments to be saved with the order denial.
     */
    decline(params: {  buyerID: string; orderID: string; comments?: string; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling decline");
        }
        // verify required parameter "orderID" is set
        if (params["orderID"] == null) {
            throw new Error("Missing required parameter orderID when calling decline");
        }
        const baseUrl = `/buyers/{buyerID}/orders/{orderID}/decline`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"orderID"}}`, `${ params.orderID }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "comments": params.comments,
        });
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     */
    get(params: {  buyerID: string; orderID: string; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling get");
        }
        // verify required parameter "orderID" is set
        if (params["orderID"] == null) {
            throw new Error("Missing required parameter orderID when calling get");
        }
        const baseUrl = `/buyers/{buyerID}/orders/{orderID}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"orderID"}}`, `${ params.orderID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listApprovals(params: {  buyerID: string; orderID: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling listApprovals");
        }
        // verify required parameter "orderID" is set
        if (params["orderID"] == null) {
            throw new Error("Missing required parameter orderID when calling listApprovals");
        }
        const baseUrl = `/buyers/{buyerID}/orders/{orderID}/approvals`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"orderID"}}`, `${ params.orderID }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "search": params.search,
            "searchOn": params.searchOn,
            "sortBy": params.sortBy,
            "page": params.page,
            "pageSize": params.pageSize,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listEligibleApprovers(params: {  buyerID: string; orderID: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling listEligibleApprovers");
        }
        // verify required parameter "orderID" is set
        if (params["orderID"] == null) {
            throw new Error("Missing required parameter orderID when calling listEligibleApprovers");
        }
        const baseUrl = `/buyers/{buyerID}/orders/{orderID}/eligibleapprovers`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"orderID"}}`, `${ params.orderID }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "search": params.search,
            "searchOn": params.searchOn,
            "sortBy": params.sortBy,
            "page": params.page,
            "pageSize": params.pageSize,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param from Lower bound of date range that the order was submitted.
     * @param to Upper bound of date range that the order was submitted.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listIncoming(params: {  buyerID?: string; from?: string; to?: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }): FetchArgs {
        const baseUrl = `/orders/incoming`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "buyerID": params.buyerID,
            "from": params.from,
            "to": params.to,
            "search": params.search,
            "searchOn": params.searchOn,
            "sortBy": params.sortBy,
            "page": params.page,
            "pageSize": params.pageSize,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param from Lower bound of date range that the order was created.
     * @param to Upper bound of date range that the order was created.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listOutgoing(params: {  buyerID?: string; from?: string; to?: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }): FetchArgs {
        const baseUrl = `/orders/outgoing`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "buyerID": params.buyerID,
            "from": params.from,
            "to": params.to,
            "search": params.search,
            "searchOn": params.searchOn,
            "sortBy": params.sortBy,
            "page": params.page,
            "pageSize": params.pageSize,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listPromotions(params: {  buyerID: string; orderID: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling listPromotions");
        }
        // verify required parameter "orderID" is set
        if (params["orderID"] == null) {
            throw new Error("Missing required parameter orderID when calling listPromotions");
        }
        const baseUrl = `/buyers/{buyerID}/orders/{orderID}/promotions`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"orderID"}}`, `${ params.orderID }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "search": params.search,
            "searchOn": params.searchOn,
            "sortBy": params.sortBy,
            "page": params.page,
            "pageSize": params.pageSize,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param partialOrder 
     */
    patch(params: {  buyerID: string; orderID: string; partialOrder: Order; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling patch");
        }
        // verify required parameter "orderID" is set
        if (params["orderID"] == null) {
            throw new Error("Missing required parameter orderID when calling patch");
        }
        // verify required parameter "partialOrder" is set
        if (params["partialOrder"] == null) {
            throw new Error("Missing required parameter partialOrder when calling patch");
        }
        const baseUrl = `/buyers/{buyerID}/orders/{orderID}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"orderID"}}`, `${ params.orderID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PATCH" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["partialOrder"]) {
            fetchOptions.body = JSON.stringify(params["partialOrder"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param address 
     */
    patchBillingAddress(params: {  buyerID: string; orderID: string; address: Address; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling patchBillingAddress");
        }
        // verify required parameter "orderID" is set
        if (params["orderID"] == null) {
            throw new Error("Missing required parameter orderID when calling patchBillingAddress");
        }
        // verify required parameter "address" is set
        if (params["address"] == null) {
            throw new Error("Missing required parameter address when calling patchBillingAddress");
        }
        const baseUrl = `/buyers/{buyerID}/orders/{orderID}/billto`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"orderID"}}`, `${ params.orderID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PATCH" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["address"]) {
            fetchOptions.body = JSON.stringify(params["address"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param address 
     */
    patchShippingAddress(params: {  buyerID: string; orderID: string; address: Address; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling patchShippingAddress");
        }
        // verify required parameter "orderID" is set
        if (params["orderID"] == null) {
            throw new Error("Missing required parameter orderID when calling patchShippingAddress");
        }
        // verify required parameter "address" is set
        if (params["address"] == null) {
            throw new Error("Missing required parameter address when calling patchShippingAddress");
        }
        const baseUrl = `/buyers/{buyerID}/orders/{orderID}/shipto`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"orderID"}}`, `${ params.orderID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PATCH" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["address"]) {
            fetchOptions.body = JSON.stringify(params["address"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param promoCode Promo code of the order.
     */
    removePromotion(params: {  buyerID: string; orderID: string; promoCode: string; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling removePromotion");
        }
        // verify required parameter "orderID" is set
        if (params["orderID"] == null) {
            throw new Error("Missing required parameter orderID when calling removePromotion");
        }
        // verify required parameter "promoCode" is set
        if (params["promoCode"] == null) {
            throw new Error("Missing required parameter promoCode when calling removePromotion");
        }
        const baseUrl = `/buyers/{buyerID}/orders/{orderID}/promotions/{promoCode}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"orderID"}}`, `${ params.orderID }`)
            .replace(`{${"promoCode"}}`, `${ params.promoCode }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "DELETE" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param address 
     */
    setBillingAddress(params: {  buyerID: string; orderID: string; address: Address; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling setBillingAddress");
        }
        // verify required parameter "orderID" is set
        if (params["orderID"] == null) {
            throw new Error("Missing required parameter orderID when calling setBillingAddress");
        }
        // verify required parameter "address" is set
        if (params["address"] == null) {
            throw new Error("Missing required parameter address when calling setBillingAddress");
        }
        const baseUrl = `/buyers/{buyerID}/orders/{orderID}/billto`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"orderID"}}`, `${ params.orderID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PUT" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["address"]) {
            fetchOptions.body = JSON.stringify(params["address"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param address 
     */
    setShippingAddress(params: {  buyerID: string; orderID: string; address: Address; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling setShippingAddress");
        }
        // verify required parameter "orderID" is set
        if (params["orderID"] == null) {
            throw new Error("Missing required parameter orderID when calling setShippingAddress");
        }
        // verify required parameter "address" is set
        if (params["address"] == null) {
            throw new Error("Missing required parameter address when calling setShippingAddress");
        }
        const baseUrl = `/buyers/{buyerID}/orders/{orderID}/shipto`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"orderID"}}`, `${ params.orderID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PUT" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["address"]) {
            fetchOptions.body = JSON.stringify(params["address"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param shipment 
     */
    ship(params: {  buyerID: string; orderID: string; shipment: Shipment; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling ship");
        }
        // verify required parameter "orderID" is set
        if (params["orderID"] == null) {
            throw new Error("Missing required parameter orderID when calling ship");
        }
        // verify required parameter "shipment" is set
        if (params["shipment"] == null) {
            throw new Error("Missing required parameter shipment when calling ship");
        }
        const baseUrl = `/buyers/{buyerID}/orders/{orderID}/ship`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"orderID"}}`, `${ params.orderID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["shipment"]) {
            fetchOptions.body = JSON.stringify(params["shipment"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     */
    submit(params: {  buyerID: string; orderID: string; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling submit");
        }
        // verify required parameter "orderID" is set
        if (params["orderID"] == null) {
            throw new Error("Missing required parameter orderID when calling submit");
        }
        const baseUrl = `/buyers/{buyerID}/orders/{orderID}/submit`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"orderID"}}`, `${ params.orderID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param tempUserToken Temp user token of the order.
     */
    transferTempUserOrder(params: {  buyerID: string; tempUserToken: string; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling transferTempUserOrder");
        }
        // verify required parameter "tempUserToken" is set
        if (params["tempUserToken"] == null) {
            throw new Error("Missing required parameter tempUserToken when calling transferTempUserOrder");
        }
        const baseUrl = `/buyers/{buyerID}/orders`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "tempUserToken": params.tempUserToken,
        });
        let fetchOptions: RequestInit = { method: "PUT" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param order 
     */
    update(params: {  buyerID: string; orderID: string; order: Order; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling update");
        }
        // verify required parameter "orderID" is set
        if (params["orderID"] == null) {
            throw new Error("Missing required parameter orderID when calling update");
        }
        // verify required parameter "order" is set
        if (params["order"] == null) {
            throw new Error("Missing required parameter order when calling update");
        }
        const baseUrl = `/buyers/{buyerID}/orders/{orderID}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"orderID"}}`, `${ params.orderID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PUT" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["order"]) {
            fetchOptions.body = JSON.stringify(params["order"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
}

/**
 * OrderApi - functional programming interface
 */
export const OrderApiFp = {
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     */
    _delete(params: { buyerID: string; orderID: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = OrderApiFetchParamCreactor._delete(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param promoCode Promo code of the order.
     */
    addPromotion(params: { buyerID: string; orderID: string; promoCode: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = OrderApiFetchParamCreactor.addPromotion(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param comments Comments to be saved with the order approval.
     */
    approve(params: { buyerID: string; orderID: string; comments?: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = OrderApiFetchParamCreactor.approve(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     */
    cancel(params: { buyerID: string; orderID: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = OrderApiFetchParamCreactor.cancel(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param order 
     */
    create(params: { buyerID: string; order: Order;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = OrderApiFetchParamCreactor.create(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param comments Comments to be saved with the order denial.
     */
    decline(params: { buyerID: string; orderID: string; comments?: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = OrderApiFetchParamCreactor.decline(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     */
    get(params: { buyerID: string; orderID: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = OrderApiFetchParamCreactor.get(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listApprovals(params: { buyerID: string; orderID: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = OrderApiFetchParamCreactor.listApprovals(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listEligibleApprovers(params: { buyerID: string; orderID: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = OrderApiFetchParamCreactor.listEligibleApprovers(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param from Lower bound of date range that the order was submitted.
     * @param to Upper bound of date range that the order was submitted.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listIncoming(params: { buyerID?: string; from?: string; to?: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = OrderApiFetchParamCreactor.listIncoming(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param from Lower bound of date range that the order was created.
     * @param to Upper bound of date range that the order was created.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listOutgoing(params: { buyerID?: string; from?: string; to?: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = OrderApiFetchParamCreactor.listOutgoing(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listPromotions(params: { buyerID: string; orderID: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = OrderApiFetchParamCreactor.listPromotions(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param partialOrder 
     */
    patch(params: { buyerID: string; orderID: string; partialOrder: Order;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = OrderApiFetchParamCreactor.patch(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param address 
     */
    patchBillingAddress(params: { buyerID: string; orderID: string; address: Address;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = OrderApiFetchParamCreactor.patchBillingAddress(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param address 
     */
    patchShippingAddress(params: { buyerID: string; orderID: string; address: Address;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = OrderApiFetchParamCreactor.patchShippingAddress(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param promoCode Promo code of the order.
     */
    removePromotion(params: { buyerID: string; orderID: string; promoCode: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = OrderApiFetchParamCreactor.removePromotion(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param address 
     */
    setBillingAddress(params: { buyerID: string; orderID: string; address: Address;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = OrderApiFetchParamCreactor.setBillingAddress(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param address 
     */
    setShippingAddress(params: { buyerID: string; orderID: string; address: Address;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = OrderApiFetchParamCreactor.setShippingAddress(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param shipment 
     */
    ship(params: { buyerID: string; orderID: string; shipment: Shipment;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = OrderApiFetchParamCreactor.ship(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     */
    submit(params: { buyerID: string; orderID: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = OrderApiFetchParamCreactor.submit(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param tempUserToken Temp user token of the order.
     */
    transferTempUserOrder(params: { buyerID: string; tempUserToken: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = OrderApiFetchParamCreactor.transferTempUserOrder(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param order 
     */
    update(params: { buyerID: string; orderID: string; order: Order;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = OrderApiFetchParamCreactor.update(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * OrderApi - object-oriented interface
 */
export class OrderApi extends BaseAPI {
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     */
    _delete(params: {  buyerID: string; orderID: string; }) {
        return OrderApiFp._delete(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param promoCode Promo code of the order.
     */
    addPromotion(params: {  buyerID: string; orderID: string; promoCode: string; }) {
        return OrderApiFp.addPromotion(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param comments Comments to be saved with the order approval.
     */
    approve(params: {  buyerID: string; orderID: string; comments?: string; }) {
        return OrderApiFp.approve(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     */
    cancel(params: {  buyerID: string; orderID: string; }) {
        return OrderApiFp.cancel(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param order 
     */
    create(params: {  buyerID: string; order: Order; }) {
        return OrderApiFp.create(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param comments Comments to be saved with the order denial.
     */
    decline(params: {  buyerID: string; orderID: string; comments?: string; }) {
        return OrderApiFp.decline(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     */
    get(params: {  buyerID: string; orderID: string; }) {
        return OrderApiFp.get(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listApprovals(params: {  buyerID: string; orderID: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
        return OrderApiFp.listApprovals(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listEligibleApprovers(params: {  buyerID: string; orderID: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
        return OrderApiFp.listEligibleApprovers(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param from Lower bound of date range that the order was submitted.
     * @param to Upper bound of date range that the order was submitted.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listIncoming(params: {  buyerID?: string; from?: string; to?: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
        return OrderApiFp.listIncoming(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param from Lower bound of date range that the order was created.
     * @param to Upper bound of date range that the order was created.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listOutgoing(params: {  buyerID?: string; from?: string; to?: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
        return OrderApiFp.listOutgoing(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listPromotions(params: {  buyerID: string; orderID: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
        return OrderApiFp.listPromotions(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param partialOrder 
     */
    patch(params: {  buyerID: string; orderID: string; partialOrder: Order; }) {
        return OrderApiFp.patch(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param address 
     */
    patchBillingAddress(params: {  buyerID: string; orderID: string; address: Address; }) {
        return OrderApiFp.patchBillingAddress(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param address 
     */
    patchShippingAddress(params: {  buyerID: string; orderID: string; address: Address; }) {
        return OrderApiFp.patchShippingAddress(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param promoCode Promo code of the order.
     */
    removePromotion(params: {  buyerID: string; orderID: string; promoCode: string; }) {
        return OrderApiFp.removePromotion(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param address 
     */
    setBillingAddress(params: {  buyerID: string; orderID: string; address: Address; }) {
        return OrderApiFp.setBillingAddress(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param address 
     */
    setShippingAddress(params: {  buyerID: string; orderID: string; address: Address; }) {
        return OrderApiFp.setShippingAddress(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param shipment 
     */
    ship(params: {  buyerID: string; orderID: string; shipment: Shipment; }) {
        return OrderApiFp.ship(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     */
    submit(params: {  buyerID: string; orderID: string; }) {
        return OrderApiFp.submit(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param tempUserToken Temp user token of the order.
     */
    transferTempUserOrder(params: {  buyerID: string; tempUserToken: string; }) {
        return OrderApiFp.transferTempUserOrder(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param order 
     */
    update(params: {  buyerID: string; orderID: string; order: Order; }) {
        return OrderApiFp.update(params)(this.fetch, this.basePath);
    }
};

/**
 * OrderApi - factory interface
 */
export const OrderApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * @param buyerID ID of the buyer.
         * @param orderID ID of the order.
         */
        _delete(params: {  buyerID: string; orderID: string; }) {
            return OrderApiFp._delete(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param orderID ID of the order.
         * @param promoCode Promo code of the order.
         */
        addPromotion(params: {  buyerID: string; orderID: string; promoCode: string; }) {
            return OrderApiFp.addPromotion(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param orderID ID of the order.
         * @param comments Comments to be saved with the order approval.
         */
        approve(params: {  buyerID: string; orderID: string; comments?: string; }) {
            return OrderApiFp.approve(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param orderID ID of the order.
         */
        cancel(params: {  buyerID: string; orderID: string; }) {
            return OrderApiFp.cancel(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param order 
         */
        create(params: {  buyerID: string; order: Order; }) {
            return OrderApiFp.create(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param orderID ID of the order.
         * @param comments Comments to be saved with the order denial.
         */
        decline(params: {  buyerID: string; orderID: string; comments?: string; }) {
            return OrderApiFp.decline(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param orderID ID of the order.
         */
        get(params: {  buyerID: string; orderID: string; }) {
            return OrderApiFp.get(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param orderID ID of the order.
         * @param search Word or phrase to search for.
         * @param searchOn Comma-delimited list of fields to search on.
         * @param sortBy Comma-delimited list of fields to sort by.
         * @param page Page of results to return. Default: 1
         * @param pageSize Number of results to return per page. Default: 20, max: 100.
         */
        listApprovals(params: {  buyerID: string; orderID: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
            return OrderApiFp.listApprovals(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param orderID ID of the order.
         * @param search Word or phrase to search for.
         * @param searchOn Comma-delimited list of fields to search on.
         * @param sortBy Comma-delimited list of fields to sort by.
         * @param page Page of results to return. Default: 1
         * @param pageSize Number of results to return per page. Default: 20, max: 100.
         */
        listEligibleApprovers(params: {  buyerID: string; orderID: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
            return OrderApiFp.listEligibleApprovers(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param from Lower bound of date range that the order was submitted.
         * @param to Upper bound of date range that the order was submitted.
         * @param search Word or phrase to search for.
         * @param searchOn Comma-delimited list of fields to search on.
         * @param sortBy Comma-delimited list of fields to sort by.
         * @param page Page of results to return. Default: 1
         * @param pageSize Number of results to return per page. Default: 20, max: 100.
         */
        listIncoming(params: {  buyerID?: string; from?: string; to?: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
            return OrderApiFp.listIncoming(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param from Lower bound of date range that the order was created.
         * @param to Upper bound of date range that the order was created.
         * @param search Word or phrase to search for.
         * @param searchOn Comma-delimited list of fields to search on.
         * @param sortBy Comma-delimited list of fields to sort by.
         * @param page Page of results to return. Default: 1
         * @param pageSize Number of results to return per page. Default: 20, max: 100.
         */
        listOutgoing(params: {  buyerID?: string; from?: string; to?: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
            return OrderApiFp.listOutgoing(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param orderID ID of the order.
         * @param search Word or phrase to search for.
         * @param searchOn Comma-delimited list of fields to search on.
         * @param sortBy Comma-delimited list of fields to sort by.
         * @param page Page of results to return. Default: 1
         * @param pageSize Number of results to return per page. Default: 20, max: 100.
         */
        listPromotions(params: {  buyerID: string; orderID: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
            return OrderApiFp.listPromotions(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param orderID ID of the order.
         * @param partialOrder 
         */
        patch(params: {  buyerID: string; orderID: string; partialOrder: Order; }) {
            return OrderApiFp.patch(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param orderID ID of the order.
         * @param address 
         */
        patchBillingAddress(params: {  buyerID: string; orderID: string; address: Address; }) {
            return OrderApiFp.patchBillingAddress(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param orderID ID of the order.
         * @param address 
         */
        patchShippingAddress(params: {  buyerID: string; orderID: string; address: Address; }) {
            return OrderApiFp.patchShippingAddress(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param orderID ID of the order.
         * @param promoCode Promo code of the order.
         */
        removePromotion(params: {  buyerID: string; orderID: string; promoCode: string; }) {
            return OrderApiFp.removePromotion(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param orderID ID of the order.
         * @param address 
         */
        setBillingAddress(params: {  buyerID: string; orderID: string; address: Address; }) {
            return OrderApiFp.setBillingAddress(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param orderID ID of the order.
         * @param address 
         */
        setShippingAddress(params: {  buyerID: string; orderID: string; address: Address; }) {
            return OrderApiFp.setShippingAddress(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param orderID ID of the order.
         * @param shipment 
         */
        ship(params: {  buyerID: string; orderID: string; shipment: Shipment; }) {
            return OrderApiFp.ship(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param orderID ID of the order.
         */
        submit(params: {  buyerID: string; orderID: string; }) {
            return OrderApiFp.submit(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param tempUserToken Temp user token of the order.
         */
        transferTempUserOrder(params: {  buyerID: string; tempUserToken: string; }) {
            return OrderApiFp.transferTempUserOrder(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param orderID ID of the order.
         * @param order 
         */
        update(params: {  buyerID: string; orderID: string; order: Order; }) {
            return OrderApiFp.update(params)(fetch, basePath);
        },
    }
};


/**
 * PasswordResetApi - fetch parameter creator
 */
export const PasswordResetApiFetchParamCreactor = {
    /** 
     * @param verificationCode Verification code of the forgotten password.
     * @param passwordReset 
     */
    resetPassword(params: {  verificationCode: string; passwordReset: PasswordReset; }): FetchArgs {
        // verify required parameter "verificationCode" is set
        if (params["verificationCode"] == null) {
            throw new Error("Missing required parameter verificationCode when calling resetPassword");
        }
        // verify required parameter "passwordReset" is set
        if (params["passwordReset"] == null) {
            throw new Error("Missing required parameter passwordReset when calling resetPassword");
        }
        const baseUrl = `/password/reset/{verificationCode}`
            .replace(`{${"verificationCode"}}`, `${ params.verificationCode }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PUT" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["passwordReset"]) {
            fetchOptions.body = JSON.stringify(params["passwordReset"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param passwordResetRequest 
     */
    sendVerificationCode(params: {  passwordResetRequest: PasswordResetRequest; }): FetchArgs {
        // verify required parameter "passwordResetRequest" is set
        if (params["passwordResetRequest"] == null) {
            throw new Error("Missing required parameter passwordResetRequest when calling sendVerificationCode");
        }
        const baseUrl = `/password/reset`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["passwordResetRequest"]) {
            fetchOptions.body = JSON.stringify(params["passwordResetRequest"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
}

/**
 * PasswordResetApi - functional programming interface
 */
export const PasswordResetApiFp = {
    /** 
     * @param verificationCode Verification code of the forgotten password.
     * @param passwordReset 
     */
    resetPassword(params: { verificationCode: string; passwordReset: PasswordReset;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PasswordResetApiFetchParamCreactor.resetPassword(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param passwordResetRequest 
     */
    sendVerificationCode(params: { passwordResetRequest: PasswordResetRequest;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PasswordResetApiFetchParamCreactor.sendVerificationCode(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * PasswordResetApi - object-oriented interface
 */
export class PasswordResetApi extends BaseAPI {
    /** 
     * @param verificationCode Verification code of the forgotten password.
     * @param passwordReset 
     */
    resetPassword(params: {  verificationCode: string; passwordReset: PasswordReset; }) {
        return PasswordResetApiFp.resetPassword(params)(this.fetch, this.basePath);
    }
    /** 
     * @param passwordResetRequest 
     */
    sendVerificationCode(params: {  passwordResetRequest: PasswordResetRequest; }) {
        return PasswordResetApiFp.sendVerificationCode(params)(this.fetch, this.basePath);
    }
};

/**
 * PasswordResetApi - factory interface
 */
export const PasswordResetApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * @param verificationCode Verification code of the forgotten password.
         * @param passwordReset 
         */
        resetPassword(params: {  verificationCode: string; passwordReset: PasswordReset; }) {
            return PasswordResetApiFp.resetPassword(params)(fetch, basePath);
        },
        /** 
         * @param passwordResetRequest 
         */
        sendVerificationCode(params: {  passwordResetRequest: PasswordResetRequest; }) {
            return PasswordResetApiFp.sendVerificationCode(params)(fetch, basePath);
        },
    }
};


/**
 * PaymentApi - fetch parameter creator
 */
export const PaymentApiFetchParamCreactor = {
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param paymentID ID of the payment.
     */
    _delete(params: {  buyerID: string; orderID: string; paymentID: string; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling _delete");
        }
        // verify required parameter "orderID" is set
        if (params["orderID"] == null) {
            throw new Error("Missing required parameter orderID when calling _delete");
        }
        // verify required parameter "paymentID" is set
        if (params["paymentID"] == null) {
            throw new Error("Missing required parameter paymentID when calling _delete");
        }
        const baseUrl = `/buyers/{buyerID}/orders/{orderID}/payments/{paymentID}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"orderID"}}`, `${ params.orderID }`)
            .replace(`{${"paymentID"}}`, `${ params.paymentID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "DELETE" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param payment 
     */
    create(params: {  buyerID: string; orderID: string; payment: Payment; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling create");
        }
        // verify required parameter "orderID" is set
        if (params["orderID"] == null) {
            throw new Error("Missing required parameter orderID when calling create");
        }
        // verify required parameter "payment" is set
        if (params["payment"] == null) {
            throw new Error("Missing required parameter payment when calling create");
        }
        const baseUrl = `/buyers/{buyerID}/orders/{orderID}/payments`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"orderID"}}`, `${ params.orderID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["payment"]) {
            fetchOptions.body = JSON.stringify(params["payment"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param paymentID ID of the payment.
     * @param transaction 
     */
    createTransaction(params: {  buyerID: string; orderID: string; paymentID: string; transaction: PaymentTransaction; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling createTransaction");
        }
        // verify required parameter "orderID" is set
        if (params["orderID"] == null) {
            throw new Error("Missing required parameter orderID when calling createTransaction");
        }
        // verify required parameter "paymentID" is set
        if (params["paymentID"] == null) {
            throw new Error("Missing required parameter paymentID when calling createTransaction");
        }
        // verify required parameter "transaction" is set
        if (params["transaction"] == null) {
            throw new Error("Missing required parameter transaction when calling createTransaction");
        }
        const baseUrl = `/buyers/{buyerID}/orders/{orderID}/payments/{paymentID}/transactions`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"orderID"}}`, `${ params.orderID }`)
            .replace(`{${"paymentID"}}`, `${ params.paymentID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["transaction"]) {
            fetchOptions.body = JSON.stringify(params["transaction"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param paymentID ID of the payment.
     * @param transactionID ID of the transaction.
     */
    deleteTransaction(params: {  buyerID: string; orderID: string; paymentID: string; transactionID: string; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling deleteTransaction");
        }
        // verify required parameter "orderID" is set
        if (params["orderID"] == null) {
            throw new Error("Missing required parameter orderID when calling deleteTransaction");
        }
        // verify required parameter "paymentID" is set
        if (params["paymentID"] == null) {
            throw new Error("Missing required parameter paymentID when calling deleteTransaction");
        }
        // verify required parameter "transactionID" is set
        if (params["transactionID"] == null) {
            throw new Error("Missing required parameter transactionID when calling deleteTransaction");
        }
        const baseUrl = `/buyers/{buyerID}/orders/{orderID}/payments/{paymentID}/transactions/{transactionID}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"orderID"}}`, `${ params.orderID }`)
            .replace(`{${"paymentID"}}`, `${ params.paymentID }`)
            .replace(`{${"transactionID"}}`, `${ params.transactionID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "DELETE" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param paymentID ID of the payment.
     */
    get(params: {  buyerID: string; orderID: string; paymentID: string; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling get");
        }
        // verify required parameter "orderID" is set
        if (params["orderID"] == null) {
            throw new Error("Missing required parameter orderID when calling get");
        }
        // verify required parameter "paymentID" is set
        if (params["paymentID"] == null) {
            throw new Error("Missing required parameter paymentID when calling get");
        }
        const baseUrl = `/buyers/{buyerID}/orders/{orderID}/payments/{paymentID}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"orderID"}}`, `${ params.orderID }`)
            .replace(`{${"paymentID"}}`, `${ params.paymentID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    list(params: {  buyerID: string; orderID: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling list");
        }
        // verify required parameter "orderID" is set
        if (params["orderID"] == null) {
            throw new Error("Missing required parameter orderID when calling list");
        }
        const baseUrl = `/buyers/{buyerID}/orders/{orderID}/payments`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"orderID"}}`, `${ params.orderID }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "search": params.search,
            "searchOn": params.searchOn,
            "sortBy": params.sortBy,
            "page": params.page,
            "pageSize": params.pageSize,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param paymentID ID of the payment.
     * @param partialPayment 
     */
    patch(params: {  buyerID: string; orderID: string; paymentID: string; partialPayment: Payment; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling patch");
        }
        // verify required parameter "orderID" is set
        if (params["orderID"] == null) {
            throw new Error("Missing required parameter orderID when calling patch");
        }
        // verify required parameter "paymentID" is set
        if (params["paymentID"] == null) {
            throw new Error("Missing required parameter paymentID when calling patch");
        }
        // verify required parameter "partialPayment" is set
        if (params["partialPayment"] == null) {
            throw new Error("Missing required parameter partialPayment when calling patch");
        }
        const baseUrl = `/buyers/{buyerID}/orders/{orderID}/payments/{paymentID}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"orderID"}}`, `${ params.orderID }`)
            .replace(`{${"paymentID"}}`, `${ params.paymentID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PATCH" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["partialPayment"]) {
            fetchOptions.body = JSON.stringify(params["partialPayment"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param paymentID ID of the payment.
     * @param transactionID ID of the transaction.
     * @param partialTransaction 
     */
    patchTransaction(params: {  buyerID: string; orderID: string; paymentID: string; transactionID: string; partialTransaction: PaymentTransaction; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling patchTransaction");
        }
        // verify required parameter "orderID" is set
        if (params["orderID"] == null) {
            throw new Error("Missing required parameter orderID when calling patchTransaction");
        }
        // verify required parameter "paymentID" is set
        if (params["paymentID"] == null) {
            throw new Error("Missing required parameter paymentID when calling patchTransaction");
        }
        // verify required parameter "transactionID" is set
        if (params["transactionID"] == null) {
            throw new Error("Missing required parameter transactionID when calling patchTransaction");
        }
        // verify required parameter "partialTransaction" is set
        if (params["partialTransaction"] == null) {
            throw new Error("Missing required parameter partialTransaction when calling patchTransaction");
        }
        const baseUrl = `/buyers/{buyerID}/orders/{orderID}/payments/{paymentID}/transactions/{transactionID}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"orderID"}}`, `${ params.orderID }`)
            .replace(`{${"paymentID"}}`, `${ params.paymentID }`)
            .replace(`{${"transactionID"}}`, `${ params.transactionID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PATCH" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["partialTransaction"]) {
            fetchOptions.body = JSON.stringify(params["partialTransaction"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param paymentID ID of the payment.
     * @param payment 
     */
    update(params: {  buyerID: string; orderID: string; paymentID: string; payment: Payment; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling update");
        }
        // verify required parameter "orderID" is set
        if (params["orderID"] == null) {
            throw new Error("Missing required parameter orderID when calling update");
        }
        // verify required parameter "paymentID" is set
        if (params["paymentID"] == null) {
            throw new Error("Missing required parameter paymentID when calling update");
        }
        // verify required parameter "payment" is set
        if (params["payment"] == null) {
            throw new Error("Missing required parameter payment when calling update");
        }
        const baseUrl = `/buyers/{buyerID}/orders/{orderID}/payments/{paymentID}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"orderID"}}`, `${ params.orderID }`)
            .replace(`{${"paymentID"}}`, `${ params.paymentID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PUT" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["payment"]) {
            fetchOptions.body = JSON.stringify(params["payment"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param paymentID ID of the payment.
     * @param transactionID ID of the transaction.
     * @param transaction 
     */
    updateTransaction(params: {  buyerID: string; orderID: string; paymentID: string; transactionID: string; transaction: PaymentTransaction; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling updateTransaction");
        }
        // verify required parameter "orderID" is set
        if (params["orderID"] == null) {
            throw new Error("Missing required parameter orderID when calling updateTransaction");
        }
        // verify required parameter "paymentID" is set
        if (params["paymentID"] == null) {
            throw new Error("Missing required parameter paymentID when calling updateTransaction");
        }
        // verify required parameter "transactionID" is set
        if (params["transactionID"] == null) {
            throw new Error("Missing required parameter transactionID when calling updateTransaction");
        }
        // verify required parameter "transaction" is set
        if (params["transaction"] == null) {
            throw new Error("Missing required parameter transaction when calling updateTransaction");
        }
        const baseUrl = `/buyers/{buyerID}/orders/{orderID}/payments/{paymentID}/transactions/{transactionID}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"orderID"}}`, `${ params.orderID }`)
            .replace(`{${"paymentID"}}`, `${ params.paymentID }`)
            .replace(`{${"transactionID"}}`, `${ params.transactionID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PUT" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["transaction"]) {
            fetchOptions.body = JSON.stringify(params["transaction"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
}

/**
 * PaymentApi - functional programming interface
 */
export const PaymentApiFp = {
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param paymentID ID of the payment.
     */
    _delete(params: { buyerID: string; orderID: string; paymentID: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PaymentApiFetchParamCreactor._delete(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param payment 
     */
    create(params: { buyerID: string; orderID: string; payment: Payment;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PaymentApiFetchParamCreactor.create(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param paymentID ID of the payment.
     * @param transaction 
     */
    createTransaction(params: { buyerID: string; orderID: string; paymentID: string; transaction: PaymentTransaction;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PaymentApiFetchParamCreactor.createTransaction(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param paymentID ID of the payment.
     * @param transactionID ID of the transaction.
     */
    deleteTransaction(params: { buyerID: string; orderID: string; paymentID: string; transactionID: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PaymentApiFetchParamCreactor.deleteTransaction(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param paymentID ID of the payment.
     */
    get(params: { buyerID: string; orderID: string; paymentID: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PaymentApiFetchParamCreactor.get(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    list(params: { buyerID: string; orderID: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PaymentApiFetchParamCreactor.list(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param paymentID ID of the payment.
     * @param partialPayment 
     */
    patch(params: { buyerID: string; orderID: string; paymentID: string; partialPayment: Payment;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PaymentApiFetchParamCreactor.patch(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param paymentID ID of the payment.
     * @param transactionID ID of the transaction.
     * @param partialTransaction 
     */
    patchTransaction(params: { buyerID: string; orderID: string; paymentID: string; transactionID: string; partialTransaction: PaymentTransaction;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PaymentApiFetchParamCreactor.patchTransaction(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param paymentID ID of the payment.
     * @param payment 
     */
    update(params: { buyerID: string; orderID: string; paymentID: string; payment: Payment;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PaymentApiFetchParamCreactor.update(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param paymentID ID of the payment.
     * @param transactionID ID of the transaction.
     * @param transaction 
     */
    updateTransaction(params: { buyerID: string; orderID: string; paymentID: string; transactionID: string; transaction: PaymentTransaction;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PaymentApiFetchParamCreactor.updateTransaction(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * PaymentApi - object-oriented interface
 */
export class PaymentApi extends BaseAPI {
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param paymentID ID of the payment.
     */
    _delete(params: {  buyerID: string; orderID: string; paymentID: string; }) {
        return PaymentApiFp._delete(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param payment 
     */
    create(params: {  buyerID: string; orderID: string; payment: Payment; }) {
        return PaymentApiFp.create(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param paymentID ID of the payment.
     * @param transaction 
     */
    createTransaction(params: {  buyerID: string; orderID: string; paymentID: string; transaction: PaymentTransaction; }) {
        return PaymentApiFp.createTransaction(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param paymentID ID of the payment.
     * @param transactionID ID of the transaction.
     */
    deleteTransaction(params: {  buyerID: string; orderID: string; paymentID: string; transactionID: string; }) {
        return PaymentApiFp.deleteTransaction(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param paymentID ID of the payment.
     */
    get(params: {  buyerID: string; orderID: string; paymentID: string; }) {
        return PaymentApiFp.get(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    list(params: {  buyerID: string; orderID: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
        return PaymentApiFp.list(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param paymentID ID of the payment.
     * @param partialPayment 
     */
    patch(params: {  buyerID: string; orderID: string; paymentID: string; partialPayment: Payment; }) {
        return PaymentApiFp.patch(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param paymentID ID of the payment.
     * @param transactionID ID of the transaction.
     * @param partialTransaction 
     */
    patchTransaction(params: {  buyerID: string; orderID: string; paymentID: string; transactionID: string; partialTransaction: PaymentTransaction; }) {
        return PaymentApiFp.patchTransaction(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param paymentID ID of the payment.
     * @param payment 
     */
    update(params: {  buyerID: string; orderID: string; paymentID: string; payment: Payment; }) {
        return PaymentApiFp.update(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param paymentID ID of the payment.
     * @param transactionID ID of the transaction.
     * @param transaction 
     */
    updateTransaction(params: {  buyerID: string; orderID: string; paymentID: string; transactionID: string; transaction: PaymentTransaction; }) {
        return PaymentApiFp.updateTransaction(params)(this.fetch, this.basePath);
    }
};

/**
 * PaymentApi - factory interface
 */
export const PaymentApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * @param buyerID ID of the buyer.
         * @param orderID ID of the order.
         * @param paymentID ID of the payment.
         */
        _delete(params: {  buyerID: string; orderID: string; paymentID: string; }) {
            return PaymentApiFp._delete(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param orderID ID of the order.
         * @param payment 
         */
        create(params: {  buyerID: string; orderID: string; payment: Payment; }) {
            return PaymentApiFp.create(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param orderID ID of the order.
         * @param paymentID ID of the payment.
         * @param transaction 
         */
        createTransaction(params: {  buyerID: string; orderID: string; paymentID: string; transaction: PaymentTransaction; }) {
            return PaymentApiFp.createTransaction(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param orderID ID of the order.
         * @param paymentID ID of the payment.
         * @param transactionID ID of the transaction.
         */
        deleteTransaction(params: {  buyerID: string; orderID: string; paymentID: string; transactionID: string; }) {
            return PaymentApiFp.deleteTransaction(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param orderID ID of the order.
         * @param paymentID ID of the payment.
         */
        get(params: {  buyerID: string; orderID: string; paymentID: string; }) {
            return PaymentApiFp.get(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param orderID ID of the order.
         * @param search Word or phrase to search for.
         * @param searchOn Comma-delimited list of fields to search on.
         * @param sortBy Comma-delimited list of fields to sort by.
         * @param page Page of results to return. Default: 1
         * @param pageSize Number of results to return per page. Default: 20, max: 100.
         */
        list(params: {  buyerID: string; orderID: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
            return PaymentApiFp.list(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param orderID ID of the order.
         * @param paymentID ID of the payment.
         * @param partialPayment 
         */
        patch(params: {  buyerID: string; orderID: string; paymentID: string; partialPayment: Payment; }) {
            return PaymentApiFp.patch(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param orderID ID of the order.
         * @param paymentID ID of the payment.
         * @param transactionID ID of the transaction.
         * @param partialTransaction 
         */
        patchTransaction(params: {  buyerID: string; orderID: string; paymentID: string; transactionID: string; partialTransaction: PaymentTransaction; }) {
            return PaymentApiFp.patchTransaction(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param orderID ID of the order.
         * @param paymentID ID of the payment.
         * @param payment 
         */
        update(params: {  buyerID: string; orderID: string; paymentID: string; payment: Payment; }) {
            return PaymentApiFp.update(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param orderID ID of the order.
         * @param paymentID ID of the payment.
         * @param transactionID ID of the transaction.
         * @param transaction 
         */
        updateTransaction(params: {  buyerID: string; orderID: string; paymentID: string; transactionID: string; transaction: PaymentTransaction; }) {
            return PaymentApiFp.updateTransaction(params)(fetch, basePath);
        },
    }
};


/**
 * PriceScheduleApi - fetch parameter creator
 */
export const PriceScheduleApiFetchParamCreactor = {
    /** 
     * @param priceScheduleID ID of the price schedule.
     */
    _delete(params: {  priceScheduleID: string; }): FetchArgs {
        // verify required parameter "priceScheduleID" is set
        if (params["priceScheduleID"] == null) {
            throw new Error("Missing required parameter priceScheduleID when calling _delete");
        }
        const baseUrl = `/priceschedules/{priceScheduleID}`
            .replace(`{${"priceScheduleID"}}`, `${ params.priceScheduleID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "DELETE" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param priceSchedule 
     */
    create(params: {  priceSchedule: PriceSchedule; }): FetchArgs {
        // verify required parameter "priceSchedule" is set
        if (params["priceSchedule"] == null) {
            throw new Error("Missing required parameter priceSchedule when calling create");
        }
        const baseUrl = `/priceschedules`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["priceSchedule"]) {
            fetchOptions.body = JSON.stringify(params["priceSchedule"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param priceScheduleID ID of the price schedule.
     * @param quantity Quantity of the price schedule.
     */
    deletePriceBreak(params: {  priceScheduleID: string; quantity: number; }): FetchArgs {
        // verify required parameter "priceScheduleID" is set
        if (params["priceScheduleID"] == null) {
            throw new Error("Missing required parameter priceScheduleID when calling deletePriceBreak");
        }
        // verify required parameter "quantity" is set
        if (params["quantity"] == null) {
            throw new Error("Missing required parameter quantity when calling deletePriceBreak");
        }
        const baseUrl = `/priceschedules/{priceScheduleID}/PriceBreaks`
            .replace(`{${"priceScheduleID"}}`, `${ params.priceScheduleID }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "quantity": params.quantity,
        });
        let fetchOptions: RequestInit = { method: "DELETE" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param priceScheduleID ID of the price schedule.
     */
    get(params: {  priceScheduleID: string; }): FetchArgs {
        // verify required parameter "priceScheduleID" is set
        if (params["priceScheduleID"] == null) {
            throw new Error("Missing required parameter priceScheduleID when calling get");
        }
        const baseUrl = `/priceschedules/{priceScheduleID}`
            .replace(`{${"priceScheduleID"}}`, `${ params.priceScheduleID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    list(params: {  search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }): FetchArgs {
        const baseUrl = `/priceschedules`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "search": params.search,
            "searchOn": params.searchOn,
            "sortBy": params.sortBy,
            "page": params.page,
            "pageSize": params.pageSize,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param priceScheduleID ID of the price schedule.
     * @param priceSchedule 
     */
    patch(params: {  priceScheduleID: string; priceSchedule: PriceSchedule; }): FetchArgs {
        // verify required parameter "priceScheduleID" is set
        if (params["priceScheduleID"] == null) {
            throw new Error("Missing required parameter priceScheduleID when calling patch");
        }
        // verify required parameter "priceSchedule" is set
        if (params["priceSchedule"] == null) {
            throw new Error("Missing required parameter priceSchedule when calling patch");
        }
        const baseUrl = `/priceschedules/{priceScheduleID}`
            .replace(`{${"priceScheduleID"}}`, `${ params.priceScheduleID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PATCH" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["priceSchedule"]) {
            fetchOptions.body = JSON.stringify(params["priceSchedule"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param priceScheduleID ID of the price schedule.
     * @param priceBreak 
     */
    savePriceBreak(params: {  priceScheduleID: string; priceBreak: PriceBreak; }): FetchArgs {
        // verify required parameter "priceScheduleID" is set
        if (params["priceScheduleID"] == null) {
            throw new Error("Missing required parameter priceScheduleID when calling savePriceBreak");
        }
        // verify required parameter "priceBreak" is set
        if (params["priceBreak"] == null) {
            throw new Error("Missing required parameter priceBreak when calling savePriceBreak");
        }
        const baseUrl = `/priceschedules/{priceScheduleID}/PriceBreaks`
            .replace(`{${"priceScheduleID"}}`, `${ params.priceScheduleID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["priceBreak"]) {
            fetchOptions.body = JSON.stringify(params["priceBreak"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param priceScheduleID ID of the price schedule.
     * @param priceSchedule 
     */
    update(params: {  priceScheduleID: string; priceSchedule: PriceSchedule; }): FetchArgs {
        // verify required parameter "priceScheduleID" is set
        if (params["priceScheduleID"] == null) {
            throw new Error("Missing required parameter priceScheduleID when calling update");
        }
        // verify required parameter "priceSchedule" is set
        if (params["priceSchedule"] == null) {
            throw new Error("Missing required parameter priceSchedule when calling update");
        }
        const baseUrl = `/priceschedules/{priceScheduleID}`
            .replace(`{${"priceScheduleID"}}`, `${ params.priceScheduleID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PUT" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["priceSchedule"]) {
            fetchOptions.body = JSON.stringify(params["priceSchedule"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
}

/**
 * PriceScheduleApi - functional programming interface
 */
export const PriceScheduleApiFp = {
    /** 
     * @param priceScheduleID ID of the price schedule.
     */
    _delete(params: { priceScheduleID: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PriceScheduleApiFetchParamCreactor._delete(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param priceSchedule 
     */
    create(params: { priceSchedule: PriceSchedule;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PriceScheduleApiFetchParamCreactor.create(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param priceScheduleID ID of the price schedule.
     * @param quantity Quantity of the price schedule.
     */
    deletePriceBreak(params: { priceScheduleID: string; quantity: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PriceScheduleApiFetchParamCreactor.deletePriceBreak(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param priceScheduleID ID of the price schedule.
     */
    get(params: { priceScheduleID: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PriceScheduleApiFetchParamCreactor.get(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    list(params: { search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PriceScheduleApiFetchParamCreactor.list(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param priceScheduleID ID of the price schedule.
     * @param priceSchedule 
     */
    patch(params: { priceScheduleID: string; priceSchedule: PriceSchedule;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PriceScheduleApiFetchParamCreactor.patch(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param priceScheduleID ID of the price schedule.
     * @param priceBreak 
     */
    savePriceBreak(params: { priceScheduleID: string; priceBreak: PriceBreak;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PriceScheduleApiFetchParamCreactor.savePriceBreak(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param priceScheduleID ID of the price schedule.
     * @param priceSchedule 
     */
    update(params: { priceScheduleID: string; priceSchedule: PriceSchedule;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PriceScheduleApiFetchParamCreactor.update(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * PriceScheduleApi - object-oriented interface
 */
export class PriceScheduleApi extends BaseAPI {
    /** 
     * @param priceScheduleID ID of the price schedule.
     */
    _delete(params: {  priceScheduleID: string; }) {
        return PriceScheduleApiFp._delete(params)(this.fetch, this.basePath);
    }
    /** 
     * @param priceSchedule 
     */
    create(params: {  priceSchedule: PriceSchedule; }) {
        return PriceScheduleApiFp.create(params)(this.fetch, this.basePath);
    }
    /** 
     * @param priceScheduleID ID of the price schedule.
     * @param quantity Quantity of the price schedule.
     */
    deletePriceBreak(params: {  priceScheduleID: string; quantity: number; }) {
        return PriceScheduleApiFp.deletePriceBreak(params)(this.fetch, this.basePath);
    }
    /** 
     * @param priceScheduleID ID of the price schedule.
     */
    get(params: {  priceScheduleID: string; }) {
        return PriceScheduleApiFp.get(params)(this.fetch, this.basePath);
    }
    /** 
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    list(params: {  search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
        return PriceScheduleApiFp.list(params)(this.fetch, this.basePath);
    }
    /** 
     * @param priceScheduleID ID of the price schedule.
     * @param priceSchedule 
     */
    patch(params: {  priceScheduleID: string; priceSchedule: PriceSchedule; }) {
        return PriceScheduleApiFp.patch(params)(this.fetch, this.basePath);
    }
    /** 
     * @param priceScheduleID ID of the price schedule.
     * @param priceBreak 
     */
    savePriceBreak(params: {  priceScheduleID: string; priceBreak: PriceBreak; }) {
        return PriceScheduleApiFp.savePriceBreak(params)(this.fetch, this.basePath);
    }
    /** 
     * @param priceScheduleID ID of the price schedule.
     * @param priceSchedule 
     */
    update(params: {  priceScheduleID: string; priceSchedule: PriceSchedule; }) {
        return PriceScheduleApiFp.update(params)(this.fetch, this.basePath);
    }
};

/**
 * PriceScheduleApi - factory interface
 */
export const PriceScheduleApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * @param priceScheduleID ID of the price schedule.
         */
        _delete(params: {  priceScheduleID: string; }) {
            return PriceScheduleApiFp._delete(params)(fetch, basePath);
        },
        /** 
         * @param priceSchedule 
         */
        create(params: {  priceSchedule: PriceSchedule; }) {
            return PriceScheduleApiFp.create(params)(fetch, basePath);
        },
        /** 
         * @param priceScheduleID ID of the price schedule.
         * @param quantity Quantity of the price schedule.
         */
        deletePriceBreak(params: {  priceScheduleID: string; quantity: number; }) {
            return PriceScheduleApiFp.deletePriceBreak(params)(fetch, basePath);
        },
        /** 
         * @param priceScheduleID ID of the price schedule.
         */
        get(params: {  priceScheduleID: string; }) {
            return PriceScheduleApiFp.get(params)(fetch, basePath);
        },
        /** 
         * @param search Word or phrase to search for.
         * @param searchOn Comma-delimited list of fields to search on.
         * @param sortBy Comma-delimited list of fields to sort by.
         * @param page Page of results to return. Default: 1
         * @param pageSize Number of results to return per page. Default: 20, max: 100.
         */
        list(params: {  search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
            return PriceScheduleApiFp.list(params)(fetch, basePath);
        },
        /** 
         * @param priceScheduleID ID of the price schedule.
         * @param priceSchedule 
         */
        patch(params: {  priceScheduleID: string; priceSchedule: PriceSchedule; }) {
            return PriceScheduleApiFp.patch(params)(fetch, basePath);
        },
        /** 
         * @param priceScheduleID ID of the price schedule.
         * @param priceBreak 
         */
        savePriceBreak(params: {  priceScheduleID: string; priceBreak: PriceBreak; }) {
            return PriceScheduleApiFp.savePriceBreak(params)(fetch, basePath);
        },
        /** 
         * @param priceScheduleID ID of the price schedule.
         * @param priceSchedule 
         */
        update(params: {  priceScheduleID: string; priceSchedule: PriceSchedule; }) {
            return PriceScheduleApiFp.update(params)(fetch, basePath);
        },
    }
};


/**
 * ProductApi - fetch parameter creator
 */
export const ProductApiFetchParamCreactor = {
    /** 
     * @param productID ID of the product.
     */
    _delete(params: {  productID: string; }): FetchArgs {
        // verify required parameter "productID" is set
        if (params["productID"] == null) {
            throw new Error("Missing required parameter productID when calling _delete");
        }
        const baseUrl = `/products/{productID}`
            .replace(`{${"productID"}}`, `${ params.productID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "DELETE" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param product 
     */
    create(params: {  product: Product; }): FetchArgs {
        // verify required parameter "product" is set
        if (params["product"] == null) {
            throw new Error("Missing required parameter product when calling create");
        }
        const baseUrl = `/products`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["product"]) {
            fetchOptions.body = JSON.stringify(params["product"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param productID ID of the product.
     * @param userID ID of the user.
     * @param userGroupID ID of the user group.
     */
    deleteAssignment(params: {  buyerID: string; productID: string; userID?: string; userGroupID?: string; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling deleteAssignment");
        }
        // verify required parameter "productID" is set
        if (params["productID"] == null) {
            throw new Error("Missing required parameter productID when calling deleteAssignment");
        }
        const baseUrl = `/products/{productID}/assignments/{buyerID}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"productID"}}`, `${ params.productID }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "userID": params.userID,
            "userGroupID": params.userGroupID,
        });
        let fetchOptions: RequestInit = { method: "DELETE" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param productID ID of the product.
     * @param overwriteExisting Overwrite existing of the product.
     */
    generateVariants(params: {  productID: string; overwriteExisting?: boolean; }): FetchArgs {
        // verify required parameter "productID" is set
        if (params["productID"] == null) {
            throw new Error("Missing required parameter productID when calling generateVariants");
        }
        const baseUrl = `/products/{productID}/variants/generate`
            .replace(`{${"productID"}}`, `${ params.productID }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "overwriteExisting": params.overwriteExisting,
        });
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param productID ID of the product.
     */
    get(params: {  productID: string; }): FetchArgs {
        // verify required parameter "productID" is set
        if (params["productID"] == null) {
            throw new Error("Missing required parameter productID when calling get");
        }
        const baseUrl = `/products/{productID}`
            .replace(`{${"productID"}}`, `${ params.productID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param productID ID of the product.
     */
    getInventory(params: {  productID: string; }): FetchArgs {
        // verify required parameter "productID" is set
        if (params["productID"] == null) {
            throw new Error("Missing required parameter productID when calling getInventory");
        }
        const baseUrl = `/products/{productID}/inventory`
            .replace(`{${"productID"}}`, `${ params.productID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param productID ID of the product.
     * @param variantID ID of the variant.
     */
    getVariant(params: {  productID: string; variantID: string; }): FetchArgs {
        // verify required parameter "productID" is set
        if (params["productID"] == null) {
            throw new Error("Missing required parameter productID when calling getVariant");
        }
        // verify required parameter "variantID" is set
        if (params["variantID"] == null) {
            throw new Error("Missing required parameter variantID when calling getVariant");
        }
        const baseUrl = `/products/{productID}/variants/{variantID}`
            .replace(`{${"productID"}}`, `${ params.productID }`)
            .replace(`{${"variantID"}}`, `${ params.variantID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param productID ID of the product.
     * @param variantID ID of the variant.
     */
    getVariantInventory(params: {  productID: string; variantID: string; }): FetchArgs {
        // verify required parameter "productID" is set
        if (params["productID"] == null) {
            throw new Error("Missing required parameter productID when calling getVariantInventory");
        }
        // verify required parameter "variantID" is set
        if (params["variantID"] == null) {
            throw new Error("Missing required parameter variantID when calling getVariantInventory");
        }
        const baseUrl = `/products/{productID}/variants/inventory/{variantID}`
            .replace(`{${"productID"}}`, `${ params.productID }`)
            .replace(`{${"variantID"}}`, `${ params.variantID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    list(params: {  search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }): FetchArgs {
        const baseUrl = `/products`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "search": params.search,
            "searchOn": params.searchOn,
            "sortBy": params.sortBy,
            "page": params.page,
            "pageSize": params.pageSize,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param productID ID of the product.
     * @param buyerID ID of the buyer.
     * @param userID ID of the user.
     * @param userGroupID ID of the user group.
     * @param level Level of the product.
     * @param priceScheduleID ID of the price schedule.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listAssignments(params: {  productID?: string; buyerID?: string; userID?: string; userGroupID?: string; level?: string; priceScheduleID?: string; page?: number; pageSize?: number; }): FetchArgs {
        const baseUrl = `/products/assignments`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "productID": params.productID,
            "buyerID": params.buyerID,
            "userID": params.userID,
            "userGroupID": params.userGroupID,
            "level": params.level,
            "priceScheduleID": params.priceScheduleID,
            "page": params.page,
            "pageSize": params.pageSize,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listInventory(params: {  search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }): FetchArgs {
        const baseUrl = `/products/inventory`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "search": params.search,
            "searchOn": params.searchOn,
            "sortBy": params.sortBy,
            "page": params.page,
            "pageSize": params.pageSize,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param productID ID of the product.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listVariantInventory(params: {  productID: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }): FetchArgs {
        // verify required parameter "productID" is set
        if (params["productID"] == null) {
            throw new Error("Missing required parameter productID when calling listVariantInventory");
        }
        const baseUrl = `/products/{productID}/variants/inventory`
            .replace(`{${"productID"}}`, `${ params.productID }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "search": params.search,
            "searchOn": params.searchOn,
            "sortBy": params.sortBy,
            "page": params.page,
            "pageSize": params.pageSize,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param productID ID of the product.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listVariants(params: {  productID: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }): FetchArgs {
        // verify required parameter "productID" is set
        if (params["productID"] == null) {
            throw new Error("Missing required parameter productID when calling listVariants");
        }
        const baseUrl = `/products/{productID}/variants`
            .replace(`{${"productID"}}`, `${ params.productID }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "search": params.search,
            "searchOn": params.searchOn,
            "sortBy": params.sortBy,
            "page": params.page,
            "pageSize": params.pageSize,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param productID ID of the product.
     * @param product 
     */
    patch(params: {  productID: string; product: Product; }): FetchArgs {
        // verify required parameter "productID" is set
        if (params["productID"] == null) {
            throw new Error("Missing required parameter productID when calling patch");
        }
        // verify required parameter "product" is set
        if (params["product"] == null) {
            throw new Error("Missing required parameter product when calling patch");
        }
        const baseUrl = `/products/{productID}`
            .replace(`{${"productID"}}`, `${ params.productID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PATCH" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["product"]) {
            fetchOptions.body = JSON.stringify(params["product"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param productID ID of the product.
     * @param variantID ID of the variant.
     * @param variant 
     */
    patchVariant(params: {  productID: string; variantID: string; variant: Variant; }): FetchArgs {
        // verify required parameter "productID" is set
        if (params["productID"] == null) {
            throw new Error("Missing required parameter productID when calling patchVariant");
        }
        // verify required parameter "variantID" is set
        if (params["variantID"] == null) {
            throw new Error("Missing required parameter variantID when calling patchVariant");
        }
        // verify required parameter "variant" is set
        if (params["variant"] == null) {
            throw new Error("Missing required parameter variant when calling patchVariant");
        }
        const baseUrl = `/products/{productID}/variants/{variantID}`
            .replace(`{${"productID"}}`, `${ params.productID }`)
            .replace(`{${"variantID"}}`, `${ params.variantID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PATCH" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["variant"]) {
            fetchOptions.body = JSON.stringify(params["variant"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param productAssignment 
     */
    saveAssignment(params: {  productAssignment: ProductAssignment; }): FetchArgs {
        // verify required parameter "productAssignment" is set
        if (params["productAssignment"] == null) {
            throw new Error("Missing required parameter productAssignment when calling saveAssignment");
        }
        const baseUrl = `/products/assignments`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["productAssignment"]) {
            fetchOptions.body = JSON.stringify(params["productAssignment"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param productID ID of the product.
     * @param product 
     */
    update(params: {  productID: string; product: Product; }): FetchArgs {
        // verify required parameter "productID" is set
        if (params["productID"] == null) {
            throw new Error("Missing required parameter productID when calling update");
        }
        // verify required parameter "product" is set
        if (params["product"] == null) {
            throw new Error("Missing required parameter product when calling update");
        }
        const baseUrl = `/products/{productID}`
            .replace(`{${"productID"}}`, `${ params.productID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PUT" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["product"]) {
            fetchOptions.body = JSON.stringify(params["product"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param productID ID of the product.
     * @param inventory Inventory of the product.
     */
    updateInventory(params: {  productID: string; inventory: number; }): FetchArgs {
        // verify required parameter "productID" is set
        if (params["productID"] == null) {
            throw new Error("Missing required parameter productID when calling updateInventory");
        }
        // verify required parameter "inventory" is set
        if (params["inventory"] == null) {
            throw new Error("Missing required parameter inventory when calling updateInventory");
        }
        const baseUrl = `/products/{productID}/inventory/{inventory}`
            .replace(`{${"productID"}}`, `${ params.productID }`)
            .replace(`{${"inventory"}}`, `${ params.inventory }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PUT" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param productID ID of the product.
     * @param variantID ID of the variant.
     * @param variant 
     */
    updateVariant(params: {  productID: string; variantID: string; variant: Variant; }): FetchArgs {
        // verify required parameter "productID" is set
        if (params["productID"] == null) {
            throw new Error("Missing required parameter productID when calling updateVariant");
        }
        // verify required parameter "variantID" is set
        if (params["variantID"] == null) {
            throw new Error("Missing required parameter variantID when calling updateVariant");
        }
        // verify required parameter "variant" is set
        if (params["variant"] == null) {
            throw new Error("Missing required parameter variant when calling updateVariant");
        }
        const baseUrl = `/products/{productID}/variants/{variantID}`
            .replace(`{${"productID"}}`, `${ params.productID }`)
            .replace(`{${"variantID"}}`, `${ params.variantID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PUT" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["variant"]) {
            fetchOptions.body = JSON.stringify(params["variant"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param productID ID of the product.
     * @param variantID ID of the variant.
     * @param inventory Inventory of the product.
     */
    updateVariantInventory(params: {  productID: string; variantID: string; inventory: number; }): FetchArgs {
        // verify required parameter "productID" is set
        if (params["productID"] == null) {
            throw new Error("Missing required parameter productID when calling updateVariantInventory");
        }
        // verify required parameter "variantID" is set
        if (params["variantID"] == null) {
            throw new Error("Missing required parameter variantID when calling updateVariantInventory");
        }
        // verify required parameter "inventory" is set
        if (params["inventory"] == null) {
            throw new Error("Missing required parameter inventory when calling updateVariantInventory");
        }
        const baseUrl = `/products/{productID}/variants/inventory/{variantID}/{inventory}`
            .replace(`{${"productID"}}`, `${ params.productID }`)
            .replace(`{${"variantID"}}`, `${ params.variantID }`)
            .replace(`{${"inventory"}}`, `${ params.inventory }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PUT" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
}

/**
 * ProductApi - functional programming interface
 */
export const ProductApiFp = {
    /** 
     * @param productID ID of the product.
     */
    _delete(params: { productID: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ProductApiFetchParamCreactor._delete(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param product 
     */
    create(params: { product: Product;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ProductApiFetchParamCreactor.create(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param productID ID of the product.
     * @param userID ID of the user.
     * @param userGroupID ID of the user group.
     */
    deleteAssignment(params: { buyerID: string; productID: string; userID?: string; userGroupID?: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ProductApiFetchParamCreactor.deleteAssignment(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param productID ID of the product.
     * @param overwriteExisting Overwrite existing of the product.
     */
    generateVariants(params: { productID: string; overwriteExisting?: boolean;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ProductApiFetchParamCreactor.generateVariants(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param productID ID of the product.
     */
    get(params: { productID: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ProductApiFetchParamCreactor.get(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param productID ID of the product.
     */
    getInventory(params: { productID: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ProductApiFetchParamCreactor.getInventory(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param productID ID of the product.
     * @param variantID ID of the variant.
     */
    getVariant(params: { productID: string; variantID: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ProductApiFetchParamCreactor.getVariant(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param productID ID of the product.
     * @param variantID ID of the variant.
     */
    getVariantInventory(params: { productID: string; variantID: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ProductApiFetchParamCreactor.getVariantInventory(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    list(params: { search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ProductApiFetchParamCreactor.list(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param productID ID of the product.
     * @param buyerID ID of the buyer.
     * @param userID ID of the user.
     * @param userGroupID ID of the user group.
     * @param level Level of the product.
     * @param priceScheduleID ID of the price schedule.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listAssignments(params: { productID?: string; buyerID?: string; userID?: string; userGroupID?: string; level?: string; priceScheduleID?: string; page?: number; pageSize?: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ProductApiFetchParamCreactor.listAssignments(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listInventory(params: { search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ProductApiFetchParamCreactor.listInventory(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param productID ID of the product.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listVariantInventory(params: { productID: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ProductApiFetchParamCreactor.listVariantInventory(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param productID ID of the product.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listVariants(params: { productID: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ProductApiFetchParamCreactor.listVariants(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param productID ID of the product.
     * @param product 
     */
    patch(params: { productID: string; product: Product;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ProductApiFetchParamCreactor.patch(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param productID ID of the product.
     * @param variantID ID of the variant.
     * @param variant 
     */
    patchVariant(params: { productID: string; variantID: string; variant: Variant;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ProductApiFetchParamCreactor.patchVariant(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param productAssignment 
     */
    saveAssignment(params: { productAssignment: ProductAssignment;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ProductApiFetchParamCreactor.saveAssignment(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param productID ID of the product.
     * @param product 
     */
    update(params: { productID: string; product: Product;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ProductApiFetchParamCreactor.update(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param productID ID of the product.
     * @param inventory Inventory of the product.
     */
    updateInventory(params: { productID: string; inventory: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ProductApiFetchParamCreactor.updateInventory(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param productID ID of the product.
     * @param variantID ID of the variant.
     * @param variant 
     */
    updateVariant(params: { productID: string; variantID: string; variant: Variant;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ProductApiFetchParamCreactor.updateVariant(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param productID ID of the product.
     * @param variantID ID of the variant.
     * @param inventory Inventory of the product.
     */
    updateVariantInventory(params: { productID: string; variantID: string; inventory: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ProductApiFetchParamCreactor.updateVariantInventory(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * ProductApi - object-oriented interface
 */
export class ProductApi extends BaseAPI {
    /** 
     * @param productID ID of the product.
     */
    _delete(params: {  productID: string; }) {
        return ProductApiFp._delete(params)(this.fetch, this.basePath);
    }
    /** 
     * @param product 
     */
    create(params: {  product: Product; }) {
        return ProductApiFp.create(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param productID ID of the product.
     * @param userID ID of the user.
     * @param userGroupID ID of the user group.
     */
    deleteAssignment(params: {  buyerID: string; productID: string; userID?: string; userGroupID?: string; }) {
        return ProductApiFp.deleteAssignment(params)(this.fetch, this.basePath);
    }
    /** 
     * @param productID ID of the product.
     * @param overwriteExisting Overwrite existing of the product.
     */
    generateVariants(params: {  productID: string; overwriteExisting?: boolean; }) {
        return ProductApiFp.generateVariants(params)(this.fetch, this.basePath);
    }
    /** 
     * @param productID ID of the product.
     */
    get(params: {  productID: string; }) {
        return ProductApiFp.get(params)(this.fetch, this.basePath);
    }
    /** 
     * @param productID ID of the product.
     */
    getInventory(params: {  productID: string; }) {
        return ProductApiFp.getInventory(params)(this.fetch, this.basePath);
    }
    /** 
     * @param productID ID of the product.
     * @param variantID ID of the variant.
     */
    getVariant(params: {  productID: string; variantID: string; }) {
        return ProductApiFp.getVariant(params)(this.fetch, this.basePath);
    }
    /** 
     * @param productID ID of the product.
     * @param variantID ID of the variant.
     */
    getVariantInventory(params: {  productID: string; variantID: string; }) {
        return ProductApiFp.getVariantInventory(params)(this.fetch, this.basePath);
    }
    /** 
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    list(params: {  search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
        return ProductApiFp.list(params)(this.fetch, this.basePath);
    }
    /** 
     * @param productID ID of the product.
     * @param buyerID ID of the buyer.
     * @param userID ID of the user.
     * @param userGroupID ID of the user group.
     * @param level Level of the product.
     * @param priceScheduleID ID of the price schedule.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listAssignments(params: {  productID?: string; buyerID?: string; userID?: string; userGroupID?: string; level?: string; priceScheduleID?: string; page?: number; pageSize?: number; }) {
        return ProductApiFp.listAssignments(params)(this.fetch, this.basePath);
    }
    /** 
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listInventory(params: {  search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
        return ProductApiFp.listInventory(params)(this.fetch, this.basePath);
    }
    /** 
     * @param productID ID of the product.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listVariantInventory(params: {  productID: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
        return ProductApiFp.listVariantInventory(params)(this.fetch, this.basePath);
    }
    /** 
     * @param productID ID of the product.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listVariants(params: {  productID: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
        return ProductApiFp.listVariants(params)(this.fetch, this.basePath);
    }
    /** 
     * @param productID ID of the product.
     * @param product 
     */
    patch(params: {  productID: string; product: Product; }) {
        return ProductApiFp.patch(params)(this.fetch, this.basePath);
    }
    /** 
     * @param productID ID of the product.
     * @param variantID ID of the variant.
     * @param variant 
     */
    patchVariant(params: {  productID: string; variantID: string; variant: Variant; }) {
        return ProductApiFp.patchVariant(params)(this.fetch, this.basePath);
    }
    /** 
     * @param productAssignment 
     */
    saveAssignment(params: {  productAssignment: ProductAssignment; }) {
        return ProductApiFp.saveAssignment(params)(this.fetch, this.basePath);
    }
    /** 
     * @param productID ID of the product.
     * @param product 
     */
    update(params: {  productID: string; product: Product; }) {
        return ProductApiFp.update(params)(this.fetch, this.basePath);
    }
    /** 
     * @param productID ID of the product.
     * @param inventory Inventory of the product.
     */
    updateInventory(params: {  productID: string; inventory: number; }) {
        return ProductApiFp.updateInventory(params)(this.fetch, this.basePath);
    }
    /** 
     * @param productID ID of the product.
     * @param variantID ID of the variant.
     * @param variant 
     */
    updateVariant(params: {  productID: string; variantID: string; variant: Variant; }) {
        return ProductApiFp.updateVariant(params)(this.fetch, this.basePath);
    }
    /** 
     * @param productID ID of the product.
     * @param variantID ID of the variant.
     * @param inventory Inventory of the product.
     */
    updateVariantInventory(params: {  productID: string; variantID: string; inventory: number; }) {
        return ProductApiFp.updateVariantInventory(params)(this.fetch, this.basePath);
    }
};

/**
 * ProductApi - factory interface
 */
export const ProductApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * @param productID ID of the product.
         */
        _delete(params: {  productID: string; }) {
            return ProductApiFp._delete(params)(fetch, basePath);
        },
        /** 
         * @param product 
         */
        create(params: {  product: Product; }) {
            return ProductApiFp.create(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param productID ID of the product.
         * @param userID ID of the user.
         * @param userGroupID ID of the user group.
         */
        deleteAssignment(params: {  buyerID: string; productID: string; userID?: string; userGroupID?: string; }) {
            return ProductApiFp.deleteAssignment(params)(fetch, basePath);
        },
        /** 
         * @param productID ID of the product.
         * @param overwriteExisting Overwrite existing of the product.
         */
        generateVariants(params: {  productID: string; overwriteExisting?: boolean; }) {
            return ProductApiFp.generateVariants(params)(fetch, basePath);
        },
        /** 
         * @param productID ID of the product.
         */
        get(params: {  productID: string; }) {
            return ProductApiFp.get(params)(fetch, basePath);
        },
        /** 
         * @param productID ID of the product.
         */
        getInventory(params: {  productID: string; }) {
            return ProductApiFp.getInventory(params)(fetch, basePath);
        },
        /** 
         * @param productID ID of the product.
         * @param variantID ID of the variant.
         */
        getVariant(params: {  productID: string; variantID: string; }) {
            return ProductApiFp.getVariant(params)(fetch, basePath);
        },
        /** 
         * @param productID ID of the product.
         * @param variantID ID of the variant.
         */
        getVariantInventory(params: {  productID: string; variantID: string; }) {
            return ProductApiFp.getVariantInventory(params)(fetch, basePath);
        },
        /** 
         * @param search Word or phrase to search for.
         * @param searchOn Comma-delimited list of fields to search on.
         * @param sortBy Comma-delimited list of fields to sort by.
         * @param page Page of results to return. Default: 1
         * @param pageSize Number of results to return per page. Default: 20, max: 100.
         */
        list(params: {  search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
            return ProductApiFp.list(params)(fetch, basePath);
        },
        /** 
         * @param productID ID of the product.
         * @param buyerID ID of the buyer.
         * @param userID ID of the user.
         * @param userGroupID ID of the user group.
         * @param level Level of the product.
         * @param priceScheduleID ID of the price schedule.
         * @param page Page of results to return. Default: 1
         * @param pageSize Number of results to return per page. Default: 20, max: 100.
         */
        listAssignments(params: {  productID?: string; buyerID?: string; userID?: string; userGroupID?: string; level?: string; priceScheduleID?: string; page?: number; pageSize?: number; }) {
            return ProductApiFp.listAssignments(params)(fetch, basePath);
        },
        /** 
         * @param search Word or phrase to search for.
         * @param searchOn Comma-delimited list of fields to search on.
         * @param sortBy Comma-delimited list of fields to sort by.
         * @param page Page of results to return. Default: 1
         * @param pageSize Number of results to return per page. Default: 20, max: 100.
         */
        listInventory(params: {  search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
            return ProductApiFp.listInventory(params)(fetch, basePath);
        },
        /** 
         * @param productID ID of the product.
         * @param search Word or phrase to search for.
         * @param searchOn Comma-delimited list of fields to search on.
         * @param sortBy Comma-delimited list of fields to sort by.
         * @param page Page of results to return. Default: 1
         * @param pageSize Number of results to return per page. Default: 20, max: 100.
         */
        listVariantInventory(params: {  productID: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
            return ProductApiFp.listVariantInventory(params)(fetch, basePath);
        },
        /** 
         * @param productID ID of the product.
         * @param search Word or phrase to search for.
         * @param searchOn Comma-delimited list of fields to search on.
         * @param sortBy Comma-delimited list of fields to sort by.
         * @param page Page of results to return. Default: 1
         * @param pageSize Number of results to return per page. Default: 20, max: 100.
         */
        listVariants(params: {  productID: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
            return ProductApiFp.listVariants(params)(fetch, basePath);
        },
        /** 
         * @param productID ID of the product.
         * @param product 
         */
        patch(params: {  productID: string; product: Product; }) {
            return ProductApiFp.patch(params)(fetch, basePath);
        },
        /** 
         * @param productID ID of the product.
         * @param variantID ID of the variant.
         * @param variant 
         */
        patchVariant(params: {  productID: string; variantID: string; variant: Variant; }) {
            return ProductApiFp.patchVariant(params)(fetch, basePath);
        },
        /** 
         * @param productAssignment 
         */
        saveAssignment(params: {  productAssignment: ProductAssignment; }) {
            return ProductApiFp.saveAssignment(params)(fetch, basePath);
        },
        /** 
         * @param productID ID of the product.
         * @param product 
         */
        update(params: {  productID: string; product: Product; }) {
            return ProductApiFp.update(params)(fetch, basePath);
        },
        /** 
         * @param productID ID of the product.
         * @param inventory Inventory of the product.
         */
        updateInventory(params: {  productID: string; inventory: number; }) {
            return ProductApiFp.updateInventory(params)(fetch, basePath);
        },
        /** 
         * @param productID ID of the product.
         * @param variantID ID of the variant.
         * @param variant 
         */
        updateVariant(params: {  productID: string; variantID: string; variant: Variant; }) {
            return ProductApiFp.updateVariant(params)(fetch, basePath);
        },
        /** 
         * @param productID ID of the product.
         * @param variantID ID of the variant.
         * @param inventory Inventory of the product.
         */
        updateVariantInventory(params: {  productID: string; variantID: string; inventory: number; }) {
            return ProductApiFp.updateVariantInventory(params)(fetch, basePath);
        },
    }
};


/**
 * PromotionApi - fetch parameter creator
 */
export const PromotionApiFetchParamCreactor = {
    /** 
     * @param promotionID ID of the promotion.
     */
    _delete(params: {  promotionID: string; }): FetchArgs {
        // verify required parameter "promotionID" is set
        if (params["promotionID"] == null) {
            throw new Error("Missing required parameter promotionID when calling _delete");
        }
        const baseUrl = `/promotions/{promotionID}`
            .replace(`{${"promotionID"}}`, `${ params.promotionID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "DELETE" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param promo 
     */
    create(params: {  promo: Promotion; }): FetchArgs {
        // verify required parameter "promo" is set
        if (params["promo"] == null) {
            throw new Error("Missing required parameter promo when calling create");
        }
        const baseUrl = `/promotions`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["promo"]) {
            fetchOptions.body = JSON.stringify(params["promo"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param promotionID ID of the promotion.
     * @param buyerID ID of the buyer.
     * @param userID ID of the user.
     * @param userGroupID ID of the user group.
     */
    deleteAssignment(params: {  promotionID: string; buyerID: string; userID?: string; userGroupID?: string; }): FetchArgs {
        // verify required parameter "promotionID" is set
        if (params["promotionID"] == null) {
            throw new Error("Missing required parameter promotionID when calling deleteAssignment");
        }
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling deleteAssignment");
        }
        const baseUrl = `/promotions/{promotionID}/assignments`
            .replace(`{${"promotionID"}}`, `${ params.promotionID }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "buyerID": params.buyerID,
            "userID": params.userID,
            "userGroupID": params.userGroupID,
        });
        let fetchOptions: RequestInit = { method: "DELETE" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param promotionID ID of the promotion.
     */
    get(params: {  promotionID: string; }): FetchArgs {
        // verify required parameter "promotionID" is set
        if (params["promotionID"] == null) {
            throw new Error("Missing required parameter promotionID when calling get");
        }
        const baseUrl = `/promotions/{promotionID}`
            .replace(`{${"promotionID"}}`, `${ params.promotionID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    list(params: {  search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }): FetchArgs {
        const baseUrl = `/promotions`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "search": params.search,
            "searchOn": params.searchOn,
            "sortBy": params.sortBy,
            "page": params.page,
            "pageSize": params.pageSize,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param promotionID ID of the promotion.
     * @param userID ID of the user.
     * @param userGroupID ID of the user group.
     * @param level Level of the promotion.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listAssignments(params: {  buyerID: string; promotionID?: string; userID?: string; userGroupID?: string; level?: string; page?: number; pageSize?: number; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling listAssignments");
        }
        const baseUrl = `/promotions/assignments`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "buyerID": params.buyerID,
            "promotionID": params.promotionID,
            "userID": params.userID,
            "userGroupID": params.userGroupID,
            "level": params.level,
            "page": params.page,
            "pageSize": params.pageSize,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param promotionID ID of the promotion.
     * @param partialPromotion 
     */
    patch(params: {  promotionID: string; partialPromotion: Promotion; }): FetchArgs {
        // verify required parameter "promotionID" is set
        if (params["promotionID"] == null) {
            throw new Error("Missing required parameter promotionID when calling patch");
        }
        // verify required parameter "partialPromotion" is set
        if (params["partialPromotion"] == null) {
            throw new Error("Missing required parameter partialPromotion when calling patch");
        }
        const baseUrl = `/promotions/{promotionID}`
            .replace(`{${"promotionID"}}`, `${ params.promotionID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PATCH" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["partialPromotion"]) {
            fetchOptions.body = JSON.stringify(params["partialPromotion"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param assignment 
     */
    saveAssignment(params: {  assignment: PromotionAssignment; }): FetchArgs {
        // verify required parameter "assignment" is set
        if (params["assignment"] == null) {
            throw new Error("Missing required parameter assignment when calling saveAssignment");
        }
        const baseUrl = `/promotions/assignments`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["assignment"]) {
            fetchOptions.body = JSON.stringify(params["assignment"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param promotionID ID of the promotion.
     * @param promo 
     */
    update(params: {  promotionID: string; promo: Promotion; }): FetchArgs {
        // verify required parameter "promotionID" is set
        if (params["promotionID"] == null) {
            throw new Error("Missing required parameter promotionID when calling update");
        }
        // verify required parameter "promo" is set
        if (params["promo"] == null) {
            throw new Error("Missing required parameter promo when calling update");
        }
        const baseUrl = `/promotions/{promotionID}`
            .replace(`{${"promotionID"}}`, `${ params.promotionID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PUT" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["promo"]) {
            fetchOptions.body = JSON.stringify(params["promo"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
}

/**
 * PromotionApi - functional programming interface
 */
export const PromotionApiFp = {
    /** 
     * @param promotionID ID of the promotion.
     */
    _delete(params: { promotionID: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PromotionApiFetchParamCreactor._delete(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param promo 
     */
    create(params: { promo: Promotion;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PromotionApiFetchParamCreactor.create(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param promotionID ID of the promotion.
     * @param buyerID ID of the buyer.
     * @param userID ID of the user.
     * @param userGroupID ID of the user group.
     */
    deleteAssignment(params: { promotionID: string; buyerID: string; userID?: string; userGroupID?: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PromotionApiFetchParamCreactor.deleteAssignment(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param promotionID ID of the promotion.
     */
    get(params: { promotionID: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PromotionApiFetchParamCreactor.get(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    list(params: { search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PromotionApiFetchParamCreactor.list(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param promotionID ID of the promotion.
     * @param userID ID of the user.
     * @param userGroupID ID of the user group.
     * @param level Level of the promotion.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listAssignments(params: { buyerID: string; promotionID?: string; userID?: string; userGroupID?: string; level?: string; page?: number; pageSize?: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PromotionApiFetchParamCreactor.listAssignments(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param promotionID ID of the promotion.
     * @param partialPromotion 
     */
    patch(params: { promotionID: string; partialPromotion: Promotion;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PromotionApiFetchParamCreactor.patch(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param assignment 
     */
    saveAssignment(params: { assignment: PromotionAssignment;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PromotionApiFetchParamCreactor.saveAssignment(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param promotionID ID of the promotion.
     * @param promo 
     */
    update(params: { promotionID: string; promo: Promotion;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PromotionApiFetchParamCreactor.update(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * PromotionApi - object-oriented interface
 */
export class PromotionApi extends BaseAPI {
    /** 
     * @param promotionID ID of the promotion.
     */
    _delete(params: {  promotionID: string; }) {
        return PromotionApiFp._delete(params)(this.fetch, this.basePath);
    }
    /** 
     * @param promo 
     */
    create(params: {  promo: Promotion; }) {
        return PromotionApiFp.create(params)(this.fetch, this.basePath);
    }
    /** 
     * @param promotionID ID of the promotion.
     * @param buyerID ID of the buyer.
     * @param userID ID of the user.
     * @param userGroupID ID of the user group.
     */
    deleteAssignment(params: {  promotionID: string; buyerID: string; userID?: string; userGroupID?: string; }) {
        return PromotionApiFp.deleteAssignment(params)(this.fetch, this.basePath);
    }
    /** 
     * @param promotionID ID of the promotion.
     */
    get(params: {  promotionID: string; }) {
        return PromotionApiFp.get(params)(this.fetch, this.basePath);
    }
    /** 
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    list(params: {  search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
        return PromotionApiFp.list(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param promotionID ID of the promotion.
     * @param userID ID of the user.
     * @param userGroupID ID of the user group.
     * @param level Level of the promotion.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listAssignments(params: {  buyerID: string; promotionID?: string; userID?: string; userGroupID?: string; level?: string; page?: number; pageSize?: number; }) {
        return PromotionApiFp.listAssignments(params)(this.fetch, this.basePath);
    }
    /** 
     * @param promotionID ID of the promotion.
     * @param partialPromotion 
     */
    patch(params: {  promotionID: string; partialPromotion: Promotion; }) {
        return PromotionApiFp.patch(params)(this.fetch, this.basePath);
    }
    /** 
     * @param assignment 
     */
    saveAssignment(params: {  assignment: PromotionAssignment; }) {
        return PromotionApiFp.saveAssignment(params)(this.fetch, this.basePath);
    }
    /** 
     * @param promotionID ID of the promotion.
     * @param promo 
     */
    update(params: {  promotionID: string; promo: Promotion; }) {
        return PromotionApiFp.update(params)(this.fetch, this.basePath);
    }
};

/**
 * PromotionApi - factory interface
 */
export const PromotionApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * @param promotionID ID of the promotion.
         */
        _delete(params: {  promotionID: string; }) {
            return PromotionApiFp._delete(params)(fetch, basePath);
        },
        /** 
         * @param promo 
         */
        create(params: {  promo: Promotion; }) {
            return PromotionApiFp.create(params)(fetch, basePath);
        },
        /** 
         * @param promotionID ID of the promotion.
         * @param buyerID ID of the buyer.
         * @param userID ID of the user.
         * @param userGroupID ID of the user group.
         */
        deleteAssignment(params: {  promotionID: string; buyerID: string; userID?: string; userGroupID?: string; }) {
            return PromotionApiFp.deleteAssignment(params)(fetch, basePath);
        },
        /** 
         * @param promotionID ID of the promotion.
         */
        get(params: {  promotionID: string; }) {
            return PromotionApiFp.get(params)(fetch, basePath);
        },
        /** 
         * @param search Word or phrase to search for.
         * @param searchOn Comma-delimited list of fields to search on.
         * @param sortBy Comma-delimited list of fields to sort by.
         * @param page Page of results to return. Default: 1
         * @param pageSize Number of results to return per page. Default: 20, max: 100.
         */
        list(params: {  search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
            return PromotionApiFp.list(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param promotionID ID of the promotion.
         * @param userID ID of the user.
         * @param userGroupID ID of the user group.
         * @param level Level of the promotion.
         * @param page Page of results to return. Default: 1
         * @param pageSize Number of results to return per page. Default: 20, max: 100.
         */
        listAssignments(params: {  buyerID: string; promotionID?: string; userID?: string; userGroupID?: string; level?: string; page?: number; pageSize?: number; }) {
            return PromotionApiFp.listAssignments(params)(fetch, basePath);
        },
        /** 
         * @param promotionID ID of the promotion.
         * @param partialPromotion 
         */
        patch(params: {  promotionID: string; partialPromotion: Promotion; }) {
            return PromotionApiFp.patch(params)(fetch, basePath);
        },
        /** 
         * @param assignment 
         */
        saveAssignment(params: {  assignment: PromotionAssignment; }) {
            return PromotionApiFp.saveAssignment(params)(fetch, basePath);
        },
        /** 
         * @param promotionID ID of the promotion.
         * @param promo 
         */
        update(params: {  promotionID: string; promo: Promotion; }) {
            return PromotionApiFp.update(params)(fetch, basePath);
        },
    }
};


/**
 * SecurityProfileApi - fetch parameter creator
 */
export const SecurityProfileApiFetchParamCreactor = {
    /** 
     * @param securityProfileID ID of the security profile.
     */
    get(params: {  securityProfileID: string; }): FetchArgs {
        // verify required parameter "securityProfileID" is set
        if (params["securityProfileID"] == null) {
            throw new Error("Missing required parameter securityProfileID when calling get");
        }
        const baseUrl = `/SecurityProfiles/{securityProfileID}`
            .replace(`{${"securityProfileID"}}`, `${ params.securityProfileID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    list(params: {  search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }): FetchArgs {
        const baseUrl = `/SecurityProfiles`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "search": params.search,
            "searchOn": params.searchOn,
            "sortBy": params.sortBy,
            "page": params.page,
            "pageSize": params.pageSize,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
}

/**
 * SecurityProfileApi - functional programming interface
 */
export const SecurityProfileApiFp = {
    /** 
     * @param securityProfileID ID of the security profile.
     */
    get(params: { securityProfileID: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SecurityProfileApiFetchParamCreactor.get(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    list(params: { search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SecurityProfileApiFetchParamCreactor.list(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * SecurityProfileApi - object-oriented interface
 */
export class SecurityProfileApi extends BaseAPI {
    /** 
     * @param securityProfileID ID of the security profile.
     */
    get(params: {  securityProfileID: string; }) {
        return SecurityProfileApiFp.get(params)(this.fetch, this.basePath);
    }
    /** 
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    list(params: {  search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
        return SecurityProfileApiFp.list(params)(this.fetch, this.basePath);
    }
};

/**
 * SecurityProfileApi - factory interface
 */
export const SecurityProfileApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * @param securityProfileID ID of the security profile.
         */
        get(params: {  securityProfileID: string; }) {
            return SecurityProfileApiFp.get(params)(fetch, basePath);
        },
        /** 
         * @param search Word or phrase to search for.
         * @param searchOn Comma-delimited list of fields to search on.
         * @param sortBy Comma-delimited list of fields to sort by.
         * @param page Page of results to return. Default: 1
         * @param pageSize Number of results to return per page. Default: 20, max: 100.
         */
        list(params: {  search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
            return SecurityProfileApiFp.list(params)(fetch, basePath);
        },
    }
};


/**
 * ShipmentApi - fetch parameter creator
 */
export const ShipmentApiFetchParamCreactor = {
    /** 
     * @param buyerID ID of the buyer.
     * @param shipmentID ID of the shipment.
     */
    _delete(params: {  buyerID: string; shipmentID: string; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling _delete");
        }
        // verify required parameter "shipmentID" is set
        if (params["shipmentID"] == null) {
            throw new Error("Missing required parameter shipmentID when calling _delete");
        }
        const baseUrl = `/buyers/{buyerID}/shipments/{shipmentID}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"shipmentID"}}`, `${ params.shipmentID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "DELETE" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param shipment 
     */
    create(params: {  buyerID: string; shipment: Shipment; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling create");
        }
        // verify required parameter "shipment" is set
        if (params["shipment"] == null) {
            throw new Error("Missing required parameter shipment when calling create");
        }
        const baseUrl = `/buyers/{buyerID}/shipments`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["shipment"]) {
            fetchOptions.body = JSON.stringify(params["shipment"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param shipmentID ID of the shipment.
     * @param orderID ID of the order.
     * @param lineItemID ID of the line item.
     */
    deleteItem(params: {  buyerID: string; shipmentID: string; orderID: string; lineItemID: string; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling deleteItem");
        }
        // verify required parameter "shipmentID" is set
        if (params["shipmentID"] == null) {
            throw new Error("Missing required parameter shipmentID when calling deleteItem");
        }
        // verify required parameter "orderID" is set
        if (params["orderID"] == null) {
            throw new Error("Missing required parameter orderID when calling deleteItem");
        }
        // verify required parameter "lineItemID" is set
        if (params["lineItemID"] == null) {
            throw new Error("Missing required parameter lineItemID when calling deleteItem");
        }
        const baseUrl = `/buyers/{buyerID}/shipments/{shipmentID}/items/{orderID}/{lineItemID}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"shipmentID"}}`, `${ params.shipmentID }`)
            .replace(`{${"orderID"}}`, `${ params.orderID }`)
            .replace(`{${"lineItemID"}}`, `${ params.lineItemID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "DELETE" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param shipmentID ID of the shipment.
     */
    get(params: {  buyerID: string; shipmentID: string; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling get");
        }
        // verify required parameter "shipmentID" is set
        if (params["shipmentID"] == null) {
            throw new Error("Missing required parameter shipmentID when calling get");
        }
        const baseUrl = `/buyers/{buyerID}/shipments/{shipmentID}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"shipmentID"}}`, `${ params.shipmentID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    list(params: {  buyerID: string; orderID?: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling list");
        }
        const baseUrl = `/buyers/{buyerID}/shipments`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "orderID": params.orderID,
            "search": params.search,
            "searchOn": params.searchOn,
            "sortBy": params.sortBy,
            "page": params.page,
            "pageSize": params.pageSize,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param shipmentID ID of the shipment.
     * @param shipment 
     */
    patch(params: {  buyerID: string; shipmentID: string; shipment: Shipment; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling patch");
        }
        // verify required parameter "shipmentID" is set
        if (params["shipmentID"] == null) {
            throw new Error("Missing required parameter shipmentID when calling patch");
        }
        // verify required parameter "shipment" is set
        if (params["shipment"] == null) {
            throw new Error("Missing required parameter shipment when calling patch");
        }
        const baseUrl = `/buyers/{buyerID}/shipments/{shipmentID}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"shipmentID"}}`, `${ params.shipmentID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PATCH" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["shipment"]) {
            fetchOptions.body = JSON.stringify(params["shipment"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param shipmentID ID of the shipment.
     * @param item 
     */
    saveItem(params: {  buyerID: string; shipmentID: string; item: ShipmentItem; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling saveItem");
        }
        // verify required parameter "shipmentID" is set
        if (params["shipmentID"] == null) {
            throw new Error("Missing required parameter shipmentID when calling saveItem");
        }
        // verify required parameter "item" is set
        if (params["item"] == null) {
            throw new Error("Missing required parameter item when calling saveItem");
        }
        const baseUrl = `/buyers/{buyerID}/shipments/{shipmentID}/items`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"shipmentID"}}`, `${ params.shipmentID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["item"]) {
            fetchOptions.body = JSON.stringify(params["item"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param shipmentID ID of the shipment.
     * @param shipment 
     */
    update(params: {  buyerID: string; shipmentID: string; shipment: Shipment; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling update");
        }
        // verify required parameter "shipmentID" is set
        if (params["shipmentID"] == null) {
            throw new Error("Missing required parameter shipmentID when calling update");
        }
        // verify required parameter "shipment" is set
        if (params["shipment"] == null) {
            throw new Error("Missing required parameter shipment when calling update");
        }
        const baseUrl = `/buyers/{buyerID}/shipments/{shipmentID}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"shipmentID"}}`, `${ params.shipmentID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PUT" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["shipment"]) {
            fetchOptions.body = JSON.stringify(params["shipment"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
}

/**
 * ShipmentApi - functional programming interface
 */
export const ShipmentApiFp = {
    /** 
     * @param buyerID ID of the buyer.
     * @param shipmentID ID of the shipment.
     */
    _delete(params: { buyerID: string; shipmentID: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ShipmentApiFetchParamCreactor._delete(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param shipment 
     */
    create(params: { buyerID: string; shipment: Shipment;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ShipmentApiFetchParamCreactor.create(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param shipmentID ID of the shipment.
     * @param orderID ID of the order.
     * @param lineItemID ID of the line item.
     */
    deleteItem(params: { buyerID: string; shipmentID: string; orderID: string; lineItemID: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ShipmentApiFetchParamCreactor.deleteItem(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param shipmentID ID of the shipment.
     */
    get(params: { buyerID: string; shipmentID: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ShipmentApiFetchParamCreactor.get(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    list(params: { buyerID: string; orderID?: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ShipmentApiFetchParamCreactor.list(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param shipmentID ID of the shipment.
     * @param shipment 
     */
    patch(params: { buyerID: string; shipmentID: string; shipment: Shipment;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ShipmentApiFetchParamCreactor.patch(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param shipmentID ID of the shipment.
     * @param item 
     */
    saveItem(params: { buyerID: string; shipmentID: string; item: ShipmentItem;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ShipmentApiFetchParamCreactor.saveItem(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param shipmentID ID of the shipment.
     * @param shipment 
     */
    update(params: { buyerID: string; shipmentID: string; shipment: Shipment;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ShipmentApiFetchParamCreactor.update(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * ShipmentApi - object-oriented interface
 */
export class ShipmentApi extends BaseAPI {
    /** 
     * @param buyerID ID of the buyer.
     * @param shipmentID ID of the shipment.
     */
    _delete(params: {  buyerID: string; shipmentID: string; }) {
        return ShipmentApiFp._delete(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param shipment 
     */
    create(params: {  buyerID: string; shipment: Shipment; }) {
        return ShipmentApiFp.create(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param shipmentID ID of the shipment.
     * @param orderID ID of the order.
     * @param lineItemID ID of the line item.
     */
    deleteItem(params: {  buyerID: string; shipmentID: string; orderID: string; lineItemID: string; }) {
        return ShipmentApiFp.deleteItem(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param shipmentID ID of the shipment.
     */
    get(params: {  buyerID: string; shipmentID: string; }) {
        return ShipmentApiFp.get(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    list(params: {  buyerID: string; orderID?: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
        return ShipmentApiFp.list(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param shipmentID ID of the shipment.
     * @param shipment 
     */
    patch(params: {  buyerID: string; shipmentID: string; shipment: Shipment; }) {
        return ShipmentApiFp.patch(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param shipmentID ID of the shipment.
     * @param item 
     */
    saveItem(params: {  buyerID: string; shipmentID: string; item: ShipmentItem; }) {
        return ShipmentApiFp.saveItem(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param shipmentID ID of the shipment.
     * @param shipment 
     */
    update(params: {  buyerID: string; shipmentID: string; shipment: Shipment; }) {
        return ShipmentApiFp.update(params)(this.fetch, this.basePath);
    }
};

/**
 * ShipmentApi - factory interface
 */
export const ShipmentApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * @param buyerID ID of the buyer.
         * @param shipmentID ID of the shipment.
         */
        _delete(params: {  buyerID: string; shipmentID: string; }) {
            return ShipmentApiFp._delete(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param shipment 
         */
        create(params: {  buyerID: string; shipment: Shipment; }) {
            return ShipmentApiFp.create(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param shipmentID ID of the shipment.
         * @param orderID ID of the order.
         * @param lineItemID ID of the line item.
         */
        deleteItem(params: {  buyerID: string; shipmentID: string; orderID: string; lineItemID: string; }) {
            return ShipmentApiFp.deleteItem(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param shipmentID ID of the shipment.
         */
        get(params: {  buyerID: string; shipmentID: string; }) {
            return ShipmentApiFp.get(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param orderID ID of the order.
         * @param search Word or phrase to search for.
         * @param searchOn Comma-delimited list of fields to search on.
         * @param sortBy Comma-delimited list of fields to sort by.
         * @param page Page of results to return. Default: 1
         * @param pageSize Number of results to return per page. Default: 20, max: 100.
         */
        list(params: {  buyerID: string; orderID?: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
            return ShipmentApiFp.list(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param shipmentID ID of the shipment.
         * @param shipment 
         */
        patch(params: {  buyerID: string; shipmentID: string; shipment: Shipment; }) {
            return ShipmentApiFp.patch(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param shipmentID ID of the shipment.
         * @param item 
         */
        saveItem(params: {  buyerID: string; shipmentID: string; item: ShipmentItem; }) {
            return ShipmentApiFp.saveItem(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param shipmentID ID of the shipment.
         * @param shipment 
         */
        update(params: {  buyerID: string; shipmentID: string; shipment: Shipment; }) {
            return ShipmentApiFp.update(params)(fetch, basePath);
        },
    }
};


/**
 * SpecApi - fetch parameter creator
 */
export const SpecApiFetchParamCreactor = {
    /** 
     * @param specID ID of the spec.
     */
    _delete(params: {  specID: string; }): FetchArgs {
        // verify required parameter "specID" is set
        if (params["specID"] == null) {
            throw new Error("Missing required parameter specID when calling _delete");
        }
        const baseUrl = `/specs/{specID}`
            .replace(`{${"specID"}}`, `${ params.specID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "DELETE" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param spec 
     */
    create(params: {  spec: Spec; }): FetchArgs {
        // verify required parameter "spec" is set
        if (params["spec"] == null) {
            throw new Error("Missing required parameter spec when calling create");
        }
        const baseUrl = `/specs`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["spec"]) {
            fetchOptions.body = JSON.stringify(params["spec"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param specID ID of the spec.
     * @param option 
     */
    createOption(params: {  specID: string; option: SpecOption; }): FetchArgs {
        // verify required parameter "specID" is set
        if (params["specID"] == null) {
            throw new Error("Missing required parameter specID when calling createOption");
        }
        // verify required parameter "option" is set
        if (params["option"] == null) {
            throw new Error("Missing required parameter option when calling createOption");
        }
        const baseUrl = `/specs/{specID}/options`
            .replace(`{${"specID"}}`, `${ params.specID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["option"]) {
            fetchOptions.body = JSON.stringify(params["option"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param specID ID of the spec.
     * @param optionID ID of the option.
     */
    deleteOption(params: {  specID: string; optionID: string; }): FetchArgs {
        // verify required parameter "specID" is set
        if (params["specID"] == null) {
            throw new Error("Missing required parameter specID when calling deleteOption");
        }
        // verify required parameter "optionID" is set
        if (params["optionID"] == null) {
            throw new Error("Missing required parameter optionID when calling deleteOption");
        }
        const baseUrl = `/specs/{specID}/options/{optionID}`
            .replace(`{${"specID"}}`, `${ params.specID }`)
            .replace(`{${"optionID"}}`, `${ params.optionID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "DELETE" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param specID ID of the spec.
     * @param productID ID of the product.
     */
    deleteProductAssignment(params: {  specID: string; productID: string; }): FetchArgs {
        // verify required parameter "specID" is set
        if (params["specID"] == null) {
            throw new Error("Missing required parameter specID when calling deleteProductAssignment");
        }
        // verify required parameter "productID" is set
        if (params["productID"] == null) {
            throw new Error("Missing required parameter productID when calling deleteProductAssignment");
        }
        const baseUrl = `/specs/{specID}/productassignments/{productID}`
            .replace(`{${"specID"}}`, `${ params.specID }`)
            .replace(`{${"productID"}}`, `${ params.productID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "DELETE" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param specID ID of the spec.
     */
    get(params: {  specID: string; }): FetchArgs {
        // verify required parameter "specID" is set
        if (params["specID"] == null) {
            throw new Error("Missing required parameter specID when calling get");
        }
        const baseUrl = `/specs/{specID}`
            .replace(`{${"specID"}}`, `${ params.specID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param specID ID of the spec.
     * @param optionID ID of the option.
     */
    getOption(params: {  specID: string; optionID: string; }): FetchArgs {
        // verify required parameter "specID" is set
        if (params["specID"] == null) {
            throw new Error("Missing required parameter specID when calling getOption");
        }
        // verify required parameter "optionID" is set
        if (params["optionID"] == null) {
            throw new Error("Missing required parameter optionID when calling getOption");
        }
        const baseUrl = `/specs/{specID}/options/{optionID}`
            .replace(`{${"specID"}}`, `${ params.specID }`)
            .replace(`{${"optionID"}}`, `${ params.optionID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    list(params: {  search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }): FetchArgs {
        const baseUrl = `/specs`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "search": params.search,
            "searchOn": params.searchOn,
            "sortBy": params.sortBy,
            "page": params.page,
            "pageSize": params.pageSize,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param specID ID of the spec.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listOptions(params: {  specID: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }): FetchArgs {
        // verify required parameter "specID" is set
        if (params["specID"] == null) {
            throw new Error("Missing required parameter specID when calling listOptions");
        }
        const baseUrl = `/specs/{specID}/options`
            .replace(`{${"specID"}}`, `${ params.specID }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "search": params.search,
            "searchOn": params.searchOn,
            "sortBy": params.sortBy,
            "page": params.page,
            "pageSize": params.pageSize,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param specID ID of the spec.
     * @param productID ID of the product.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listProductAssignments(params: {  specID?: string; productID?: string; page?: number; pageSize?: number; }): FetchArgs {
        const baseUrl = `/specs/productassignments`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "specID": params.specID,
            "productID": params.productID,
            "page": params.page,
            "pageSize": params.pageSize,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param specID ID of the spec.
     * @param spec 
     */
    patch(params: {  specID: string; spec: Spec; }): FetchArgs {
        // verify required parameter "specID" is set
        if (params["specID"] == null) {
            throw new Error("Missing required parameter specID when calling patch");
        }
        // verify required parameter "spec" is set
        if (params["spec"] == null) {
            throw new Error("Missing required parameter spec when calling patch");
        }
        const baseUrl = `/specs/{specID}`
            .replace(`{${"specID"}}`, `${ params.specID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PATCH" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["spec"]) {
            fetchOptions.body = JSON.stringify(params["spec"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param specID ID of the spec.
     * @param optionID ID of the option.
     * @param option 
     */
    patchOption(params: {  specID: string; optionID: string; option: SpecOption; }): FetchArgs {
        // verify required parameter "specID" is set
        if (params["specID"] == null) {
            throw new Error("Missing required parameter specID when calling patchOption");
        }
        // verify required parameter "optionID" is set
        if (params["optionID"] == null) {
            throw new Error("Missing required parameter optionID when calling patchOption");
        }
        // verify required parameter "option" is set
        if (params["option"] == null) {
            throw new Error("Missing required parameter option when calling patchOption");
        }
        const baseUrl = `/specs/{specID}/options/{optionID}`
            .replace(`{${"specID"}}`, `${ params.specID }`)
            .replace(`{${"optionID"}}`, `${ params.optionID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PATCH" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["option"]) {
            fetchOptions.body = JSON.stringify(params["option"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param productAssignment 
     */
    saveProductAssignment(params: {  productAssignment: SpecProductAssignment; }): FetchArgs {
        // verify required parameter "productAssignment" is set
        if (params["productAssignment"] == null) {
            throw new Error("Missing required parameter productAssignment when calling saveProductAssignment");
        }
        const baseUrl = `/specs/productassignments`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["productAssignment"]) {
            fetchOptions.body = JSON.stringify(params["productAssignment"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param specID ID of the spec.
     * @param spec 
     */
    update(params: {  specID: string; spec: Spec; }): FetchArgs {
        // verify required parameter "specID" is set
        if (params["specID"] == null) {
            throw new Error("Missing required parameter specID when calling update");
        }
        // verify required parameter "spec" is set
        if (params["spec"] == null) {
            throw new Error("Missing required parameter spec when calling update");
        }
        const baseUrl = `/specs/{specID}`
            .replace(`{${"specID"}}`, `${ params.specID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PUT" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["spec"]) {
            fetchOptions.body = JSON.stringify(params["spec"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param specID ID of the spec.
     * @param optionID ID of the option.
     * @param option 
     */
    updateOption(params: {  specID: string; optionID: string; option: SpecOption; }): FetchArgs {
        // verify required parameter "specID" is set
        if (params["specID"] == null) {
            throw new Error("Missing required parameter specID when calling updateOption");
        }
        // verify required parameter "optionID" is set
        if (params["optionID"] == null) {
            throw new Error("Missing required parameter optionID when calling updateOption");
        }
        // verify required parameter "option" is set
        if (params["option"] == null) {
            throw new Error("Missing required parameter option when calling updateOption");
        }
        const baseUrl = `/specs/{specID}/options/{optionID}`
            .replace(`{${"specID"}}`, `${ params.specID }`)
            .replace(`{${"optionID"}}`, `${ params.optionID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PUT" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["option"]) {
            fetchOptions.body = JSON.stringify(params["option"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
}

/**
 * SpecApi - functional programming interface
 */
export const SpecApiFp = {
    /** 
     * @param specID ID of the spec.
     */
    _delete(params: { specID: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SpecApiFetchParamCreactor._delete(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param spec 
     */
    create(params: { spec: Spec;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SpecApiFetchParamCreactor.create(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param specID ID of the spec.
     * @param option 
     */
    createOption(params: { specID: string; option: SpecOption;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SpecApiFetchParamCreactor.createOption(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param specID ID of the spec.
     * @param optionID ID of the option.
     */
    deleteOption(params: { specID: string; optionID: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SpecApiFetchParamCreactor.deleteOption(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param specID ID of the spec.
     * @param productID ID of the product.
     */
    deleteProductAssignment(params: { specID: string; productID: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SpecApiFetchParamCreactor.deleteProductAssignment(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param specID ID of the spec.
     */
    get(params: { specID: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SpecApiFetchParamCreactor.get(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param specID ID of the spec.
     * @param optionID ID of the option.
     */
    getOption(params: { specID: string; optionID: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SpecApiFetchParamCreactor.getOption(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    list(params: { search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SpecApiFetchParamCreactor.list(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param specID ID of the spec.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listOptions(params: { specID: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SpecApiFetchParamCreactor.listOptions(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param specID ID of the spec.
     * @param productID ID of the product.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listProductAssignments(params: { specID?: string; productID?: string; page?: number; pageSize?: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SpecApiFetchParamCreactor.listProductAssignments(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param specID ID of the spec.
     * @param spec 
     */
    patch(params: { specID: string; spec: Spec;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SpecApiFetchParamCreactor.patch(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param specID ID of the spec.
     * @param optionID ID of the option.
     * @param option 
     */
    patchOption(params: { specID: string; optionID: string; option: SpecOption;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SpecApiFetchParamCreactor.patchOption(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param productAssignment 
     */
    saveProductAssignment(params: { productAssignment: SpecProductAssignment;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SpecApiFetchParamCreactor.saveProductAssignment(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param specID ID of the spec.
     * @param spec 
     */
    update(params: { specID: string; spec: Spec;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SpecApiFetchParamCreactor.update(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param specID ID of the spec.
     * @param optionID ID of the option.
     * @param option 
     */
    updateOption(params: { specID: string; optionID: string; option: SpecOption;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SpecApiFetchParamCreactor.updateOption(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * SpecApi - object-oriented interface
 */
export class SpecApi extends BaseAPI {
    /** 
     * @param specID ID of the spec.
     */
    _delete(params: {  specID: string; }) {
        return SpecApiFp._delete(params)(this.fetch, this.basePath);
    }
    /** 
     * @param spec 
     */
    create(params: {  spec: Spec; }) {
        return SpecApiFp.create(params)(this.fetch, this.basePath);
    }
    /** 
     * @param specID ID of the spec.
     * @param option 
     */
    createOption(params: {  specID: string; option: SpecOption; }) {
        return SpecApiFp.createOption(params)(this.fetch, this.basePath);
    }
    /** 
     * @param specID ID of the spec.
     * @param optionID ID of the option.
     */
    deleteOption(params: {  specID: string; optionID: string; }) {
        return SpecApiFp.deleteOption(params)(this.fetch, this.basePath);
    }
    /** 
     * @param specID ID of the spec.
     * @param productID ID of the product.
     */
    deleteProductAssignment(params: {  specID: string; productID: string; }) {
        return SpecApiFp.deleteProductAssignment(params)(this.fetch, this.basePath);
    }
    /** 
     * @param specID ID of the spec.
     */
    get(params: {  specID: string; }) {
        return SpecApiFp.get(params)(this.fetch, this.basePath);
    }
    /** 
     * @param specID ID of the spec.
     * @param optionID ID of the option.
     */
    getOption(params: {  specID: string; optionID: string; }) {
        return SpecApiFp.getOption(params)(this.fetch, this.basePath);
    }
    /** 
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    list(params: {  search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
        return SpecApiFp.list(params)(this.fetch, this.basePath);
    }
    /** 
     * @param specID ID of the spec.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listOptions(params: {  specID: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
        return SpecApiFp.listOptions(params)(this.fetch, this.basePath);
    }
    /** 
     * @param specID ID of the spec.
     * @param productID ID of the product.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listProductAssignments(params: {  specID?: string; productID?: string; page?: number; pageSize?: number; }) {
        return SpecApiFp.listProductAssignments(params)(this.fetch, this.basePath);
    }
    /** 
     * @param specID ID of the spec.
     * @param spec 
     */
    patch(params: {  specID: string; spec: Spec; }) {
        return SpecApiFp.patch(params)(this.fetch, this.basePath);
    }
    /** 
     * @param specID ID of the spec.
     * @param optionID ID of the option.
     * @param option 
     */
    patchOption(params: {  specID: string; optionID: string; option: SpecOption; }) {
        return SpecApiFp.patchOption(params)(this.fetch, this.basePath);
    }
    /** 
     * @param productAssignment 
     */
    saveProductAssignment(params: {  productAssignment: SpecProductAssignment; }) {
        return SpecApiFp.saveProductAssignment(params)(this.fetch, this.basePath);
    }
    /** 
     * @param specID ID of the spec.
     * @param spec 
     */
    update(params: {  specID: string; spec: Spec; }) {
        return SpecApiFp.update(params)(this.fetch, this.basePath);
    }
    /** 
     * @param specID ID of the spec.
     * @param optionID ID of the option.
     * @param option 
     */
    updateOption(params: {  specID: string; optionID: string; option: SpecOption; }) {
        return SpecApiFp.updateOption(params)(this.fetch, this.basePath);
    }
};

/**
 * SpecApi - factory interface
 */
export const SpecApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * @param specID ID of the spec.
         */
        _delete(params: {  specID: string; }) {
            return SpecApiFp._delete(params)(fetch, basePath);
        },
        /** 
         * @param spec 
         */
        create(params: {  spec: Spec; }) {
            return SpecApiFp.create(params)(fetch, basePath);
        },
        /** 
         * @param specID ID of the spec.
         * @param option 
         */
        createOption(params: {  specID: string; option: SpecOption; }) {
            return SpecApiFp.createOption(params)(fetch, basePath);
        },
        /** 
         * @param specID ID of the spec.
         * @param optionID ID of the option.
         */
        deleteOption(params: {  specID: string; optionID: string; }) {
            return SpecApiFp.deleteOption(params)(fetch, basePath);
        },
        /** 
         * @param specID ID of the spec.
         * @param productID ID of the product.
         */
        deleteProductAssignment(params: {  specID: string; productID: string; }) {
            return SpecApiFp.deleteProductAssignment(params)(fetch, basePath);
        },
        /** 
         * @param specID ID of the spec.
         */
        get(params: {  specID: string; }) {
            return SpecApiFp.get(params)(fetch, basePath);
        },
        /** 
         * @param specID ID of the spec.
         * @param optionID ID of the option.
         */
        getOption(params: {  specID: string; optionID: string; }) {
            return SpecApiFp.getOption(params)(fetch, basePath);
        },
        /** 
         * @param search Word or phrase to search for.
         * @param searchOn Comma-delimited list of fields to search on.
         * @param sortBy Comma-delimited list of fields to sort by.
         * @param page Page of results to return. Default: 1
         * @param pageSize Number of results to return per page. Default: 20, max: 100.
         */
        list(params: {  search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
            return SpecApiFp.list(params)(fetch, basePath);
        },
        /** 
         * @param specID ID of the spec.
         * @param search Word or phrase to search for.
         * @param searchOn Comma-delimited list of fields to search on.
         * @param sortBy Comma-delimited list of fields to sort by.
         * @param page Page of results to return. Default: 1
         * @param pageSize Number of results to return per page. Default: 20, max: 100.
         */
        listOptions(params: {  specID: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
            return SpecApiFp.listOptions(params)(fetch, basePath);
        },
        /** 
         * @param specID ID of the spec.
         * @param productID ID of the product.
         * @param page Page of results to return. Default: 1
         * @param pageSize Number of results to return per page. Default: 20, max: 100.
         */
        listProductAssignments(params: {  specID?: string; productID?: string; page?: number; pageSize?: number; }) {
            return SpecApiFp.listProductAssignments(params)(fetch, basePath);
        },
        /** 
         * @param specID ID of the spec.
         * @param spec 
         */
        patch(params: {  specID: string; spec: Spec; }) {
            return SpecApiFp.patch(params)(fetch, basePath);
        },
        /** 
         * @param specID ID of the spec.
         * @param optionID ID of the option.
         * @param option 
         */
        patchOption(params: {  specID: string; optionID: string; option: SpecOption; }) {
            return SpecApiFp.patchOption(params)(fetch, basePath);
        },
        /** 
         * @param productAssignment 
         */
        saveProductAssignment(params: {  productAssignment: SpecProductAssignment; }) {
            return SpecApiFp.saveProductAssignment(params)(fetch, basePath);
        },
        /** 
         * @param specID ID of the spec.
         * @param spec 
         */
        update(params: {  specID: string; spec: Spec; }) {
            return SpecApiFp.update(params)(fetch, basePath);
        },
        /** 
         * @param specID ID of the spec.
         * @param optionID ID of the option.
         * @param option 
         */
        updateOption(params: {  specID: string; optionID: string; option: SpecOption; }) {
            return SpecApiFp.updateOption(params)(fetch, basePath);
        },
    }
};


/**
 * SpendingAccountApi - fetch parameter creator
 */
export const SpendingAccountApiFetchParamCreactor = {
    /** 
     * @param buyerID ID of the buyer.
     * @param spendingAccountID ID of the spending account.
     */
    _delete(params: {  buyerID: string; spendingAccountID: string; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling _delete");
        }
        // verify required parameter "spendingAccountID" is set
        if (params["spendingAccountID"] == null) {
            throw new Error("Missing required parameter spendingAccountID when calling _delete");
        }
        const baseUrl = `/buyers/{buyerID}/spendingaccounts/{spendingAccountID}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"spendingAccountID"}}`, `${ params.spendingAccountID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "DELETE" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param spendingAccount 
     */
    create(params: {  buyerID: string; spendingAccount: SpendingAccount; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling create");
        }
        // verify required parameter "spendingAccount" is set
        if (params["spendingAccount"] == null) {
            throw new Error("Missing required parameter spendingAccount when calling create");
        }
        const baseUrl = `/buyers/{buyerID}/spendingaccounts`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["spendingAccount"]) {
            fetchOptions.body = JSON.stringify(params["spendingAccount"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param spendingAccountID ID of the spending account.
     * @param userID ID of the user.
     * @param userGroupID ID of the user group.
     */
    deleteAssignment(params: {  buyerID: string; spendingAccountID: string; userID?: string; userGroupID?: string; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling deleteAssignment");
        }
        // verify required parameter "spendingAccountID" is set
        if (params["spendingAccountID"] == null) {
            throw new Error("Missing required parameter spendingAccountID when calling deleteAssignment");
        }
        const baseUrl = `/buyers/{buyerID}/spendingaccounts/{spendingAccountID}/assignments`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"spendingAccountID"}}`, `${ params.spendingAccountID }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "userID": params.userID,
            "userGroupID": params.userGroupID,
        });
        let fetchOptions: RequestInit = { method: "DELETE" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param spendingAccountID ID of the spending account.
     */
    get(params: {  buyerID: string; spendingAccountID: string; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling get");
        }
        // verify required parameter "spendingAccountID" is set
        if (params["spendingAccountID"] == null) {
            throw new Error("Missing required parameter spendingAccountID when calling get");
        }
        const baseUrl = `/buyers/{buyerID}/spendingaccounts/{spendingAccountID}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"spendingAccountID"}}`, `${ params.spendingAccountID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    list(params: {  buyerID: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling list");
        }
        const baseUrl = `/buyers/{buyerID}/spendingaccounts`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "search": params.search,
            "searchOn": params.searchOn,
            "sortBy": params.sortBy,
            "page": params.page,
            "pageSize": params.pageSize,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param spendingAccountID ID of the spending account.
     * @param userID ID of the user.
     * @param userGroupID ID of the user group.
     * @param level Level of the spending account.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listAssignments(params: {  buyerID: string; spendingAccountID?: string; userID?: string; userGroupID?: string; level?: string; page?: number; pageSize?: number; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling listAssignments");
        }
        const baseUrl = `/buyers/{buyerID}/spendingaccounts/assignments`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "spendingAccountID": params.spendingAccountID,
            "userID": params.userID,
            "userGroupID": params.userGroupID,
            "level": params.level,
            "page": params.page,
            "pageSize": params.pageSize,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param spendingAccountID ID of the spending account.
     * @param spendingAccount 
     */
    patch(params: {  buyerID: string; spendingAccountID: string; spendingAccount: SpendingAccount; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling patch");
        }
        // verify required parameter "spendingAccountID" is set
        if (params["spendingAccountID"] == null) {
            throw new Error("Missing required parameter spendingAccountID when calling patch");
        }
        // verify required parameter "spendingAccount" is set
        if (params["spendingAccount"] == null) {
            throw new Error("Missing required parameter spendingAccount when calling patch");
        }
        const baseUrl = `/buyers/{buyerID}/spendingaccounts/{spendingAccountID}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"spendingAccountID"}}`, `${ params.spendingAccountID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PATCH" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["spendingAccount"]) {
            fetchOptions.body = JSON.stringify(params["spendingAccount"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param assignment 
     */
    saveAssignment(params: {  buyerID: string; assignment: SpendingAccountAssignment; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling saveAssignment");
        }
        // verify required parameter "assignment" is set
        if (params["assignment"] == null) {
            throw new Error("Missing required parameter assignment when calling saveAssignment");
        }
        const baseUrl = `/buyers/{buyerID}/spendingaccounts/assignments`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["assignment"]) {
            fetchOptions.body = JSON.stringify(params["assignment"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param spendingAccountID ID of the spending account.
     * @param spendingAccount 
     */
    update(params: {  buyerID: string; spendingAccountID: string; spendingAccount: SpendingAccount; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling update");
        }
        // verify required parameter "spendingAccountID" is set
        if (params["spendingAccountID"] == null) {
            throw new Error("Missing required parameter spendingAccountID when calling update");
        }
        // verify required parameter "spendingAccount" is set
        if (params["spendingAccount"] == null) {
            throw new Error("Missing required parameter spendingAccount when calling update");
        }
        const baseUrl = `/buyers/{buyerID}/spendingaccounts/{spendingAccountID}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"spendingAccountID"}}`, `${ params.spendingAccountID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PUT" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["spendingAccount"]) {
            fetchOptions.body = JSON.stringify(params["spendingAccount"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
}

/**
 * SpendingAccountApi - functional programming interface
 */
export const SpendingAccountApiFp = {
    /** 
     * @param buyerID ID of the buyer.
     * @param spendingAccountID ID of the spending account.
     */
    _delete(params: { buyerID: string; spendingAccountID: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SpendingAccountApiFetchParamCreactor._delete(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param spendingAccount 
     */
    create(params: { buyerID: string; spendingAccount: SpendingAccount;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SpendingAccountApiFetchParamCreactor.create(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param spendingAccountID ID of the spending account.
     * @param userID ID of the user.
     * @param userGroupID ID of the user group.
     */
    deleteAssignment(params: { buyerID: string; spendingAccountID: string; userID?: string; userGroupID?: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SpendingAccountApiFetchParamCreactor.deleteAssignment(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param spendingAccountID ID of the spending account.
     */
    get(params: { buyerID: string; spendingAccountID: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SpendingAccountApiFetchParamCreactor.get(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    list(params: { buyerID: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SpendingAccountApiFetchParamCreactor.list(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param spendingAccountID ID of the spending account.
     * @param userID ID of the user.
     * @param userGroupID ID of the user group.
     * @param level Level of the spending account.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listAssignments(params: { buyerID: string; spendingAccountID?: string; userID?: string; userGroupID?: string; level?: string; page?: number; pageSize?: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SpendingAccountApiFetchParamCreactor.listAssignments(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param spendingAccountID ID of the spending account.
     * @param spendingAccount 
     */
    patch(params: { buyerID: string; spendingAccountID: string; spendingAccount: SpendingAccount;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SpendingAccountApiFetchParamCreactor.patch(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param assignment 
     */
    saveAssignment(params: { buyerID: string; assignment: SpendingAccountAssignment;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SpendingAccountApiFetchParamCreactor.saveAssignment(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param spendingAccountID ID of the spending account.
     * @param spendingAccount 
     */
    update(params: { buyerID: string; spendingAccountID: string; spendingAccount: SpendingAccount;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SpendingAccountApiFetchParamCreactor.update(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * SpendingAccountApi - object-oriented interface
 */
export class SpendingAccountApi extends BaseAPI {
    /** 
     * @param buyerID ID of the buyer.
     * @param spendingAccountID ID of the spending account.
     */
    _delete(params: {  buyerID: string; spendingAccountID: string; }) {
        return SpendingAccountApiFp._delete(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param spendingAccount 
     */
    create(params: {  buyerID: string; spendingAccount: SpendingAccount; }) {
        return SpendingAccountApiFp.create(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param spendingAccountID ID of the spending account.
     * @param userID ID of the user.
     * @param userGroupID ID of the user group.
     */
    deleteAssignment(params: {  buyerID: string; spendingAccountID: string; userID?: string; userGroupID?: string; }) {
        return SpendingAccountApiFp.deleteAssignment(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param spendingAccountID ID of the spending account.
     */
    get(params: {  buyerID: string; spendingAccountID: string; }) {
        return SpendingAccountApiFp.get(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    list(params: {  buyerID: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
        return SpendingAccountApiFp.list(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param spendingAccountID ID of the spending account.
     * @param userID ID of the user.
     * @param userGroupID ID of the user group.
     * @param level Level of the spending account.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listAssignments(params: {  buyerID: string; spendingAccountID?: string; userID?: string; userGroupID?: string; level?: string; page?: number; pageSize?: number; }) {
        return SpendingAccountApiFp.listAssignments(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param spendingAccountID ID of the spending account.
     * @param spendingAccount 
     */
    patch(params: {  buyerID: string; spendingAccountID: string; spendingAccount: SpendingAccount; }) {
        return SpendingAccountApiFp.patch(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param assignment 
     */
    saveAssignment(params: {  buyerID: string; assignment: SpendingAccountAssignment; }) {
        return SpendingAccountApiFp.saveAssignment(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param spendingAccountID ID of the spending account.
     * @param spendingAccount 
     */
    update(params: {  buyerID: string; spendingAccountID: string; spendingAccount: SpendingAccount; }) {
        return SpendingAccountApiFp.update(params)(this.fetch, this.basePath);
    }
};

/**
 * SpendingAccountApi - factory interface
 */
export const SpendingAccountApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * @param buyerID ID of the buyer.
         * @param spendingAccountID ID of the spending account.
         */
        _delete(params: {  buyerID: string; spendingAccountID: string; }) {
            return SpendingAccountApiFp._delete(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param spendingAccount 
         */
        create(params: {  buyerID: string; spendingAccount: SpendingAccount; }) {
            return SpendingAccountApiFp.create(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param spendingAccountID ID of the spending account.
         * @param userID ID of the user.
         * @param userGroupID ID of the user group.
         */
        deleteAssignment(params: {  buyerID: string; spendingAccountID: string; userID?: string; userGroupID?: string; }) {
            return SpendingAccountApiFp.deleteAssignment(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param spendingAccountID ID of the spending account.
         */
        get(params: {  buyerID: string; spendingAccountID: string; }) {
            return SpendingAccountApiFp.get(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param search Word or phrase to search for.
         * @param searchOn Comma-delimited list of fields to search on.
         * @param sortBy Comma-delimited list of fields to sort by.
         * @param page Page of results to return. Default: 1
         * @param pageSize Number of results to return per page. Default: 20, max: 100.
         */
        list(params: {  buyerID: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
            return SpendingAccountApiFp.list(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param spendingAccountID ID of the spending account.
         * @param userID ID of the user.
         * @param userGroupID ID of the user group.
         * @param level Level of the spending account.
         * @param page Page of results to return. Default: 1
         * @param pageSize Number of results to return per page. Default: 20, max: 100.
         */
        listAssignments(params: {  buyerID: string; spendingAccountID?: string; userID?: string; userGroupID?: string; level?: string; page?: number; pageSize?: number; }) {
            return SpendingAccountApiFp.listAssignments(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param spendingAccountID ID of the spending account.
         * @param spendingAccount 
         */
        patch(params: {  buyerID: string; spendingAccountID: string; spendingAccount: SpendingAccount; }) {
            return SpendingAccountApiFp.patch(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param assignment 
         */
        saveAssignment(params: {  buyerID: string; assignment: SpendingAccountAssignment; }) {
            return SpendingAccountApiFp.saveAssignment(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param spendingAccountID ID of the spending account.
         * @param spendingAccount 
         */
        update(params: {  buyerID: string; spendingAccountID: string; spendingAccount: SpendingAccount; }) {
            return SpendingAccountApiFp.update(params)(fetch, basePath);
        },
    }
};


/**
 * UserApi - fetch parameter creator
 */
export const UserApiFetchParamCreactor = {
    /** 
     * @param buyerID ID of the buyer.
     * @param userID ID of the user.
     */
    _delete(params: {  buyerID: string; userID: string; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling _delete");
        }
        // verify required parameter "userID" is set
        if (params["userID"] == null) {
            throw new Error("Missing required parameter userID when calling _delete");
        }
        const baseUrl = `/buyers/{buyerID}/users/{userID}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"userID"}}`, `${ params.userID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "DELETE" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param user 
     */
    create(params: {  buyerID: string; user: User; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling create");
        }
        // verify required parameter "user" is set
        if (params["user"] == null) {
            throw new Error("Missing required parameter user when calling create");
        }
        const baseUrl = `/buyers/{buyerID}/users`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["user"]) {
            fetchOptions.body = JSON.stringify(params["user"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param userID ID of the user.
     */
    get(params: {  buyerID: string; userID: string; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling get");
        }
        // verify required parameter "userID" is set
        if (params["userID"] == null) {
            throw new Error("Missing required parameter userID when calling get");
        }
        const baseUrl = `/buyers/{buyerID}/users/{userID}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"userID"}}`, `${ params.userID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param userID ID of the user.
     * @param tokenRequest 
     */
    getAccessToken(params: {  buyerID: string; userID: string; tokenRequest: ImpersonateTokenRequest; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling getAccessToken");
        }
        // verify required parameter "userID" is set
        if (params["userID"] == null) {
            throw new Error("Missing required parameter userID when calling getAccessToken");
        }
        // verify required parameter "tokenRequest" is set
        if (params["tokenRequest"] == null) {
            throw new Error("Missing required parameter tokenRequest when calling getAccessToken");
        }
        const baseUrl = `/buyers/{buyerID}/users/{userID}/accesstoken`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"userID"}}`, `${ params.userID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["tokenRequest"]) {
            fetchOptions.body = JSON.stringify(params["tokenRequest"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param userGroupID ID of the user group.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    list(params: {  buyerID: string; userGroupID?: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling list");
        }
        const baseUrl = `/buyers/{buyerID}/users`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "userGroupID": params.userGroupID,
            "search": params.search,
            "searchOn": params.searchOn,
            "sortBy": params.sortBy,
            "page": params.page,
            "pageSize": params.pageSize,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param userID ID of the user.
     * @param user 
     */
    patch(params: {  buyerID: string; userID: string; user: User; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling patch");
        }
        // verify required parameter "userID" is set
        if (params["userID"] == null) {
            throw new Error("Missing required parameter userID when calling patch");
        }
        // verify required parameter "user" is set
        if (params["user"] == null) {
            throw new Error("Missing required parameter user when calling patch");
        }
        const baseUrl = `/buyers/{buyerID}/users/{userID}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"userID"}}`, `${ params.userID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PATCH" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["user"]) {
            fetchOptions.body = JSON.stringify(params["user"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param userID ID of the user.
     * @param user 
     */
    update(params: {  buyerID: string; userID: string; user: User; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling update");
        }
        // verify required parameter "userID" is set
        if (params["userID"] == null) {
            throw new Error("Missing required parameter userID when calling update");
        }
        // verify required parameter "user" is set
        if (params["user"] == null) {
            throw new Error("Missing required parameter user when calling update");
        }
        const baseUrl = `/buyers/{buyerID}/users/{userID}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"userID"}}`, `${ params.userID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PUT" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["user"]) {
            fetchOptions.body = JSON.stringify(params["user"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
}

/**
 * UserApi - functional programming interface
 */
export const UserApiFp = {
    /** 
     * @param buyerID ID of the buyer.
     * @param userID ID of the user.
     */
    _delete(params: { buyerID: string; userID: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserApiFetchParamCreactor._delete(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param user 
     */
    create(params: { buyerID: string; user: User;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserApiFetchParamCreactor.create(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param userID ID of the user.
     */
    get(params: { buyerID: string; userID: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserApiFetchParamCreactor.get(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param userID ID of the user.
     * @param tokenRequest 
     */
    getAccessToken(params: { buyerID: string; userID: string; tokenRequest: ImpersonateTokenRequest;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserApiFetchParamCreactor.getAccessToken(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param userGroupID ID of the user group.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    list(params: { buyerID: string; userGroupID?: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserApiFetchParamCreactor.list(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param userID ID of the user.
     * @param user 
     */
    patch(params: { buyerID: string; userID: string; user: User;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserApiFetchParamCreactor.patch(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param userID ID of the user.
     * @param user 
     */
    update(params: { buyerID: string; userID: string; user: User;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserApiFetchParamCreactor.update(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * UserApi - object-oriented interface
 */
export class UserApi extends BaseAPI {
    /** 
     * @param buyerID ID of the buyer.
     * @param userID ID of the user.
     */
    _delete(params: {  buyerID: string; userID: string; }) {
        return UserApiFp._delete(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param user 
     */
    create(params: {  buyerID: string; user: User; }) {
        return UserApiFp.create(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param userID ID of the user.
     */
    get(params: {  buyerID: string; userID: string; }) {
        return UserApiFp.get(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param userID ID of the user.
     * @param tokenRequest 
     */
    getAccessToken(params: {  buyerID: string; userID: string; tokenRequest: ImpersonateTokenRequest; }) {
        return UserApiFp.getAccessToken(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param userGroupID ID of the user group.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    list(params: {  buyerID: string; userGroupID?: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
        return UserApiFp.list(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param userID ID of the user.
     * @param user 
     */
    patch(params: {  buyerID: string; userID: string; user: User; }) {
        return UserApiFp.patch(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param userID ID of the user.
     * @param user 
     */
    update(params: {  buyerID: string; userID: string; user: User; }) {
        return UserApiFp.update(params)(this.fetch, this.basePath);
    }
};

/**
 * UserApi - factory interface
 */
export const UserApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * @param buyerID ID of the buyer.
         * @param userID ID of the user.
         */
        _delete(params: {  buyerID: string; userID: string; }) {
            return UserApiFp._delete(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param user 
         */
        create(params: {  buyerID: string; user: User; }) {
            return UserApiFp.create(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param userID ID of the user.
         */
        get(params: {  buyerID: string; userID: string; }) {
            return UserApiFp.get(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param userID ID of the user.
         * @param tokenRequest 
         */
        getAccessToken(params: {  buyerID: string; userID: string; tokenRequest: ImpersonateTokenRequest; }) {
            return UserApiFp.getAccessToken(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param userGroupID ID of the user group.
         * @param search Word or phrase to search for.
         * @param searchOn Comma-delimited list of fields to search on.
         * @param sortBy Comma-delimited list of fields to sort by.
         * @param page Page of results to return. Default: 1
         * @param pageSize Number of results to return per page. Default: 20, max: 100.
         */
        list(params: {  buyerID: string; userGroupID?: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
            return UserApiFp.list(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param userID ID of the user.
         * @param user 
         */
        patch(params: {  buyerID: string; userID: string; user: User; }) {
            return UserApiFp.patch(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param userID ID of the user.
         * @param user 
         */
        update(params: {  buyerID: string; userID: string; user: User; }) {
            return UserApiFp.update(params)(fetch, basePath);
        },
    }
};


/**
 * UserGroupApi - fetch parameter creator
 */
export const UserGroupApiFetchParamCreactor = {
    /** 
     * @param buyerID ID of the buyer.
     * @param userGroupID ID of the user group.
     */
    _delete(params: {  buyerID: string; userGroupID: string; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling _delete");
        }
        // verify required parameter "userGroupID" is set
        if (params["userGroupID"] == null) {
            throw new Error("Missing required parameter userGroupID when calling _delete");
        }
        const baseUrl = `/buyers/{buyerID}/usergroups/{userGroupID}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"userGroupID"}}`, `${ params.userGroupID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "DELETE" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param group 
     */
    create(params: {  buyerID: string; group: UserGroup; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling create");
        }
        // verify required parameter "group" is set
        if (params["group"] == null) {
            throw new Error("Missing required parameter group when calling create");
        }
        const baseUrl = `/buyers/{buyerID}/usergroups`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["group"]) {
            fetchOptions.body = JSON.stringify(params["group"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param userGroupID ID of the user group.
     * @param userID ID of the user.
     */
    deleteUserAssignment(params: {  buyerID: string; userGroupID: string; userID: string; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling deleteUserAssignment");
        }
        // verify required parameter "userGroupID" is set
        if (params["userGroupID"] == null) {
            throw new Error("Missing required parameter userGroupID when calling deleteUserAssignment");
        }
        // verify required parameter "userID" is set
        if (params["userID"] == null) {
            throw new Error("Missing required parameter userID when calling deleteUserAssignment");
        }
        const baseUrl = `/buyers/{buyerID}/usergroups/{userGroupID}/assignments/{userID}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"userGroupID"}}`, `${ params.userGroupID }`)
            .replace(`{${"userID"}}`, `${ params.userID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "DELETE" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param userGroupID ID of the user group.
     */
    get(params: {  buyerID: string; userGroupID: string; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling get");
        }
        // verify required parameter "userGroupID" is set
        if (params["userGroupID"] == null) {
            throw new Error("Missing required parameter userGroupID when calling get");
        }
        const baseUrl = `/buyers/{buyerID}/usergroups/{userGroupID}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"userGroupID"}}`, `${ params.userGroupID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    list(params: {  buyerID: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling list");
        }
        const baseUrl = `/buyers/{buyerID}/usergroups`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "search": params.search,
            "searchOn": params.searchOn,
            "sortBy": params.sortBy,
            "page": params.page,
            "pageSize": params.pageSize,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param userGroupID ID of the user group.
     * @param userID ID of the user.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listUserAssignments(params: {  buyerID: string; userGroupID?: string; userID?: string; page?: number; pageSize?: number; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling listUserAssignments");
        }
        const baseUrl = `/buyers/{buyerID}/usergroups/assignments`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "userGroupID": params.userGroupID,
            "userID": params.userID,
            "page": params.page,
            "pageSize": params.pageSize,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param userGroupID ID of the user group.
     * @param group 
     */
    patch(params: {  buyerID: string; userGroupID: string; group: UserGroup; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling patch");
        }
        // verify required parameter "userGroupID" is set
        if (params["userGroupID"] == null) {
            throw new Error("Missing required parameter userGroupID when calling patch");
        }
        // verify required parameter "group" is set
        if (params["group"] == null) {
            throw new Error("Missing required parameter group when calling patch");
        }
        const baseUrl = `/buyers/{buyerID}/usergroups/{userGroupID}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"userGroupID"}}`, `${ params.userGroupID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PATCH" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["group"]) {
            fetchOptions.body = JSON.stringify(params["group"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param userGroupAssignment 
     */
    saveUserAssignment(params: {  buyerID: string; userGroupAssignment: UserGroupAssignment; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling saveUserAssignment");
        }
        // verify required parameter "userGroupAssignment" is set
        if (params["userGroupAssignment"] == null) {
            throw new Error("Missing required parameter userGroupAssignment when calling saveUserAssignment");
        }
        const baseUrl = `/buyers/{buyerID}/usergroups/assignments`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["userGroupAssignment"]) {
            fetchOptions.body = JSON.stringify(params["userGroupAssignment"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param userGroupID ID of the user group.
     * @param group 
     */
    update(params: {  buyerID: string; userGroupID: string; group: UserGroup; }): FetchArgs {
        // verify required parameter "buyerID" is set
        if (params["buyerID"] == null) {
            throw new Error("Missing required parameter buyerID when calling update");
        }
        // verify required parameter "userGroupID" is set
        if (params["userGroupID"] == null) {
            throw new Error("Missing required parameter userGroupID when calling update");
        }
        // verify required parameter "group" is set
        if (params["group"] == null) {
            throw new Error("Missing required parameter group when calling update");
        }
        const baseUrl = `/buyers/{buyerID}/usergroups/{userGroupID}`
            .replace(`{${"buyerID"}}`, `${ params.buyerID }`)
            .replace(`{${"userGroupID"}}`, `${ params.userGroupID }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PUT" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["group"]) {
            fetchOptions.body = JSON.stringify(params["group"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
}

/**
 * UserGroupApi - functional programming interface
 */
export const UserGroupApiFp = {
    /** 
     * @param buyerID ID of the buyer.
     * @param userGroupID ID of the user group.
     */
    _delete(params: { buyerID: string; userGroupID: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserGroupApiFetchParamCreactor._delete(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param group 
     */
    create(params: { buyerID: string; group: UserGroup;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserGroupApiFetchParamCreactor.create(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param userGroupID ID of the user group.
     * @param userID ID of the user.
     */
    deleteUserAssignment(params: { buyerID: string; userGroupID: string; userID: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserGroupApiFetchParamCreactor.deleteUserAssignment(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param userGroupID ID of the user group.
     */
    get(params: { buyerID: string; userGroupID: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserGroupApiFetchParamCreactor.get(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    list(params: { buyerID: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserGroupApiFetchParamCreactor.list(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param userGroupID ID of the user group.
     * @param userID ID of the user.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listUserAssignments(params: { buyerID: string; userGroupID?: string; userID?: string; page?: number; pageSize?: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserGroupApiFetchParamCreactor.listUserAssignments(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param userGroupID ID of the user group.
     * @param group 
     */
    patch(params: { buyerID: string; userGroupID: string; group: UserGroup;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserGroupApiFetchParamCreactor.patch(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param userGroupAssignment 
     */
    saveUserAssignment(params: { buyerID: string; userGroupAssignment: UserGroupAssignment;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserGroupApiFetchParamCreactor.saveUserAssignment(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param buyerID ID of the buyer.
     * @param userGroupID ID of the user group.
     * @param group 
     */
    update(params: { buyerID: string; userGroupID: string; group: UserGroup;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserGroupApiFetchParamCreactor.update(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * UserGroupApi - object-oriented interface
 */
export class UserGroupApi extends BaseAPI {
    /** 
     * @param buyerID ID of the buyer.
     * @param userGroupID ID of the user group.
     */
    _delete(params: {  buyerID: string; userGroupID: string; }) {
        return UserGroupApiFp._delete(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param group 
     */
    create(params: {  buyerID: string; group: UserGroup; }) {
        return UserGroupApiFp.create(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param userGroupID ID of the user group.
     * @param userID ID of the user.
     */
    deleteUserAssignment(params: {  buyerID: string; userGroupID: string; userID: string; }) {
        return UserGroupApiFp.deleteUserAssignment(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param userGroupID ID of the user group.
     */
    get(params: {  buyerID: string; userGroupID: string; }) {
        return UserGroupApiFp.get(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    list(params: {  buyerID: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
        return UserGroupApiFp.list(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param userGroupID ID of the user group.
     * @param userID ID of the user.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    listUserAssignments(params: {  buyerID: string; userGroupID?: string; userID?: string; page?: number; pageSize?: number; }) {
        return UserGroupApiFp.listUserAssignments(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param userGroupID ID of the user group.
     * @param group 
     */
    patch(params: {  buyerID: string; userGroupID: string; group: UserGroup; }) {
        return UserGroupApiFp.patch(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param userGroupAssignment 
     */
    saveUserAssignment(params: {  buyerID: string; userGroupAssignment: UserGroupAssignment; }) {
        return UserGroupApiFp.saveUserAssignment(params)(this.fetch, this.basePath);
    }
    /** 
     * @param buyerID ID of the buyer.
     * @param userGroupID ID of the user group.
     * @param group 
     */
    update(params: {  buyerID: string; userGroupID: string; group: UserGroup; }) {
        return UserGroupApiFp.update(params)(this.fetch, this.basePath);
    }
};

/**
 * UserGroupApi - factory interface
 */
export const UserGroupApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * @param buyerID ID of the buyer.
         * @param userGroupID ID of the user group.
         */
        _delete(params: {  buyerID: string; userGroupID: string; }) {
            return UserGroupApiFp._delete(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param group 
         */
        create(params: {  buyerID: string; group: UserGroup; }) {
            return UserGroupApiFp.create(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param userGroupID ID of the user group.
         * @param userID ID of the user.
         */
        deleteUserAssignment(params: {  buyerID: string; userGroupID: string; userID: string; }) {
            return UserGroupApiFp.deleteUserAssignment(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param userGroupID ID of the user group.
         */
        get(params: {  buyerID: string; userGroupID: string; }) {
            return UserGroupApiFp.get(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param search Word or phrase to search for.
         * @param searchOn Comma-delimited list of fields to search on.
         * @param sortBy Comma-delimited list of fields to sort by.
         * @param page Page of results to return. Default: 1
         * @param pageSize Number of results to return per page. Default: 20, max: 100.
         */
        list(params: {  buyerID: string; search?: string; searchOn?: string; sortBy?: string; page?: number; pageSize?: number; }) {
            return UserGroupApiFp.list(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param userGroupID ID of the user group.
         * @param userID ID of the user.
         * @param page Page of results to return. Default: 1
         * @param pageSize Number of results to return per page. Default: 20, max: 100.
         */
        listUserAssignments(params: {  buyerID: string; userGroupID?: string; userID?: string; page?: number; pageSize?: number; }) {
            return UserGroupApiFp.listUserAssignments(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param userGroupID ID of the user group.
         * @param group 
         */
        patch(params: {  buyerID: string; userGroupID: string; group: UserGroup; }) {
            return UserGroupApiFp.patch(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param userGroupAssignment 
         */
        saveUserAssignment(params: {  buyerID: string; userGroupAssignment: UserGroupAssignment; }) {
            return UserGroupApiFp.saveUserAssignment(params)(fetch, basePath);
        },
        /** 
         * @param buyerID ID of the buyer.
         * @param userGroupID ID of the user group.
         * @param group 
         */
        update(params: {  buyerID: string; userGroupID: string; group: UserGroup; }) {
            return UserGroupApiFp.update(params)(fetch, basePath);
        },
    }
};

