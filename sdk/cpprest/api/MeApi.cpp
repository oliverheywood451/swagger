/**
 * OrderCloud
 * A full ecommerce backend as a service.
 *
 * OpenAPI spec version: 0.1
 * Contact: ordercloud@four51.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#include "MeApi.h"
#include "IHttpBody.h"
#include "JsonBody.h"
#include "MultipartFormData.h"

#include <unordered_set>

#include <boost/algorithm/string/replace.hpp>

namespace io {
namespace swagger {
namespace client {
namespace api {

using namespace io::swagger::client::model;

MeApi::MeApi( std::shared_ptr<ApiClient> apiClient )
    : m_ApiClient(apiClient)
{
}

MeApi::~MeApi()
{
}

pplx::task<std::shared_ptr<Object>> MeApi::createAddress(std::shared_ptr<BuyerAddress> address)
{
    
    // verify the required parameter 'address' is set
    if (address == nullptr)
    {
        throw ApiException(400, U("Missing required parameter 'address' when calling MeApi->createAddress"));
    }
    
    
    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/me/addresses");
        
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
        
    utility::string_t responseHttpContentType;
    
    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 || responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata 
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("MeApi->createAddress does not produce any supported media type"));
    }    
    
    headerParams[U("Accept")] = responseHttpContentType;
    
    std::unordered_set<utility::string_t> consumeHttpContentTypes;
        
    

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;
   
    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");

        web::json::value json;
 
        json = ModelBase::toJson(address);
        
        
        httpBody = std::shared_ptr<IHttpBody>( new JsonBody( json ) );
        
    }
    // multipart formdata 
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
        
        std::shared_ptr<MultipartFormData> multipart(new MultipartFormData);
        
        if(address.get())
        {
            address->toMultipart(multipart, U("address"));
        }
        

        httpBody = multipart;
        requestHttpContentType += U("; boundary=") + multipart->getBoundary();
    }
    else
    {
        throw ApiException(415, U("MeApi->createAddress does not consume any supported media type"));
    }    
    
    // authentication (auth) required
    // oauth2 authentication is added automatically as part of the http_client_config
    
    return m_ApiClient->callApi(path, U("POST"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
		// 1xx - informational : OK
		// 2xx - successful	   : OK
		// 3xx - redirection   : OK 
		// 4xx - client error  : not OK
		// 5xx - client error  : not OK
		if (response.status_code() >= 400)
		{
			throw ApiException(response.status_code()
				, U("error calling createAddress: ") + response.reason_phrase()
				, std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
		}
        
        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling createAddress: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }
        
        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<Object> result(nullptr);
        
        if(responseHttpContentType == U("application/json"))
        {
            web::json::value json = web::json::value::parse(response);
            
            result->fromJson(json);
        }
        // else if(responseHttpContentType == U("multipart/form-data"))
        // {
        // TODO multipart response parsing    
        // }
        else 
        {
			throw ApiException(500
				, U("error calling findPetsByStatus: unsupported response type"));
        }
        
        return result;
    });            
}
pplx::task<std::shared_ptr<Object>> MeApi::createCreditCard(std::shared_ptr<BuyerCreditCard> creditCard)
{
    
    // verify the required parameter 'creditCard' is set
    if (creditCard == nullptr)
    {
        throw ApiException(400, U("Missing required parameter 'creditCard' when calling MeApi->createCreditCard"));
    }
    
    
    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/me/creditcards");
        
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
        
    utility::string_t responseHttpContentType;
    
    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 || responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata 
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("MeApi->createCreditCard does not produce any supported media type"));
    }    
    
    headerParams[U("Accept")] = responseHttpContentType;
    
    std::unordered_set<utility::string_t> consumeHttpContentTypes;
        
    

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;
   
    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");

        web::json::value json;
 
        json = ModelBase::toJson(creditCard);
        
        
        httpBody = std::shared_ptr<IHttpBody>( new JsonBody( json ) );
        
    }
    // multipart formdata 
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
        
        std::shared_ptr<MultipartFormData> multipart(new MultipartFormData);
        
        if(creditCard.get())
        {
            creditCard->toMultipart(multipart, U("creditCard"));
        }
        

        httpBody = multipart;
        requestHttpContentType += U("; boundary=") + multipart->getBoundary();
    }
    else
    {
        throw ApiException(415, U("MeApi->createCreditCard does not consume any supported media type"));
    }    
    
    // authentication (auth) required
    // oauth2 authentication is added automatically as part of the http_client_config
    
    return m_ApiClient->callApi(path, U("POST"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
		// 1xx - informational : OK
		// 2xx - successful	   : OK
		// 3xx - redirection   : OK 
		// 4xx - client error  : not OK
		// 5xx - client error  : not OK
		if (response.status_code() >= 400)
		{
			throw ApiException(response.status_code()
				, U("error calling createCreditCard: ") + response.reason_phrase()
				, std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
		}
        
        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling createCreditCard: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }
        
        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<Object> result(nullptr);
        
        if(responseHttpContentType == U("application/json"))
        {
            web::json::value json = web::json::value::parse(response);
            
            result->fromJson(json);
        }
        // else if(responseHttpContentType == U("multipart/form-data"))
        // {
        // TODO multipart response parsing    
        // }
        else 
        {
			throw ApiException(500
				, U("error calling findPetsByStatus: unsupported response type"));
        }
        
        return result;
    });            
}
pplx::task<void> MeApi::deleteAddress(utility::string_t addressID)
{
    
    
    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/me/addresses/{addressID}");
    boost::replace_all(path, U("{") U("addressID") U("}"), ApiClient::parameterToString(addressID));
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
        
    utility::string_t responseHttpContentType;
    
    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 || responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata 
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("MeApi->deleteAddress does not produce any supported media type"));
    }    
    
    headerParams[U("Accept")] = responseHttpContentType;
    
    std::unordered_set<utility::string_t> consumeHttpContentTypes;
        
    
    {
        
    }
    

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;
   
    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");

    }
    // multipart formdata 
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
        
    }
    else
    {
        throw ApiException(415, U("MeApi->deleteAddress does not consume any supported media type"));
    }    
    
    // authentication (auth) required
    // oauth2 authentication is added automatically as part of the http_client_config
    
    return m_ApiClient->callApi(path, U("DELETE"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
		// 1xx - informational : OK
		// 2xx - successful	   : OK
		// 3xx - redirection   : OK 
		// 4xx - client error  : not OK
		// 5xx - client error  : not OK
		if (response.status_code() >= 400)
		{
			throw ApiException(response.status_code()
				, U("error calling deleteAddress: ") + response.reason_phrase()
				, std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
		}
        
        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling deleteAddress: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }
        
        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        return void();
            });            
}
pplx::task<void> MeApi::deleteCreditCard(utility::string_t creditcardID)
{
    
    
    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/me/creditcards/{creditcardID}");
    boost::replace_all(path, U("{") U("creditcardID") U("}"), ApiClient::parameterToString(creditcardID));
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
        
    utility::string_t responseHttpContentType;
    
    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 || responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata 
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("MeApi->deleteCreditCard does not produce any supported media type"));
    }    
    
    headerParams[U("Accept")] = responseHttpContentType;
    
    std::unordered_set<utility::string_t> consumeHttpContentTypes;
        
    
    {
        
    }
    

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;
   
    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");

    }
    // multipart formdata 
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
        
    }
    else
    {
        throw ApiException(415, U("MeApi->deleteCreditCard does not consume any supported media type"));
    }    
    
    // authentication (auth) required
    // oauth2 authentication is added automatically as part of the http_client_config
    
    return m_ApiClient->callApi(path, U("DELETE"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
		// 1xx - informational : OK
		// 2xx - successful	   : OK
		// 3xx - redirection   : OK 
		// 4xx - client error  : not OK
		// 5xx - client error  : not OK
		if (response.status_code() >= 400)
		{
			throw ApiException(response.status_code()
				, U("error calling deleteCreditCard: ") + response.reason_phrase()
				, std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
		}
        
        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling deleteCreditCard: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }
        
        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        return void();
            });            
}
pplx::task<std::shared_ptr<Object>> MeApi::get()
{
    
    
    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/me");
        
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
        
    utility::string_t responseHttpContentType;
    
    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 || responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata 
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("MeApi->get does not produce any supported media type"));
    }    
    
    headerParams[U("Accept")] = responseHttpContentType;
    
    std::unordered_set<utility::string_t> consumeHttpContentTypes;
        
    

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;
   
    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");

    }
    // multipart formdata 
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
        
    }
    else
    {
        throw ApiException(415, U("MeApi->get does not consume any supported media type"));
    }    
    
    // authentication (auth) required
    // oauth2 authentication is added automatically as part of the http_client_config
    
    return m_ApiClient->callApi(path, U("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
		// 1xx - informational : OK
		// 2xx - successful	   : OK
		// 3xx - redirection   : OK 
		// 4xx - client error  : not OK
		// 5xx - client error  : not OK
		if (response.status_code() >= 400)
		{
			throw ApiException(response.status_code()
				, U("error calling get: ") + response.reason_phrase()
				, std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
		}
        
        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling get: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }
        
        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<Object> result(nullptr);
        
        if(responseHttpContentType == U("application/json"))
        {
            web::json::value json = web::json::value::parse(response);
            
            result->fromJson(json);
        }
        // else if(responseHttpContentType == U("multipart/form-data"))
        // {
        // TODO multipart response parsing    
        // }
        else 
        {
			throw ApiException(500
				, U("error calling findPetsByStatus: unsupported response type"));
        }
        
        return result;
    });            
}
pplx::task<std::shared_ptr<Object>> MeApi::getAddress(utility::string_t addressID)
{
    
    
    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/me/addresses/{addressID}");
    boost::replace_all(path, U("{") U("addressID") U("}"), ApiClient::parameterToString(addressID));
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
        
    utility::string_t responseHttpContentType;
    
    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 || responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata 
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("MeApi->getAddress does not produce any supported media type"));
    }    
    
    headerParams[U("Accept")] = responseHttpContentType;
    
    std::unordered_set<utility::string_t> consumeHttpContentTypes;
        
    
    {
        
    }
    

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;
   
    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");

    }
    // multipart formdata 
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
        
    }
    else
    {
        throw ApiException(415, U("MeApi->getAddress does not consume any supported media type"));
    }    
    
    // authentication (auth) required
    // oauth2 authentication is added automatically as part of the http_client_config
    
    return m_ApiClient->callApi(path, U("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
		// 1xx - informational : OK
		// 2xx - successful	   : OK
		// 3xx - redirection   : OK 
		// 4xx - client error  : not OK
		// 5xx - client error  : not OK
		if (response.status_code() >= 400)
		{
			throw ApiException(response.status_code()
				, U("error calling getAddress: ") + response.reason_phrase()
				, std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
		}
        
        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling getAddress: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }
        
        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<Object> result(nullptr);
        
        if(responseHttpContentType == U("application/json"))
        {
            web::json::value json = web::json::value::parse(response);
            
            result->fromJson(json);
        }
        // else if(responseHttpContentType == U("multipart/form-data"))
        // {
        // TODO multipart response parsing    
        // }
        else 
        {
			throw ApiException(500
				, U("error calling findPetsByStatus: unsupported response type"));
        }
        
        return result;
    });            
}
pplx::task<std::shared_ptr<Object>> MeApi::getCreditCard(utility::string_t creditcardID)
{
    
    
    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/me/creditcards/{creditcardID}");
    boost::replace_all(path, U("{") U("creditcardID") U("}"), ApiClient::parameterToString(creditcardID));
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
        
    utility::string_t responseHttpContentType;
    
    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 || responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata 
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("MeApi->getCreditCard does not produce any supported media type"));
    }    
    
    headerParams[U("Accept")] = responseHttpContentType;
    
    std::unordered_set<utility::string_t> consumeHttpContentTypes;
        
    
    {
        
    }
    

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;
   
    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");

    }
    // multipart formdata 
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
        
    }
    else
    {
        throw ApiException(415, U("MeApi->getCreditCard does not consume any supported media type"));
    }    
    
    // authentication (auth) required
    // oauth2 authentication is added automatically as part of the http_client_config
    
    return m_ApiClient->callApi(path, U("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
		// 1xx - informational : OK
		// 2xx - successful	   : OK
		// 3xx - redirection   : OK 
		// 4xx - client error  : not OK
		// 5xx - client error  : not OK
		if (response.status_code() >= 400)
		{
			throw ApiException(response.status_code()
				, U("error calling getCreditCard: ") + response.reason_phrase()
				, std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
		}
        
        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling getCreditCard: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }
        
        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<Object> result(nullptr);
        
        if(responseHttpContentType == U("application/json"))
        {
            web::json::value json = web::json::value::parse(response);
            
            result->fromJson(json);
        }
        // else if(responseHttpContentType == U("multipart/form-data"))
        // {
        // TODO multipart response parsing    
        // }
        else 
        {
			throw ApiException(500
				, U("error calling findPetsByStatus: unsupported response type"));
        }
        
        return result;
    });            
}
pplx::task<std::shared_ptr<Object>> MeApi::getOrder(utility::string_t orderID)
{
    
    
    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/me/orders/{orderID}");
    boost::replace_all(path, U("{") U("orderID") U("}"), ApiClient::parameterToString(orderID));
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
        
    utility::string_t responseHttpContentType;
    
    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 || responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata 
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("MeApi->getOrder does not produce any supported media type"));
    }    
    
    headerParams[U("Accept")] = responseHttpContentType;
    
    std::unordered_set<utility::string_t> consumeHttpContentTypes;
        
    
    {
        
    }
    

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;
   
    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");

    }
    // multipart formdata 
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
        
    }
    else
    {
        throw ApiException(415, U("MeApi->getOrder does not consume any supported media type"));
    }    
    
    // authentication (auth) required
    // oauth2 authentication is added automatically as part of the http_client_config
    
    return m_ApiClient->callApi(path, U("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
		// 1xx - informational : OK
		// 2xx - successful	   : OK
		// 3xx - redirection   : OK 
		// 4xx - client error  : not OK
		// 5xx - client error  : not OK
		if (response.status_code() >= 400)
		{
			throw ApiException(response.status_code()
				, U("error calling getOrder: ") + response.reason_phrase()
				, std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
		}
        
        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling getOrder: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }
        
        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<Object> result(nullptr);
        
        if(responseHttpContentType == U("application/json"))
        {
            web::json::value json = web::json::value::parse(response);
            
            result->fromJson(json);
        }
        // else if(responseHttpContentType == U("multipart/form-data"))
        // {
        // TODO multipart response parsing    
        // }
        else 
        {
			throw ApiException(500
				, U("error calling findPetsByStatus: unsupported response type"));
        }
        
        return result;
    });            
}
pplx::task<std::shared_ptr<Object>> MeApi::getProduct(utility::string_t productID)
{
    
    
    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/me/products/{productID}");
    boost::replace_all(path, U("{") U("productID") U("}"), ApiClient::parameterToString(productID));
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
        
    utility::string_t responseHttpContentType;
    
    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 || responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata 
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("MeApi->getProduct does not produce any supported media type"));
    }    
    
    headerParams[U("Accept")] = responseHttpContentType;
    
    std::unordered_set<utility::string_t> consumeHttpContentTypes;
        
    
    {
        
    }
    

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;
   
    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");

    }
    // multipart formdata 
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
        
    }
    else
    {
        throw ApiException(415, U("MeApi->getProduct does not consume any supported media type"));
    }    
    
    // authentication (auth) required
    // oauth2 authentication is added automatically as part of the http_client_config
    
    return m_ApiClient->callApi(path, U("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
		// 1xx - informational : OK
		// 2xx - successful	   : OK
		// 3xx - redirection   : OK 
		// 4xx - client error  : not OK
		// 5xx - client error  : not OK
		if (response.status_code() >= 400)
		{
			throw ApiException(response.status_code()
				, U("error calling getProduct: ") + response.reason_phrase()
				, std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
		}
        
        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling getProduct: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }
        
        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<Object> result(nullptr);
        
        if(responseHttpContentType == U("application/json"))
        {
            web::json::value json = web::json::value::parse(response);
            
            result->fromJson(json);
        }
        // else if(responseHttpContentType == U("multipart/form-data"))
        // {
        // TODO multipart response parsing    
        // }
        else 
        {
			throw ApiException(500
				, U("error calling findPetsByStatus: unsupported response type"));
        }
        
        return result;
    });            
}
pplx::task<std::shared_ptr<Object>> MeApi::getPromotion(utility::string_t promotionID)
{
    
    
    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/me/promotions/{promotionID}");
    boost::replace_all(path, U("{") U("promotionID") U("}"), ApiClient::parameterToString(promotionID));
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
        
    utility::string_t responseHttpContentType;
    
    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 || responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata 
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("MeApi->getPromotion does not produce any supported media type"));
    }    
    
    headerParams[U("Accept")] = responseHttpContentType;
    
    std::unordered_set<utility::string_t> consumeHttpContentTypes;
        
    
    {
        
    }
    

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;
   
    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");

    }
    // multipart formdata 
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
        
    }
    else
    {
        throw ApiException(415, U("MeApi->getPromotion does not consume any supported media type"));
    }    
    
    // authentication (auth) required
    // oauth2 authentication is added automatically as part of the http_client_config
    
    return m_ApiClient->callApi(path, U("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
		// 1xx - informational : OK
		// 2xx - successful	   : OK
		// 3xx - redirection   : OK 
		// 4xx - client error  : not OK
		// 5xx - client error  : not OK
		if (response.status_code() >= 400)
		{
			throw ApiException(response.status_code()
				, U("error calling getPromotion: ") + response.reason_phrase()
				, std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
		}
        
        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling getPromotion: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }
        
        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<Object> result(nullptr);
        
        if(responseHttpContentType == U("application/json"))
        {
            web::json::value json = web::json::value::parse(response);
            
            result->fromJson(json);
        }
        // else if(responseHttpContentType == U("multipart/form-data"))
        // {
        // TODO multipart response parsing    
        // }
        else 
        {
			throw ApiException(500
				, U("error calling findPetsByStatus: unsupported response type"));
        }
        
        return result;
    });            
}
pplx::task<std::shared_ptr<Object>> MeApi::getSpec(utility::string_t productID, utility::string_t specID)
{
    
    
    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/me/products/{productID}/specs/{specID}");
    boost::replace_all(path, U("{") U("productID") U("}"), ApiClient::parameterToString(productID));
boost::replace_all(path, U("{") U("specID") U("}"), ApiClient::parameterToString(specID));
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
        
    utility::string_t responseHttpContentType;
    
    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 || responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata 
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("MeApi->getSpec does not produce any supported media type"));
    }    
    
    headerParams[U("Accept")] = responseHttpContentType;
    
    std::unordered_set<utility::string_t> consumeHttpContentTypes;
        
    
    {
        
    }
    
    {
        
    }
    

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;
   
    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");

    }
    // multipart formdata 
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
        
    }
    else
    {
        throw ApiException(415, U("MeApi->getSpec does not consume any supported media type"));
    }    
    
    // authentication (auth) required
    // oauth2 authentication is added automatically as part of the http_client_config
    
    return m_ApiClient->callApi(path, U("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
		// 1xx - informational : OK
		// 2xx - successful	   : OK
		// 3xx - redirection   : OK 
		// 4xx - client error  : not OK
		// 5xx - client error  : not OK
		if (response.status_code() >= 400)
		{
			throw ApiException(response.status_code()
				, U("error calling getSpec: ") + response.reason_phrase()
				, std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
		}
        
        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling getSpec: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }
        
        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<Object> result(nullptr);
        
        if(responseHttpContentType == U("application/json"))
        {
            web::json::value json = web::json::value::parse(response);
            
            result->fromJson(json);
        }
        // else if(responseHttpContentType == U("multipart/form-data"))
        // {
        // TODO multipart response parsing    
        // }
        else 
        {
			throw ApiException(500
				, U("error calling findPetsByStatus: unsupported response type"));
        }
        
        return result;
    });            
}
pplx::task<std::shared_ptr<Object>> MeApi::listAddresses(utility::string_t search, utility::string_t searchOn, utility::string_t sortBy, int32_t page, int32_t pageSize)
{
    
    
    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/me/addresses");
        
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
        
    utility::string_t responseHttpContentType;
    
    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 || responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata 
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("MeApi->listAddresses does not produce any supported media type"));
    }    
    
    headerParams[U("Accept")] = responseHttpContentType;
    
    std::unordered_set<utility::string_t> consumeHttpContentTypes;
        
    
    {
        queryParams[U("search")] = ApiClient::parameterToString(search);
        
    }
    
    {
        queryParams[U("searchOn")] = ApiClient::parameterToString(searchOn);
        
    }
    
    {
        queryParams[U("sortBy")] = ApiClient::parameterToString(sortBy);
        
    }
    
    {
        queryParams[U("page")] = ApiClient::parameterToString(page);
        
    }
    
    {
        queryParams[U("pageSize")] = ApiClient::parameterToString(pageSize);
        
    }
    

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;
   
    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");

    }
    // multipart formdata 
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
        
    }
    else
    {
        throw ApiException(415, U("MeApi->listAddresses does not consume any supported media type"));
    }    
    
    // authentication (auth) required
    // oauth2 authentication is added automatically as part of the http_client_config
    
    return m_ApiClient->callApi(path, U("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
		// 1xx - informational : OK
		// 2xx - successful	   : OK
		// 3xx - redirection   : OK 
		// 4xx - client error  : not OK
		// 5xx - client error  : not OK
		if (response.status_code() >= 400)
		{
			throw ApiException(response.status_code()
				, U("error calling listAddresses: ") + response.reason_phrase()
				, std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
		}
        
        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling listAddresses: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }
        
        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<Object> result(nullptr);
        
        if(responseHttpContentType == U("application/json"))
        {
            web::json::value json = web::json::value::parse(response);
            
            result->fromJson(json);
        }
        // else if(responseHttpContentType == U("multipart/form-data"))
        // {
        // TODO multipart response parsing    
        // }
        else 
        {
			throw ApiException(500
				, U("error calling findPetsByStatus: unsupported response type"));
        }
        
        return result;
    });            
}
pplx::task<std::shared_ptr<Object>> MeApi::listCategories(utility::string_t depth, utility::string_t search, utility::string_t searchOn, utility::string_t sortBy, int32_t page, int32_t pageSize)
{
    
    
    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/me/categories");
        
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
        
    utility::string_t responseHttpContentType;
    
    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 || responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata 
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("MeApi->listCategories does not produce any supported media type"));
    }    
    
    headerParams[U("Accept")] = responseHttpContentType;
    
    std::unordered_set<utility::string_t> consumeHttpContentTypes;
        
    
    {
        queryParams[U("depth")] = ApiClient::parameterToString(depth);
        
    }
    
    {
        queryParams[U("search")] = ApiClient::parameterToString(search);
        
    }
    
    {
        queryParams[U("searchOn")] = ApiClient::parameterToString(searchOn);
        
    }
    
    {
        queryParams[U("sortBy")] = ApiClient::parameterToString(sortBy);
        
    }
    
    {
        queryParams[U("page")] = ApiClient::parameterToString(page);
        
    }
    
    {
        queryParams[U("pageSize")] = ApiClient::parameterToString(pageSize);
        
    }
    

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;
   
    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");

    }
    // multipart formdata 
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
        
    }
    else
    {
        throw ApiException(415, U("MeApi->listCategories does not consume any supported media type"));
    }    
    
    // authentication (auth) required
    // oauth2 authentication is added automatically as part of the http_client_config
    
    return m_ApiClient->callApi(path, U("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
		// 1xx - informational : OK
		// 2xx - successful	   : OK
		// 3xx - redirection   : OK 
		// 4xx - client error  : not OK
		// 5xx - client error  : not OK
		if (response.status_code() >= 400)
		{
			throw ApiException(response.status_code()
				, U("error calling listCategories: ") + response.reason_phrase()
				, std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
		}
        
        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling listCategories: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }
        
        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<Object> result(nullptr);
        
        if(responseHttpContentType == U("application/json"))
        {
            web::json::value json = web::json::value::parse(response);
            
            result->fromJson(json);
        }
        // else if(responseHttpContentType == U("multipart/form-data"))
        // {
        // TODO multipart response parsing    
        // }
        else 
        {
			throw ApiException(500
				, U("error calling findPetsByStatus: unsupported response type"));
        }
        
        return result;
    });            
}
pplx::task<std::shared_ptr<Object>> MeApi::listCostCenters(utility::string_t search, utility::string_t searchOn, utility::string_t sortBy, int32_t page, int32_t pageSize)
{
    
    
    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/me/costcenters");
        
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
        
    utility::string_t responseHttpContentType;
    
    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 || responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata 
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("MeApi->listCostCenters does not produce any supported media type"));
    }    
    
    headerParams[U("Accept")] = responseHttpContentType;
    
    std::unordered_set<utility::string_t> consumeHttpContentTypes;
        
    
    {
        queryParams[U("search")] = ApiClient::parameterToString(search);
        
    }
    
    {
        queryParams[U("searchOn")] = ApiClient::parameterToString(searchOn);
        
    }
    
    {
        queryParams[U("sortBy")] = ApiClient::parameterToString(sortBy);
        
    }
    
    {
        queryParams[U("page")] = ApiClient::parameterToString(page);
        
    }
    
    {
        queryParams[U("pageSize")] = ApiClient::parameterToString(pageSize);
        
    }
    

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;
   
    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");

    }
    // multipart formdata 
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
        
    }
    else
    {
        throw ApiException(415, U("MeApi->listCostCenters does not consume any supported media type"));
    }    
    
    // authentication (auth) required
    // oauth2 authentication is added automatically as part of the http_client_config
    
    return m_ApiClient->callApi(path, U("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
		// 1xx - informational : OK
		// 2xx - successful	   : OK
		// 3xx - redirection   : OK 
		// 4xx - client error  : not OK
		// 5xx - client error  : not OK
		if (response.status_code() >= 400)
		{
			throw ApiException(response.status_code()
				, U("error calling listCostCenters: ") + response.reason_phrase()
				, std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
		}
        
        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling listCostCenters: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }
        
        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<Object> result(nullptr);
        
        if(responseHttpContentType == U("application/json"))
        {
            web::json::value json = web::json::value::parse(response);
            
            result->fromJson(json);
        }
        // else if(responseHttpContentType == U("multipart/form-data"))
        // {
        // TODO multipart response parsing    
        // }
        else 
        {
			throw ApiException(500
				, U("error calling findPetsByStatus: unsupported response type"));
        }
        
        return result;
    });            
}
pplx::task<std::shared_ptr<Object>> MeApi::listCreditCards(utility::string_t search, utility::string_t searchOn, utility::string_t sortBy, int32_t page, int32_t pageSize)
{
    
    
    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/me/creditcards");
        
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
        
    utility::string_t responseHttpContentType;
    
    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 || responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata 
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("MeApi->listCreditCards does not produce any supported media type"));
    }    
    
    headerParams[U("Accept")] = responseHttpContentType;
    
    std::unordered_set<utility::string_t> consumeHttpContentTypes;
        
    
    {
        queryParams[U("search")] = ApiClient::parameterToString(search);
        
    }
    
    {
        queryParams[U("searchOn")] = ApiClient::parameterToString(searchOn);
        
    }
    
    {
        queryParams[U("sortBy")] = ApiClient::parameterToString(sortBy);
        
    }
    
    {
        queryParams[U("page")] = ApiClient::parameterToString(page);
        
    }
    
    {
        queryParams[U("pageSize")] = ApiClient::parameterToString(pageSize);
        
    }
    

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;
   
    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");

    }
    // multipart formdata 
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
        
    }
    else
    {
        throw ApiException(415, U("MeApi->listCreditCards does not consume any supported media type"));
    }    
    
    // authentication (auth) required
    // oauth2 authentication is added automatically as part of the http_client_config
    
    return m_ApiClient->callApi(path, U("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
		// 1xx - informational : OK
		// 2xx - successful	   : OK
		// 3xx - redirection   : OK 
		// 4xx - client error  : not OK
		// 5xx - client error  : not OK
		if (response.status_code() >= 400)
		{
			throw ApiException(response.status_code()
				, U("error calling listCreditCards: ") + response.reason_phrase()
				, std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
		}
        
        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling listCreditCards: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }
        
        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<Object> result(nullptr);
        
        if(responseHttpContentType == U("application/json"))
        {
            web::json::value json = web::json::value::parse(response);
            
            result->fromJson(json);
        }
        // else if(responseHttpContentType == U("multipart/form-data"))
        // {
        // TODO multipart response parsing    
        // }
        else 
        {
			throw ApiException(500
				, U("error calling findPetsByStatus: unsupported response type"));
        }
        
        return result;
    });            
}
pplx::task<std::shared_ptr<Object>> MeApi::listIncomingOrders(utility::string_t from, utility::string_t to, utility::string_t search, utility::string_t searchOn, utility::string_t sortBy, int32_t page, int32_t pageSize)
{
    
    
    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/me/orders/incoming");
        
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
        
    utility::string_t responseHttpContentType;
    
    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 || responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata 
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("MeApi->listIncomingOrders does not produce any supported media type"));
    }    
    
    headerParams[U("Accept")] = responseHttpContentType;
    
    std::unordered_set<utility::string_t> consumeHttpContentTypes;
        
    
    {
        queryParams[U("from")] = ApiClient::parameterToString(from);
        
    }
    
    {
        queryParams[U("to")] = ApiClient::parameterToString(to);
        
    }
    
    {
        queryParams[U("search")] = ApiClient::parameterToString(search);
        
    }
    
    {
        queryParams[U("searchOn")] = ApiClient::parameterToString(searchOn);
        
    }
    
    {
        queryParams[U("sortBy")] = ApiClient::parameterToString(sortBy);
        
    }
    
    {
        queryParams[U("page")] = ApiClient::parameterToString(page);
        
    }
    
    {
        queryParams[U("pageSize")] = ApiClient::parameterToString(pageSize);
        
    }
    

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;
   
    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");

    }
    // multipart formdata 
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
        
    }
    else
    {
        throw ApiException(415, U("MeApi->listIncomingOrders does not consume any supported media type"));
    }    
    
    // authentication (auth) required
    // oauth2 authentication is added automatically as part of the http_client_config
    
    return m_ApiClient->callApi(path, U("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
		// 1xx - informational : OK
		// 2xx - successful	   : OK
		// 3xx - redirection   : OK 
		// 4xx - client error  : not OK
		// 5xx - client error  : not OK
		if (response.status_code() >= 400)
		{
			throw ApiException(response.status_code()
				, U("error calling listIncomingOrders: ") + response.reason_phrase()
				, std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
		}
        
        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling listIncomingOrders: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }
        
        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<Object> result(nullptr);
        
        if(responseHttpContentType == U("application/json"))
        {
            web::json::value json = web::json::value::parse(response);
            
            result->fromJson(json);
        }
        // else if(responseHttpContentType == U("multipart/form-data"))
        // {
        // TODO multipart response parsing    
        // }
        else 
        {
			throw ApiException(500
				, U("error calling findPetsByStatus: unsupported response type"));
        }
        
        return result;
    });            
}
pplx::task<std::shared_ptr<Object>> MeApi::listOutgoingOrders(utility::string_t from, utility::string_t to, utility::string_t search, utility::string_t searchOn, utility::string_t sortBy, int32_t page, int32_t pageSize)
{
    
    
    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/me/orders/outgoing");
        
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
        
    utility::string_t responseHttpContentType;
    
    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 || responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata 
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("MeApi->listOutgoingOrders does not produce any supported media type"));
    }    
    
    headerParams[U("Accept")] = responseHttpContentType;
    
    std::unordered_set<utility::string_t> consumeHttpContentTypes;
        
    
    {
        queryParams[U("from")] = ApiClient::parameterToString(from);
        
    }
    
    {
        queryParams[U("to")] = ApiClient::parameterToString(to);
        
    }
    
    {
        queryParams[U("search")] = ApiClient::parameterToString(search);
        
    }
    
    {
        queryParams[U("searchOn")] = ApiClient::parameterToString(searchOn);
        
    }
    
    {
        queryParams[U("sortBy")] = ApiClient::parameterToString(sortBy);
        
    }
    
    {
        queryParams[U("page")] = ApiClient::parameterToString(page);
        
    }
    
    {
        queryParams[U("pageSize")] = ApiClient::parameterToString(pageSize);
        
    }
    

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;
   
    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");

    }
    // multipart formdata 
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
        
    }
    else
    {
        throw ApiException(415, U("MeApi->listOutgoingOrders does not consume any supported media type"));
    }    
    
    // authentication (auth) required
    // oauth2 authentication is added automatically as part of the http_client_config
    
    return m_ApiClient->callApi(path, U("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
		// 1xx - informational : OK
		// 2xx - successful	   : OK
		// 3xx - redirection   : OK 
		// 4xx - client error  : not OK
		// 5xx - client error  : not OK
		if (response.status_code() >= 400)
		{
			throw ApiException(response.status_code()
				, U("error calling listOutgoingOrders: ") + response.reason_phrase()
				, std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
		}
        
        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling listOutgoingOrders: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }
        
        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<Object> result(nullptr);
        
        if(responseHttpContentType == U("application/json"))
        {
            web::json::value json = web::json::value::parse(response);
            
            result->fromJson(json);
        }
        // else if(responseHttpContentType == U("multipart/form-data"))
        // {
        // TODO multipart response parsing    
        // }
        else 
        {
			throw ApiException(500
				, U("error calling findPetsByStatus: unsupported response type"));
        }
        
        return result;
    });            
}
pplx::task<std::shared_ptr<Object>> MeApi::listProducts(utility::string_t categoryID, utility::string_t search, utility::string_t searchOn, utility::string_t sortBy, int32_t page, int32_t pageSize)
{
    
    
    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/me/products");
        
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
        
    utility::string_t responseHttpContentType;
    
    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 || responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata 
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("MeApi->listProducts does not produce any supported media type"));
    }    
    
    headerParams[U("Accept")] = responseHttpContentType;
    
    std::unordered_set<utility::string_t> consumeHttpContentTypes;
        
    
    {
        queryParams[U("categoryID")] = ApiClient::parameterToString(categoryID);
        
    }
    
    {
        queryParams[U("search")] = ApiClient::parameterToString(search);
        
    }
    
    {
        queryParams[U("searchOn")] = ApiClient::parameterToString(searchOn);
        
    }
    
    {
        queryParams[U("sortBy")] = ApiClient::parameterToString(sortBy);
        
    }
    
    {
        queryParams[U("page")] = ApiClient::parameterToString(page);
        
    }
    
    {
        queryParams[U("pageSize")] = ApiClient::parameterToString(pageSize);
        
    }
    

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;
   
    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");

    }
    // multipart formdata 
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
        
    }
    else
    {
        throw ApiException(415, U("MeApi->listProducts does not consume any supported media type"));
    }    
    
    // authentication (auth) required
    // oauth2 authentication is added automatically as part of the http_client_config
    
    return m_ApiClient->callApi(path, U("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
		// 1xx - informational : OK
		// 2xx - successful	   : OK
		// 3xx - redirection   : OK 
		// 4xx - client error  : not OK
		// 5xx - client error  : not OK
		if (response.status_code() >= 400)
		{
			throw ApiException(response.status_code()
				, U("error calling listProducts: ") + response.reason_phrase()
				, std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
		}
        
        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling listProducts: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }
        
        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<Object> result(nullptr);
        
        if(responseHttpContentType == U("application/json"))
        {
            web::json::value json = web::json::value::parse(response);
            
            result->fromJson(json);
        }
        // else if(responseHttpContentType == U("multipart/form-data"))
        // {
        // TODO multipart response parsing    
        // }
        else 
        {
			throw ApiException(500
				, U("error calling findPetsByStatus: unsupported response type"));
        }
        
        return result;
    });            
}
pplx::task<std::shared_ptr<Object>> MeApi::listPromotions(utility::string_t search, utility::string_t searchOn, utility::string_t sortBy, int32_t page, int32_t pageSize)
{
    
    
    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/me/promotions");
        
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
        
    utility::string_t responseHttpContentType;
    
    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 || responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata 
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("MeApi->listPromotions does not produce any supported media type"));
    }    
    
    headerParams[U("Accept")] = responseHttpContentType;
    
    std::unordered_set<utility::string_t> consumeHttpContentTypes;
        
    
    {
        queryParams[U("search")] = ApiClient::parameterToString(search);
        
    }
    
    {
        queryParams[U("searchOn")] = ApiClient::parameterToString(searchOn);
        
    }
    
    {
        queryParams[U("sortBy")] = ApiClient::parameterToString(sortBy);
        
    }
    
    {
        queryParams[U("page")] = ApiClient::parameterToString(page);
        
    }
    
    {
        queryParams[U("pageSize")] = ApiClient::parameterToString(pageSize);
        
    }
    

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;
   
    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");

    }
    // multipart formdata 
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
        
    }
    else
    {
        throw ApiException(415, U("MeApi->listPromotions does not consume any supported media type"));
    }    
    
    // authentication (auth) required
    // oauth2 authentication is added automatically as part of the http_client_config
    
    return m_ApiClient->callApi(path, U("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
		// 1xx - informational : OK
		// 2xx - successful	   : OK
		// 3xx - redirection   : OK 
		// 4xx - client error  : not OK
		// 5xx - client error  : not OK
		if (response.status_code() >= 400)
		{
			throw ApiException(response.status_code()
				, U("error calling listPromotions: ") + response.reason_phrase()
				, std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
		}
        
        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling listPromotions: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }
        
        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<Object> result(nullptr);
        
        if(responseHttpContentType == U("application/json"))
        {
            web::json::value json = web::json::value::parse(response);
            
            result->fromJson(json);
        }
        // else if(responseHttpContentType == U("multipart/form-data"))
        // {
        // TODO multipart response parsing    
        // }
        else 
        {
			throw ApiException(500
				, U("error calling findPetsByStatus: unsupported response type"));
        }
        
        return result;
    });            
}
pplx::task<std::shared_ptr<Object>> MeApi::listSpecs(utility::string_t productID, utility::string_t search, utility::string_t searchOn, utility::string_t sortBy, int32_t page, int32_t pageSize)
{
    
    
    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/me/products/{productID}/specs");
    boost::replace_all(path, U("{") U("productID") U("}"), ApiClient::parameterToString(productID));
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
        
    utility::string_t responseHttpContentType;
    
    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 || responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata 
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("MeApi->listSpecs does not produce any supported media type"));
    }    
    
    headerParams[U("Accept")] = responseHttpContentType;
    
    std::unordered_set<utility::string_t> consumeHttpContentTypes;
        
    
    {
        
    }
    
    {
        queryParams[U("search")] = ApiClient::parameterToString(search);
        
    }
    
    {
        queryParams[U("searchOn")] = ApiClient::parameterToString(searchOn);
        
    }
    
    {
        queryParams[U("sortBy")] = ApiClient::parameterToString(sortBy);
        
    }
    
    {
        queryParams[U("page")] = ApiClient::parameterToString(page);
        
    }
    
    {
        queryParams[U("pageSize")] = ApiClient::parameterToString(pageSize);
        
    }
    

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;
   
    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");

    }
    // multipart formdata 
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
        
    }
    else
    {
        throw ApiException(415, U("MeApi->listSpecs does not consume any supported media type"));
    }    
    
    // authentication (auth) required
    // oauth2 authentication is added automatically as part of the http_client_config
    
    return m_ApiClient->callApi(path, U("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
		// 1xx - informational : OK
		// 2xx - successful	   : OK
		// 3xx - redirection   : OK 
		// 4xx - client error  : not OK
		// 5xx - client error  : not OK
		if (response.status_code() >= 400)
		{
			throw ApiException(response.status_code()
				, U("error calling listSpecs: ") + response.reason_phrase()
				, std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
		}
        
        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling listSpecs: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }
        
        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<Object> result(nullptr);
        
        if(responseHttpContentType == U("application/json"))
        {
            web::json::value json = web::json::value::parse(response);
            
            result->fromJson(json);
        }
        // else if(responseHttpContentType == U("multipart/form-data"))
        // {
        // TODO multipart response parsing    
        // }
        else 
        {
			throw ApiException(500
				, U("error calling findPetsByStatus: unsupported response type"));
        }
        
        return result;
    });            
}
pplx::task<std::shared_ptr<Object>> MeApi::listSubcategories(utility::string_t parentID, utility::string_t depth, utility::string_t search, utility::string_t searchOn, utility::string_t sortBy, int32_t page, int32_t pageSize)
{
    
    
    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/me/categories/{parentID}/categories");
    boost::replace_all(path, U("{") U("parentID") U("}"), ApiClient::parameterToString(parentID));
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
        
    utility::string_t responseHttpContentType;
    
    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 || responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata 
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("MeApi->listSubcategories does not produce any supported media type"));
    }    
    
    headerParams[U("Accept")] = responseHttpContentType;
    
    std::unordered_set<utility::string_t> consumeHttpContentTypes;
        
    
    {
        
    }
    
    {
        queryParams[U("depth")] = ApiClient::parameterToString(depth);
        
    }
    
    {
        queryParams[U("search")] = ApiClient::parameterToString(search);
        
    }
    
    {
        queryParams[U("searchOn")] = ApiClient::parameterToString(searchOn);
        
    }
    
    {
        queryParams[U("sortBy")] = ApiClient::parameterToString(sortBy);
        
    }
    
    {
        queryParams[U("page")] = ApiClient::parameterToString(page);
        
    }
    
    {
        queryParams[U("pageSize")] = ApiClient::parameterToString(pageSize);
        
    }
    

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;
   
    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");

    }
    // multipart formdata 
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
        
    }
    else
    {
        throw ApiException(415, U("MeApi->listSubcategories does not consume any supported media type"));
    }    
    
    // authentication (auth) required
    // oauth2 authentication is added automatically as part of the http_client_config
    
    return m_ApiClient->callApi(path, U("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
		// 1xx - informational : OK
		// 2xx - successful	   : OK
		// 3xx - redirection   : OK 
		// 4xx - client error  : not OK
		// 5xx - client error  : not OK
		if (response.status_code() >= 400)
		{
			throw ApiException(response.status_code()
				, U("error calling listSubcategories: ") + response.reason_phrase()
				, std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
		}
        
        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling listSubcategories: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }
        
        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<Object> result(nullptr);
        
        if(responseHttpContentType == U("application/json"))
        {
            web::json::value json = web::json::value::parse(response);
            
            result->fromJson(json);
        }
        // else if(responseHttpContentType == U("multipart/form-data"))
        // {
        // TODO multipart response parsing    
        // }
        else 
        {
			throw ApiException(500
				, U("error calling findPetsByStatus: unsupported response type"));
        }
        
        return result;
    });            
}
pplx::task<std::shared_ptr<Object>> MeApi::listUserGroups(utility::string_t search, utility::string_t searchOn, utility::string_t sortBy, int32_t page, int32_t pageSize)
{
    
    
    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/me/usergroups");
        
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
        
    utility::string_t responseHttpContentType;
    
    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 || responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata 
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("MeApi->listUserGroups does not produce any supported media type"));
    }    
    
    headerParams[U("Accept")] = responseHttpContentType;
    
    std::unordered_set<utility::string_t> consumeHttpContentTypes;
        
    
    {
        queryParams[U("search")] = ApiClient::parameterToString(search);
        
    }
    
    {
        queryParams[U("searchOn")] = ApiClient::parameterToString(searchOn);
        
    }
    
    {
        queryParams[U("sortBy")] = ApiClient::parameterToString(sortBy);
        
    }
    
    {
        queryParams[U("page")] = ApiClient::parameterToString(page);
        
    }
    
    {
        queryParams[U("pageSize")] = ApiClient::parameterToString(pageSize);
        
    }
    

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;
   
    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");

    }
    // multipart formdata 
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
        
    }
    else
    {
        throw ApiException(415, U("MeApi->listUserGroups does not consume any supported media type"));
    }    
    
    // authentication (auth) required
    // oauth2 authentication is added automatically as part of the http_client_config
    
    return m_ApiClient->callApi(path, U("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
		// 1xx - informational : OK
		// 2xx - successful	   : OK
		// 3xx - redirection   : OK 
		// 4xx - client error  : not OK
		// 5xx - client error  : not OK
		if (response.status_code() >= 400)
		{
			throw ApiException(response.status_code()
				, U("error calling listUserGroups: ") + response.reason_phrase()
				, std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
		}
        
        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling listUserGroups: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }
        
        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<Object> result(nullptr);
        
        if(responseHttpContentType == U("application/json"))
        {
            web::json::value json = web::json::value::parse(response);
            
            result->fromJson(json);
        }
        // else if(responseHttpContentType == U("multipart/form-data"))
        // {
        // TODO multipart response parsing    
        // }
        else 
        {
			throw ApiException(500
				, U("error calling findPetsByStatus: unsupported response type"));
        }
        
        return result;
    });            
}
pplx::task<std::shared_ptr<Object>> MeApi::patch(std::shared_ptr<User> user)
{
    
    // verify the required parameter 'user' is set
    if (user == nullptr)
    {
        throw ApiException(400, U("Missing required parameter 'user' when calling MeApi->patch"));
    }
    
    
    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/me");
        
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
        
    utility::string_t responseHttpContentType;
    
    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 || responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata 
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("MeApi->patch does not produce any supported media type"));
    }    
    
    headerParams[U("Accept")] = responseHttpContentType;
    
    std::unordered_set<utility::string_t> consumeHttpContentTypes;
        
    

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;
   
    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");

        web::json::value json;
 
        json = ModelBase::toJson(user);
        
        
        httpBody = std::shared_ptr<IHttpBody>( new JsonBody( json ) );
        
    }
    // multipart formdata 
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
        
        std::shared_ptr<MultipartFormData> multipart(new MultipartFormData);
        
        if(user.get())
        {
            user->toMultipart(multipart, U("user"));
        }
        

        httpBody = multipart;
        requestHttpContentType += U("; boundary=") + multipart->getBoundary();
    }
    else
    {
        throw ApiException(415, U("MeApi->patch does not consume any supported media type"));
    }    
    
    // authentication (auth) required
    // oauth2 authentication is added automatically as part of the http_client_config
    
    return m_ApiClient->callApi(path, U("PATCH"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
		// 1xx - informational : OK
		// 2xx - successful	   : OK
		// 3xx - redirection   : OK 
		// 4xx - client error  : not OK
		// 5xx - client error  : not OK
		if (response.status_code() >= 400)
		{
			throw ApiException(response.status_code()
				, U("error calling patch: ") + response.reason_phrase()
				, std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
		}
        
        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling patch: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }
        
        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<Object> result(nullptr);
        
        if(responseHttpContentType == U("application/json"))
        {
            web::json::value json = web::json::value::parse(response);
            
            result->fromJson(json);
        }
        // else if(responseHttpContentType == U("multipart/form-data"))
        // {
        // TODO multipart response parsing    
        // }
        else 
        {
			throw ApiException(500
				, U("error calling findPetsByStatus: unsupported response type"));
        }
        
        return result;
    });            
}
pplx::task<void> MeApi::patchAddress(utility::string_t addressID, std::shared_ptr<BuyerAddress> address)
{
    
    // verify the required parameter 'address' is set
    if (address == nullptr)
    {
        throw ApiException(400, U("Missing required parameter 'address' when calling MeApi->patchAddress"));
    }
    
    
    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/me/addresses/{addressID}");
    boost::replace_all(path, U("{") U("addressID") U("}"), ApiClient::parameterToString(addressID));
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
        
    utility::string_t responseHttpContentType;
    
    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 || responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata 
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("MeApi->patchAddress does not produce any supported media type"));
    }    
    
    headerParams[U("Accept")] = responseHttpContentType;
    
    std::unordered_set<utility::string_t> consumeHttpContentTypes;
        
    
    {
        
    }
    

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;
   
    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");

        web::json::value json;
 
        json = ModelBase::toJson(address);
        
        
        httpBody = std::shared_ptr<IHttpBody>( new JsonBody( json ) );
        
    }
    // multipart formdata 
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
        
        std::shared_ptr<MultipartFormData> multipart(new MultipartFormData);
        
        if(address.get())
        {
            address->toMultipart(multipart, U("address"));
        }
        

        httpBody = multipart;
        requestHttpContentType += U("; boundary=") + multipart->getBoundary();
    }
    else
    {
        throw ApiException(415, U("MeApi->patchAddress does not consume any supported media type"));
    }    
    
    // authentication (auth) required
    // oauth2 authentication is added automatically as part of the http_client_config
    
    return m_ApiClient->callApi(path, U("PATCH"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
		// 1xx - informational : OK
		// 2xx - successful	   : OK
		// 3xx - redirection   : OK 
		// 4xx - client error  : not OK
		// 5xx - client error  : not OK
		if (response.status_code() >= 400)
		{
			throw ApiException(response.status_code()
				, U("error calling patchAddress: ") + response.reason_phrase()
				, std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
		}
        
        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling patchAddress: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }
        
        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        return void();
            });            
}
pplx::task<void> MeApi::patchCreditCard(utility::string_t creditcardID, std::shared_ptr<BuyerCreditCard> creditCard)
{
    
    // verify the required parameter 'creditCard' is set
    if (creditCard == nullptr)
    {
        throw ApiException(400, U("Missing required parameter 'creditCard' when calling MeApi->patchCreditCard"));
    }
    
    
    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/me/creditcards/{creditcardID}");
    boost::replace_all(path, U("{") U("creditcardID") U("}"), ApiClient::parameterToString(creditcardID));
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
        
    utility::string_t responseHttpContentType;
    
    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 || responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata 
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("MeApi->patchCreditCard does not produce any supported media type"));
    }    
    
    headerParams[U("Accept")] = responseHttpContentType;
    
    std::unordered_set<utility::string_t> consumeHttpContentTypes;
        
    
    {
        
    }
    

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;
   
    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");

        web::json::value json;
 
        json = ModelBase::toJson(creditCard);
        
        
        httpBody = std::shared_ptr<IHttpBody>( new JsonBody( json ) );
        
    }
    // multipart formdata 
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
        
        std::shared_ptr<MultipartFormData> multipart(new MultipartFormData);
        
        if(creditCard.get())
        {
            creditCard->toMultipart(multipart, U("creditCard"));
        }
        

        httpBody = multipart;
        requestHttpContentType += U("; boundary=") + multipart->getBoundary();
    }
    else
    {
        throw ApiException(415, U("MeApi->patchCreditCard does not consume any supported media type"));
    }    
    
    // authentication (auth) required
    // oauth2 authentication is added automatically as part of the http_client_config
    
    return m_ApiClient->callApi(path, U("PATCH"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
		// 1xx - informational : OK
		// 2xx - successful	   : OK
		// 3xx - redirection   : OK 
		// 4xx - client error  : not OK
		// 5xx - client error  : not OK
		if (response.status_code() >= 400)
		{
			throw ApiException(response.status_code()
				, U("error calling patchCreditCard: ") + response.reason_phrase()
				, std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
		}
        
        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling patchCreditCard: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }
        
        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        return void();
            });            
}
pplx::task<std::shared_ptr<Object>> MeApi::update(std::shared_ptr<User> user)
{
    
    // verify the required parameter 'user' is set
    if (user == nullptr)
    {
        throw ApiException(400, U("Missing required parameter 'user' when calling MeApi->update"));
    }
    
    
    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/me");
        
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
        
    utility::string_t responseHttpContentType;
    
    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 || responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata 
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("MeApi->update does not produce any supported media type"));
    }    
    
    headerParams[U("Accept")] = responseHttpContentType;
    
    std::unordered_set<utility::string_t> consumeHttpContentTypes;
        
    

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;
   
    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");

        web::json::value json;
 
        json = ModelBase::toJson(user);
        
        
        httpBody = std::shared_ptr<IHttpBody>( new JsonBody( json ) );
        
    }
    // multipart formdata 
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
        
        std::shared_ptr<MultipartFormData> multipart(new MultipartFormData);
        
        if(user.get())
        {
            user->toMultipart(multipart, U("user"));
        }
        

        httpBody = multipart;
        requestHttpContentType += U("; boundary=") + multipart->getBoundary();
    }
    else
    {
        throw ApiException(415, U("MeApi->update does not consume any supported media type"));
    }    
    
    // authentication (auth) required
    // oauth2 authentication is added automatically as part of the http_client_config
    
    return m_ApiClient->callApi(path, U("PUT"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
		// 1xx - informational : OK
		// 2xx - successful	   : OK
		// 3xx - redirection   : OK 
		// 4xx - client error  : not OK
		// 5xx - client error  : not OK
		if (response.status_code() >= 400)
		{
			throw ApiException(response.status_code()
				, U("error calling update: ") + response.reason_phrase()
				, std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
		}
        
        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling update: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }
        
        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<Object> result(nullptr);
        
        if(responseHttpContentType == U("application/json"))
        {
            web::json::value json = web::json::value::parse(response);
            
            result->fromJson(json);
        }
        // else if(responseHttpContentType == U("multipart/form-data"))
        // {
        // TODO multipart response parsing    
        // }
        else 
        {
			throw ApiException(500
				, U("error calling findPetsByStatus: unsupported response type"));
        }
        
        return result;
    });            
}
pplx::task<std::shared_ptr<Object>> MeApi::updateAddress(utility::string_t addressID, std::shared_ptr<BuyerAddress> address)
{
    
    // verify the required parameter 'address' is set
    if (address == nullptr)
    {
        throw ApiException(400, U("Missing required parameter 'address' when calling MeApi->updateAddress"));
    }
    
    
    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/me/addresses/{addressID}");
    boost::replace_all(path, U("{") U("addressID") U("}"), ApiClient::parameterToString(addressID));
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
        
    utility::string_t responseHttpContentType;
    
    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 || responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata 
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("MeApi->updateAddress does not produce any supported media type"));
    }    
    
    headerParams[U("Accept")] = responseHttpContentType;
    
    std::unordered_set<utility::string_t> consumeHttpContentTypes;
        
    
    {
        
    }
    

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;
   
    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");

        web::json::value json;
 
        json = ModelBase::toJson(address);
        
        
        httpBody = std::shared_ptr<IHttpBody>( new JsonBody( json ) );
        
    }
    // multipart formdata 
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
        
        std::shared_ptr<MultipartFormData> multipart(new MultipartFormData);
        
        if(address.get())
        {
            address->toMultipart(multipart, U("address"));
        }
        

        httpBody = multipart;
        requestHttpContentType += U("; boundary=") + multipart->getBoundary();
    }
    else
    {
        throw ApiException(415, U("MeApi->updateAddress does not consume any supported media type"));
    }    
    
    // authentication (auth) required
    // oauth2 authentication is added automatically as part of the http_client_config
    
    return m_ApiClient->callApi(path, U("PUT"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
		// 1xx - informational : OK
		// 2xx - successful	   : OK
		// 3xx - redirection   : OK 
		// 4xx - client error  : not OK
		// 5xx - client error  : not OK
		if (response.status_code() >= 400)
		{
			throw ApiException(response.status_code()
				, U("error calling updateAddress: ") + response.reason_phrase()
				, std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
		}
        
        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling updateAddress: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }
        
        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<Object> result(nullptr);
        
        if(responseHttpContentType == U("application/json"))
        {
            web::json::value json = web::json::value::parse(response);
            
            result->fromJson(json);
        }
        // else if(responseHttpContentType == U("multipart/form-data"))
        // {
        // TODO multipart response parsing    
        // }
        else 
        {
			throw ApiException(500
				, U("error calling findPetsByStatus: unsupported response type"));
        }
        
        return result;
    });            
}
pplx::task<std::shared_ptr<Object>> MeApi::updateCreditCard(utility::string_t creditcardID, std::shared_ptr<BuyerCreditCard> creditCard)
{
    
    // verify the required parameter 'creditCard' is set
    if (creditCard == nullptr)
    {
        throw ApiException(400, U("Missing required parameter 'creditCard' when calling MeApi->updateCreditCard"));
    }
    
    
    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/me/creditcards/{creditcardID}");
    boost::replace_all(path, U("{") U("creditcardID") U("}"), ApiClient::parameterToString(creditcardID));
    
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
        
    utility::string_t responseHttpContentType;
    
    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 || responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata 
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("MeApi->updateCreditCard does not produce any supported media type"));
    }    
    
    headerParams[U("Accept")] = responseHttpContentType;
    
    std::unordered_set<utility::string_t> consumeHttpContentTypes;
        
    
    {
        
    }
    

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;
   
    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");

        web::json::value json;
 
        json = ModelBase::toJson(creditCard);
        
        
        httpBody = std::shared_ptr<IHttpBody>( new JsonBody( json ) );
        
    }
    // multipart formdata 
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
        
        std::shared_ptr<MultipartFormData> multipart(new MultipartFormData);
        
        if(creditCard.get())
        {
            creditCard->toMultipart(multipart, U("creditCard"));
        }
        

        httpBody = multipart;
        requestHttpContentType += U("; boundary=") + multipart->getBoundary();
    }
    else
    {
        throw ApiException(415, U("MeApi->updateCreditCard does not consume any supported media type"));
    }    
    
    // authentication (auth) required
    // oauth2 authentication is added automatically as part of the http_client_config
    
    return m_ApiClient->callApi(path, U("PUT"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
		// 1xx - informational : OK
		// 2xx - successful	   : OK
		// 3xx - redirection   : OK 
		// 4xx - client error  : not OK
		// 5xx - client error  : not OK
		if (response.status_code() >= 400)
		{
			throw ApiException(response.status_code()
				, U("error calling updateCreditCard: ") + response.reason_phrase()
				, std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
		}
        
        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling updateCreditCard: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }
        
        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<Object> result(nullptr);
        
        if(responseHttpContentType == U("application/json"))
        {
            web::json::value json = web::json::value::parse(response);
            
            result->fromJson(json);
        }
        // else if(responseHttpContentType == U("multipart/form-data"))
        // {
        // TODO multipart response parsing    
        // }
        else 
        {
			throw ApiException(500
				, U("error calling findPetsByStatus: unsupported response type"));
        }
        
        return result;
    });            
}

}
}
}
}

