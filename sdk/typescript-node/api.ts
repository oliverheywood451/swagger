/**
 * OrderCloud
 * A full ecommerce backend as a service.
 *
 * OpenAPI spec version: 0.1
 * Contact: ordercloud@four51.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import request = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'https://api.ordercloud.io/v1';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */

export class Address {
    'iD': string;
    'companyName': string;
    'firstName': string;
    'lastName': string;
    'street1': string;
    'street2': string;
    'city': string;
    'state': string;
    'zip': string;
    'country': string;
    'phone': string;
    'addressName': string;
    'xp': any;
}

export class AddressAssignment {
    'addressID': string;
    'userID': string;
    'userGroupID': string;
    'isShipping': boolean;
    'isBilling': boolean;
}

export class ApprovalRule {
    'iD': string;
    'name': string;
    'description': string;
    'approvingGroupID': string;
    'ruleExpression': string;
    'scope': string;
    'scopeTimeUnit': string;
    'scopeTimeNumber': number;
    'scopeStartDate': Date;
    'expireAfterTimeUnit': string;
    'expireAfterNumber': number;
    'approveOnExpire': boolean;
    'xp': any;
}

export class Buyer {
    'iD': string;
    'name': string;
    'active': boolean;
    'xp': any;
}

export class BuyerAddress {
    'shipping': boolean;
    'billing': boolean;
    'companyName': string;
    'firstName': string;
    'lastName': string;
    'street1': string;
    'street2': string;
    'city': string;
    'state': string;
    'zip': string;
    'country': string;
    'phone': string;
    'addressName': string;
    'xp': any;
}

export class BuyerCreditCard {
    'token': string;
    'cardType': string;
    'partialAccountNumber': string;
    'cardholderName': string;
    'expirationDate': Date;
    'xp': any;
}

export class Category {
    'iD': string;
    'name': string;
    'description': string;
    'xp': any;
    'listOrder': number;
    'active': boolean;
    'parentID': string;
}

export class CategoryAssignment {
    'categoryID': string;
    'userID': string;
    'userGroupID': string;
}

export class CategoryProductAssignment {
    'categoryID': string;
    'productID': string;
    'listOrder': number;
}

export class CostCenter {
    'iD': string;
    'name': string;
    'description': string;
    'xp': any;
}

export class CostCenterAssignment {
    'costCenterID': string;
    'userID': string;
    'userGroupID': string;
}

export class CreditCard {
    'iD': string;
    'token': string;
    'cardType': string;
    'partialAccountNumber': string;
    'cardholderName': string;
    'expirationDate': Date;
    'xp': any;
}

export class CreditCardAssignment {
    'creditCardID': string;
    'userID': string;
    'userGroupID': string;
}

export class EmailTemplate {
    'subject': string;
    'body': string;
    'replyEmail': string;
    'sendMessageType': boolean;
    'emailFormatType': string;
}

export class ImpersonateTokenRequest {
    'clientID': string;
    'claims': Array<ShipmentItem>;
}

export class LineItem {
    'iD': string;
    'productID': string;
    'quantity': number;
    'unitPrice': number;
    'costCenter': string;
    'dateNeeded': Date;
    'shippingAccount': string;
    'shippingAddressID': string;
    'shipfromAddressID': string;
    'shipperID': string;
    'specs': Array<ShipmentItem>;
    'xp': any;
}

export class Order {
    'iD': string;
    'type': string;
    'fromUserID': string;
    'billingAddressID': string;
    'shippingAddressID': string;
    'comments': string;
    'shippingCost': number;
    'taxCost': number;
    'xp': any;
}

export class Partial1 {
    'iD': string;
    'username': string;
    'password': string;
    'firstName': string;
    'lastName': string;
    'email': string;
    'phone': string;
    'termsAccepted': Date;
    'active': boolean;
    'xp': any;
    'securityProfileID': string;
}

export class PasswordReset {
    'clientID': string;
    'username': string;
    'password': string;
}

export class PasswordResetRequest {
    'clientID': string;
    'email': string;
    'username': string;
    'uRL': string;
}

export class Payment {
    'iD': string;
    'type': string;
    'creditCardID': string;
    'spendingAccountID': string;
    'description': string;
    'amount': number;
    'xp': any;
}

export class PaymentTransaction {
    'iD': string;
    'type': string;
    'dateExecuted': Date;
    'amount': number;
    'succeeded': boolean;
    'resultCode': string;
    'resultMessage': string;
    'xp': any;
}

export class PriceBreak {
    'quantity': number;
    'price': number;
}

export class PriceSchedule {
    'iD': string;
    'name': string;
    'applyTax': boolean;
    'applyShipping': boolean;
    'maxQuantity': number;
    'useCumulativeQuantity': boolean;
    'restrictedQuantity': boolean;
    'orderType': string;
    'priceBreaks': Array<ShipmentItem>;
    'xp': any;
}

export class Product {
    'iD': string;
    'name': string;
    'description': string;
    'quantityMultiplier': number;
    'shipWeight': number;
    'active': boolean;
    'type': string;
    'inventoryEnabled': boolean;
    'inventoryNotificationPoint': number;
    'variantLevelInventory': boolean;
    'xp': any;
    'allowOrderExceedInventory': boolean;
    'inventoryVisible': boolean;
}

export class ProductAssignment {
    'productID': string;
    'standardPriceScheduleID': string;
    'replenishmentPriceScheduleID': string;
    'userID': string;
    'userGroupID': string;
    'buyerID': string;
}

export class Promotion {
    'iD': string;
    'code': string;
    'name': string;
    'usagesRemaining': number;
    'description': string;
    'finePrint': string;
    'startDate': Date;
    'expirationDate': Date;
    'eligibleExpression': string;
    'valueExpression': string;
    'canCombine': boolean;
    'xp': any;
}

export class PromotionAssignment {
    'promotionID': string;
    'buyerID': string;
    'userID': string;
    'userGroupID': string;
}

export class Shipment {
    'iD': string;
    'shipper': string;
    'dateShipped': Date;
    'trackingNumber': string;
    'cost': number;
    'items': Array<ShipmentItem>;
    'xp': any;
}

export class ShipmentItem {
    'orderID': string;
    'lineItemID': string;
    'quantityShipped': number;
}

export class Spec {
    'iD': string;
    'listOrder': number;
    'name': string;
    'defaultValue': string;
    'required': boolean;
    'allowOpenText': boolean;
    'defaultOptionID': string;
    'xp': any;
}

export class SpecOption {
    'iD': string;
    'value': string;
    'listOrder': number;
    'isOpenText': boolean;
    'priceMarkupType': string;
    'priceMarkup': number;
    'xp': any;
}

export class SpecProductAssignment {
    'specID': string;
    'productID': string;
    'definesVariant': boolean;
}

export class SpendingAccount {
    'iD': string;
    'name': string;
    'balance': number;
    'allowAsPaymentMethod': boolean;
    'redemptionCode': string;
    'startDate': Date;
    'endDate': Date;
    'xp': any;
}

export class SpendingAccountAssignment {
    'spendingAccountID': string;
    'userID': string;
    'userGroupID': string;
    'allowExceed': boolean;
}

export class User {
    'iD': string;
    'username': string;
    'password': string;
    'firstName': string;
    'lastName': string;
    'email': string;
    'phone': string;
    'termsAccepted': Date;
    'active': boolean;
    'xp': any;
    'securityProfileID': string;
}

export class UserGroup {
    'iD': string;
    'name': string;
    'description': string;
    'xp': any;
}

export class UserGroupAssignment {
    'userGroupID': string;
    'userID': string;
}

export class Variant {
    'iD': string;
    'name': string;
    'description': string;
    'active': boolean;
    'xp': any;
}


export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: request.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string;

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: request.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header") {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string;

    applyToRequest(requestOptions: request.Options): void {
        requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
    }
}

export class VoidAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void {
        // Do nothing
    }
}

export enum AddressApiApiKeys {
}

export class AddressApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'auth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: AddressApiApiKeys, value: string) {
        this.authentications[AddressApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.auth.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param addressID ID of the address.
     */
    public _delete (buyerID: string, addressID: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/addresses/{addressID}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'addressID' + '}', String(addressID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling _delete.');
        }

        // verify required parameter 'addressID' is not null or undefined
        if (addressID === null || addressID === undefined) {
            throw new Error('Required parameter addressID was null or undefined when calling _delete.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param address 
     */
    public create (buyerID: string, address: Address) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/addresses'
            .replace('{' + 'buyerID' + '}', String(buyerID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling create.');
        }

        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
            throw new Error('Required parameter address was null or undefined when calling create.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: address,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param addressID ID of the address.
     * @param userID ID of the user.
     * @param userGroupID ID of the user group.
     */
    public deleteAssignment (buyerID: string, addressID: string, userID?: string, userGroupID?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/addresses/{addressID}/assignments'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'addressID' + '}', String(addressID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling deleteAssignment.');
        }

        // verify required parameter 'addressID' is not null or undefined
        if (addressID === null || addressID === undefined) {
            throw new Error('Required parameter addressID was null or undefined when calling deleteAssignment.');
        }

        if (userID !== undefined) {
            queryParameters['userID'] = userID;
        }

        if (userGroupID !== undefined) {
            queryParameters['userGroupID'] = userGroupID;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param addressID ID of the address.
     */
    public get (buyerID: string, addressID: string) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/addresses/{addressID}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'addressID' + '}', String(addressID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling get.');
        }

        // verify required parameter 'addressID' is not null or undefined
        if (addressID === null || addressID === undefined) {
            throw new Error('Required parameter addressID was null or undefined when calling get.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public list (buyerID: string, search?: string, searchOn?: string, sortBy?: string, page?: number, pageSize?: number) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/addresses'
            .replace('{' + 'buyerID' + '}', String(buyerID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling list.');
        }

        if (search !== undefined) {
            queryParameters['search'] = search;
        }

        if (searchOn !== undefined) {
            queryParameters['searchOn'] = searchOn;
        }

        if (sortBy !== undefined) {
            queryParameters['sortBy'] = sortBy;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param addressID ID of the address.
     * @param userID ID of the user.
     * @param userGroupID ID of the user group.
     * @param level Level of the address.
     * @param isShipping Is shipping of the address.
     * @param isBilling Is billing of the address.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public listAssignments (buyerID: string, addressID?: string, userID?: string, userGroupID?: string, level?: string, isShipping?: boolean, isBilling?: boolean, page?: number, pageSize?: number) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/addresses/assignments'
            .replace('{' + 'buyerID' + '}', String(buyerID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling listAssignments.');
        }

        if (addressID !== undefined) {
            queryParameters['addressID'] = addressID;
        }

        if (userID !== undefined) {
            queryParameters['userID'] = userID;
        }

        if (userGroupID !== undefined) {
            queryParameters['userGroupID'] = userGroupID;
        }

        if (level !== undefined) {
            queryParameters['level'] = level;
        }

        if (isShipping !== undefined) {
            queryParameters['isShipping'] = isShipping;
        }

        if (isBilling !== undefined) {
            queryParameters['isBilling'] = isBilling;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param addressID ID of the address.
     * @param address 
     */
    public patch (buyerID: string, addressID: string, address: Address) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/addresses/{addressID}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'addressID' + '}', String(addressID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling patch.');
        }

        // verify required parameter 'addressID' is not null or undefined
        if (addressID === null || addressID === undefined) {
            throw new Error('Required parameter addressID was null or undefined when calling patch.');
        }

        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
            throw new Error('Required parameter address was null or undefined when calling patch.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: address,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param assignment 
     */
    public saveAssignment (buyerID: string, assignment: AddressAssignment) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/addresses/assignments'
            .replace('{' + 'buyerID' + '}', String(buyerID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling saveAssignment.');
        }

        // verify required parameter 'assignment' is not null or undefined
        if (assignment === null || assignment === undefined) {
            throw new Error('Required parameter assignment was null or undefined when calling saveAssignment.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: assignment,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param addressID ID of the address.
     * @param address 
     */
    public update (buyerID: string, addressID: string, address: Address) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/addresses/{addressID}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'addressID' + '}', String(addressID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling update.');
        }

        // verify required parameter 'addressID' is not null or undefined
        if (addressID === null || addressID === undefined) {
            throw new Error('Required parameter addressID was null or undefined when calling update.');
        }

        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
            throw new Error('Required parameter address was null or undefined when calling update.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: address,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AdminUserApiApiKeys {
}

export class AdminUserApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'auth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: AdminUserApiApiKeys, value: string) {
        this.authentications[AdminUserApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.auth.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * 
     * 
     * @param userID ID of the user.
     */
    public _delete (userID: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/adminusers/{userID}'
            .replace('{' + 'userID' + '}', String(userID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userID' is not null or undefined
        if (userID === null || userID === undefined) {
            throw new Error('Required parameter userID was null or undefined when calling _delete.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param user 
     */
    public create (user: User) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/adminusers';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'user' is not null or undefined
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling create.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: user,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param userID ID of the user.
     */
    public get (userID: string) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/adminusers/{userID}'
            .replace('{' + 'userID' + '}', String(userID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userID' is not null or undefined
        if (userID === null || userID === undefined) {
            throw new Error('Required parameter userID was null or undefined when calling get.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public list (search?: string, searchOn?: string, sortBy?: string, page?: number, pageSize?: number) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/adminusers';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (search !== undefined) {
            queryParameters['search'] = search;
        }

        if (searchOn !== undefined) {
            queryParameters['searchOn'] = searchOn;
        }

        if (sortBy !== undefined) {
            queryParameters['sortBy'] = sortBy;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param userID ID of the user.
     * @param user 
     */
    public patch (userID: string, user: User) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/adminusers/{userID}'
            .replace('{' + 'userID' + '}', String(userID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userID' is not null or undefined
        if (userID === null || userID === undefined) {
            throw new Error('Required parameter userID was null or undefined when calling patch.');
        }

        // verify required parameter 'user' is not null or undefined
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling patch.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: user,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param userID ID of the user.
     * @param user 
     */
    public update (userID: string, user: User) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/adminusers/{userID}'
            .replace('{' + 'userID' + '}', String(userID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userID' is not null or undefined
        if (userID === null || userID === undefined) {
            throw new Error('Required parameter userID was null or undefined when calling update.');
        }

        // verify required parameter 'user' is not null or undefined
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling update.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: user,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ApprovalRuleApiApiKeys {
}

export class ApprovalRuleApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'auth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: ApprovalRuleApiApiKeys, value: string) {
        this.authentications[ApprovalRuleApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.auth.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param approvalRuleID ID of the approval rule.
     */
    public _delete (buyerID: string, approvalRuleID: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/approvalrules/{approvalRuleID}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'approvalRuleID' + '}', String(approvalRuleID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling _delete.');
        }

        // verify required parameter 'approvalRuleID' is not null or undefined
        if (approvalRuleID === null || approvalRuleID === undefined) {
            throw new Error('Required parameter approvalRuleID was null or undefined when calling _delete.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param approvalRule 
     */
    public create (buyerID: string, approvalRule: ApprovalRule) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/approvalrules'
            .replace('{' + 'buyerID' + '}', String(buyerID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling create.');
        }

        // verify required parameter 'approvalRule' is not null or undefined
        if (approvalRule === null || approvalRule === undefined) {
            throw new Error('Required parameter approvalRule was null or undefined when calling create.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: approvalRule,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param approvalRuleID ID of the approval rule.
     */
    public get (buyerID: string, approvalRuleID: string) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/approvalrules/{approvalRuleID}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'approvalRuleID' + '}', String(approvalRuleID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling get.');
        }

        // verify required parameter 'approvalRuleID' is not null or undefined
        if (approvalRuleID === null || approvalRuleID === undefined) {
            throw new Error('Required parameter approvalRuleID was null or undefined when calling get.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public list (buyerID: string, search?: string, searchOn?: string, sortBy?: string, page?: number, pageSize?: number) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/approvalrules'
            .replace('{' + 'buyerID' + '}', String(buyerID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling list.');
        }

        if (search !== undefined) {
            queryParameters['search'] = search;
        }

        if (searchOn !== undefined) {
            queryParameters['searchOn'] = searchOn;
        }

        if (sortBy !== undefined) {
            queryParameters['sortBy'] = sortBy;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param approvalRuleID ID of the approval rule.
     * @param partialApprovalRule 
     */
    public patch (buyerID: string, approvalRuleID: string, partialApprovalRule: ApprovalRule) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/approvalrules/{approvalRuleID}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'approvalRuleID' + '}', String(approvalRuleID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling patch.');
        }

        // verify required parameter 'approvalRuleID' is not null or undefined
        if (approvalRuleID === null || approvalRuleID === undefined) {
            throw new Error('Required parameter approvalRuleID was null or undefined when calling patch.');
        }

        // verify required parameter 'partialApprovalRule' is not null or undefined
        if (partialApprovalRule === null || partialApprovalRule === undefined) {
            throw new Error('Required parameter partialApprovalRule was null or undefined when calling patch.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: partialApprovalRule,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param approvalRuleID ID of the approval rule.
     * @param approvalRule 
     */
    public update (buyerID: string, approvalRuleID: string, approvalRule: ApprovalRule) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/approvalrules/{approvalRuleID}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'approvalRuleID' + '}', String(approvalRuleID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling update.');
        }

        // verify required parameter 'approvalRuleID' is not null or undefined
        if (approvalRuleID === null || approvalRuleID === undefined) {
            throw new Error('Required parameter approvalRuleID was null or undefined when calling update.');
        }

        // verify required parameter 'approvalRule' is not null or undefined
        if (approvalRule === null || approvalRule === undefined) {
            throw new Error('Required parameter approvalRule was null or undefined when calling update.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: approvalRule,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum BuyerApiApiKeys {
}

export class BuyerApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'auth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: BuyerApiApiKeys, value: string) {
        this.authentications[BuyerApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.auth.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     */
    public _delete (buyerID: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}'
            .replace('{' + 'buyerID' + '}', String(buyerID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling _delete.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param company 
     */
    public create (company: Buyer) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'company' is not null or undefined
        if (company === null || company === undefined) {
            throw new Error('Required parameter company was null or undefined when calling create.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: company,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     */
    public get (buyerID: string) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}'
            .replace('{' + 'buyerID' + '}', String(buyerID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling get.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param search Word or phrase to search for.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public list (search?: string, page?: number, pageSize?: number) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (search !== undefined) {
            queryParameters['search'] = search;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param company 
     */
    public update (buyerID: string, company: Buyer) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}'
            .replace('{' + 'buyerID' + '}', String(buyerID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling update.');
        }

        // verify required parameter 'company' is not null or undefined
        if (company === null || company === undefined) {
            throw new Error('Required parameter company was null or undefined when calling update.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: company,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CategoryApiApiKeys {
}

export class CategoryApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'auth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: CategoryApiApiKeys, value: string) {
        this.authentications[CategoryApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.auth.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param categoryID ID of the category.
     */
    public _delete (buyerID: string, categoryID: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/categories/{categoryID}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'categoryID' + '}', String(categoryID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling _delete.');
        }

        // verify required parameter 'categoryID' is not null or undefined
        if (categoryID === null || categoryID === undefined) {
            throw new Error('Required parameter categoryID was null or undefined when calling _delete.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param category 
     */
    public create (buyerID: string, category: Category) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/categories'
            .replace('{' + 'buyerID' + '}', String(buyerID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling create.');
        }

        // verify required parameter 'category' is not null or undefined
        if (category === null || category === undefined) {
            throw new Error('Required parameter category was null or undefined when calling create.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: category,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param categoryID ID of the category.
     * @param userID ID of the user.
     * @param userGroupID ID of the user group.
     */
    public deleteAssignment (buyerID: string, categoryID: string, userID?: string, userGroupID?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/categories/{categoryID}/assignments'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'categoryID' + '}', String(categoryID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling deleteAssignment.');
        }

        // verify required parameter 'categoryID' is not null or undefined
        if (categoryID === null || categoryID === undefined) {
            throw new Error('Required parameter categoryID was null or undefined when calling deleteAssignment.');
        }

        if (userID !== undefined) {
            queryParameters['userID'] = userID;
        }

        if (userGroupID !== undefined) {
            queryParameters['userGroupID'] = userGroupID;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param categoryID ID of the category.
     * @param productID ID of the product.
     */
    public deleteProductAssignment (buyerID: string, categoryID: string, productID: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/categories/{categoryID}/productassignments/{productID}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'categoryID' + '}', String(categoryID))
            .replace('{' + 'productID' + '}', String(productID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling deleteProductAssignment.');
        }

        // verify required parameter 'categoryID' is not null or undefined
        if (categoryID === null || categoryID === undefined) {
            throw new Error('Required parameter categoryID was null or undefined when calling deleteProductAssignment.');
        }

        // verify required parameter 'productID' is not null or undefined
        if (productID === null || productID === undefined) {
            throw new Error('Required parameter productID was null or undefined when calling deleteProductAssignment.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param categoryID ID of the category.
     */
    public get (buyerID: string, categoryID: string) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/categories/{categoryID}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'categoryID' + '}', String(categoryID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling get.');
        }

        // verify required parameter 'categoryID' is not null or undefined
        if (categoryID === null || categoryID === undefined) {
            throw new Error('Required parameter categoryID was null or undefined when calling get.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param parentID ID of the parent.
     * @param depth Depth of the category.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public list (buyerID: string, parentID?: string, depth?: string, search?: string, searchOn?: string, sortBy?: string, page?: number, pageSize?: number) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/categories'
            .replace('{' + 'buyerID' + '}', String(buyerID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling list.');
        }

        if (parentID !== undefined) {
            queryParameters['parentID'] = parentID;
        }

        if (depth !== undefined) {
            queryParameters['depth'] = depth;
        }

        if (search !== undefined) {
            queryParameters['search'] = search;
        }

        if (searchOn !== undefined) {
            queryParameters['searchOn'] = searchOn;
        }

        if (sortBy !== undefined) {
            queryParameters['sortBy'] = sortBy;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param categoryID ID of the category.
     * @param userID ID of the user.
     * @param userGroupID ID of the user group.
     * @param level Level of the category.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public listAssignments (buyerID: string, categoryID?: string, userID?: string, userGroupID?: string, level?: string, page?: number, pageSize?: number) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/categories/assignments'
            .replace('{' + 'buyerID' + '}', String(buyerID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling listAssignments.');
        }

        if (categoryID !== undefined) {
            queryParameters['categoryID'] = categoryID;
        }

        if (userID !== undefined) {
            queryParameters['userID'] = userID;
        }

        if (userGroupID !== undefined) {
            queryParameters['userGroupID'] = userGroupID;
        }

        if (level !== undefined) {
            queryParameters['level'] = level;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param parentID ID of the parent.
     * @param search Word or phrase to search for.
     * @param depth Depth of the category.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public listChildren (buyerID: string, parentID: string, search?: string, depth?: string, page?: number, pageSize?: number) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/categories/{parentID}/categories'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'parentID' + '}', String(parentID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling listChildren.');
        }

        // verify required parameter 'parentID' is not null or undefined
        if (parentID === null || parentID === undefined) {
            throw new Error('Required parameter parentID was null or undefined when calling listChildren.');
        }

        if (search !== undefined) {
            queryParameters['search'] = search;
        }

        if (depth !== undefined) {
            queryParameters['depth'] = depth;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param categoryID ID of the category.
     * @param productID ID of the product.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public listProductAssignments (buyerID: string, categoryID?: string, productID?: string, page?: number, pageSize?: number) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/categories/productassignments'
            .replace('{' + 'buyerID' + '}', String(buyerID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling listProductAssignments.');
        }

        if (categoryID !== undefined) {
            queryParameters['categoryID'] = categoryID;
        }

        if (productID !== undefined) {
            queryParameters['productID'] = productID;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param categoryID ID of the category.
     * @param category 
     */
    public patch (buyerID: string, categoryID: string, category: Category) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/categories/{categoryID}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'categoryID' + '}', String(categoryID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling patch.');
        }

        // verify required parameter 'categoryID' is not null or undefined
        if (categoryID === null || categoryID === undefined) {
            throw new Error('Required parameter categoryID was null or undefined when calling patch.');
        }

        // verify required parameter 'category' is not null or undefined
        if (category === null || category === undefined) {
            throw new Error('Required parameter category was null or undefined when calling patch.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: category,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param categoryAssignment 
     */
    public saveAssignment (buyerID: string, categoryAssignment: CategoryAssignment) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/categories/assignments'
            .replace('{' + 'buyerID' + '}', String(buyerID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling saveAssignment.');
        }

        // verify required parameter 'categoryAssignment' is not null or undefined
        if (categoryAssignment === null || categoryAssignment === undefined) {
            throw new Error('Required parameter categoryAssignment was null or undefined when calling saveAssignment.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: categoryAssignment,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param productAssignment 
     */
    public saveProductAssignment (buyerID: string, productAssignment: CategoryProductAssignment) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/categories/productassignments'
            .replace('{' + 'buyerID' + '}', String(buyerID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling saveProductAssignment.');
        }

        // verify required parameter 'productAssignment' is not null or undefined
        if (productAssignment === null || productAssignment === undefined) {
            throw new Error('Required parameter productAssignment was null or undefined when calling saveProductAssignment.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: productAssignment,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param categoryID ID of the category.
     * @param category 
     */
    public update (buyerID: string, categoryID: string, category: Category) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/categories/{categoryID}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'categoryID' + '}', String(categoryID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling update.');
        }

        // verify required parameter 'categoryID' is not null or undefined
        if (categoryID === null || categoryID === undefined) {
            throw new Error('Required parameter categoryID was null or undefined when calling update.');
        }

        // verify required parameter 'category' is not null or undefined
        if (category === null || category === undefined) {
            throw new Error('Required parameter category was null or undefined when calling update.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: category,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CostCenterApiApiKeys {
}

export class CostCenterApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'auth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: CostCenterApiApiKeys, value: string) {
        this.authentications[CostCenterApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.auth.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param costCenterID ID of the cost center.
     */
    public _delete (buyerID: string, costCenterID: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/costcenters/{costCenterID}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'costCenterID' + '}', String(costCenterID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling _delete.');
        }

        // verify required parameter 'costCenterID' is not null or undefined
        if (costCenterID === null || costCenterID === undefined) {
            throw new Error('Required parameter costCenterID was null or undefined when calling _delete.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param costCenter 
     */
    public create (buyerID: string, costCenter: CostCenter) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/costcenters'
            .replace('{' + 'buyerID' + '}', String(buyerID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling create.');
        }

        // verify required parameter 'costCenter' is not null or undefined
        if (costCenter === null || costCenter === undefined) {
            throw new Error('Required parameter costCenter was null or undefined when calling create.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: costCenter,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param costCenterID ID of the cost center.
     * @param userID ID of the user.
     * @param userGroupID ID of the user group.
     */
    public deleteAssignment (buyerID: string, costCenterID: string, userID?: string, userGroupID?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/costcenters/{costCenterID}/assignments'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'costCenterID' + '}', String(costCenterID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling deleteAssignment.');
        }

        // verify required parameter 'costCenterID' is not null or undefined
        if (costCenterID === null || costCenterID === undefined) {
            throw new Error('Required parameter costCenterID was null or undefined when calling deleteAssignment.');
        }

        if (userID !== undefined) {
            queryParameters['userID'] = userID;
        }

        if (userGroupID !== undefined) {
            queryParameters['userGroupID'] = userGroupID;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param costCenterID ID of the cost center.
     */
    public get (buyerID: string, costCenterID: string) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/costcenters/{costCenterID}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'costCenterID' + '}', String(costCenterID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling get.');
        }

        // verify required parameter 'costCenterID' is not null or undefined
        if (costCenterID === null || costCenterID === undefined) {
            throw new Error('Required parameter costCenterID was null or undefined when calling get.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public list (buyerID: string, search?: string, searchOn?: string, sortBy?: string, page?: number, pageSize?: number) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/costcenters'
            .replace('{' + 'buyerID' + '}', String(buyerID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling list.');
        }

        if (search !== undefined) {
            queryParameters['search'] = search;
        }

        if (searchOn !== undefined) {
            queryParameters['searchOn'] = searchOn;
        }

        if (sortBy !== undefined) {
            queryParameters['sortBy'] = sortBy;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param costCenterID ID of the cost center.
     * @param userID ID of the user.
     * @param userGroupID ID of the user group.
     * @param level Level of the cost center.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public listAssignments (buyerID: string, costCenterID?: string, userID?: string, userGroupID?: string, level?: string, page?: number, pageSize?: number) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/costcenters/assignments'
            .replace('{' + 'buyerID' + '}', String(buyerID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling listAssignments.');
        }

        if (costCenterID !== undefined) {
            queryParameters['costCenterID'] = costCenterID;
        }

        if (userID !== undefined) {
            queryParameters['userID'] = userID;
        }

        if (userGroupID !== undefined) {
            queryParameters['userGroupID'] = userGroupID;
        }

        if (level !== undefined) {
            queryParameters['level'] = level;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param costCenterID ID of the cost center.
     * @param costCenter 
     */
    public patch (buyerID: string, costCenterID: string, costCenter: CostCenter) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/costcenters/{costCenterID}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'costCenterID' + '}', String(costCenterID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling patch.');
        }

        // verify required parameter 'costCenterID' is not null or undefined
        if (costCenterID === null || costCenterID === undefined) {
            throw new Error('Required parameter costCenterID was null or undefined when calling patch.');
        }

        // verify required parameter 'costCenter' is not null or undefined
        if (costCenter === null || costCenter === undefined) {
            throw new Error('Required parameter costCenter was null or undefined when calling patch.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: costCenter,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param assignment 
     */
    public saveAssignment (buyerID: string, assignment: CostCenterAssignment) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/costcenters/assignments'
            .replace('{' + 'buyerID' + '}', String(buyerID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling saveAssignment.');
        }

        // verify required parameter 'assignment' is not null or undefined
        if (assignment === null || assignment === undefined) {
            throw new Error('Required parameter assignment was null or undefined when calling saveAssignment.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: assignment,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param costCenterID ID of the cost center.
     * @param costCenter 
     */
    public update (buyerID: string, costCenterID: string, costCenter: CostCenter) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/costcenters/{costCenterID}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'costCenterID' + '}', String(costCenterID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling update.');
        }

        // verify required parameter 'costCenterID' is not null or undefined
        if (costCenterID === null || costCenterID === undefined) {
            throw new Error('Required parameter costCenterID was null or undefined when calling update.');
        }

        // verify required parameter 'costCenter' is not null or undefined
        if (costCenter === null || costCenter === undefined) {
            throw new Error('Required parameter costCenter was null or undefined when calling update.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: costCenter,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CreditCardApiApiKeys {
}

export class CreditCardApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'auth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: CreditCardApiApiKeys, value: string) {
        this.authentications[CreditCardApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.auth.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param creditCardID ID of the credit card.
     */
    public _delete (buyerID: string, creditCardID: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/creditcards/{creditCardID}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'creditCardID' + '}', String(creditCardID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling _delete.');
        }

        // verify required parameter 'creditCardID' is not null or undefined
        if (creditCardID === null || creditCardID === undefined) {
            throw new Error('Required parameter creditCardID was null or undefined when calling _delete.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param card 
     */
    public create (buyerID: string, card: CreditCard) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/creditcards'
            .replace('{' + 'buyerID' + '}', String(buyerID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling create.');
        }

        // verify required parameter 'card' is not null or undefined
        if (card === null || card === undefined) {
            throw new Error('Required parameter card was null or undefined when calling create.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: card,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param creditCardID ID of the credit card.
     * @param userID ID of the user.
     * @param userGroupID ID of the user group.
     */
    public deleteAssignment (buyerID: string, creditCardID: string, userID?: string, userGroupID?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/creditcards/{creditCardID}/assignments'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'creditCardID' + '}', String(creditCardID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling deleteAssignment.');
        }

        // verify required parameter 'creditCardID' is not null or undefined
        if (creditCardID === null || creditCardID === undefined) {
            throw new Error('Required parameter creditCardID was null or undefined when calling deleteAssignment.');
        }

        if (userID !== undefined) {
            queryParameters['userID'] = userID;
        }

        if (userGroupID !== undefined) {
            queryParameters['userGroupID'] = userGroupID;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param creditCardID ID of the credit card.
     */
    public get (buyerID: string, creditCardID: string) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/creditcards/{creditCardID}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'creditCardID' + '}', String(creditCardID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling get.');
        }

        // verify required parameter 'creditCardID' is not null or undefined
        if (creditCardID === null || creditCardID === undefined) {
            throw new Error('Required parameter creditCardID was null or undefined when calling get.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public list (buyerID: string, search?: string, searchOn?: string, sortBy?: string, page?: number, pageSize?: number) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/creditcards'
            .replace('{' + 'buyerID' + '}', String(buyerID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling list.');
        }

        if (search !== undefined) {
            queryParameters['search'] = search;
        }

        if (searchOn !== undefined) {
            queryParameters['searchOn'] = searchOn;
        }

        if (sortBy !== undefined) {
            queryParameters['sortBy'] = sortBy;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param creditCardID ID of the credit card.
     * @param userID ID of the user.
     * @param userGroupID ID of the user group.
     * @param level Level of the credit card.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public listAssignments (buyerID: string, creditCardID?: string, userID?: string, userGroupID?: string, level?: string, page?: number, pageSize?: number) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/creditcards/assignments'
            .replace('{' + 'buyerID' + '}', String(buyerID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling listAssignments.');
        }

        if (creditCardID !== undefined) {
            queryParameters['creditCardID'] = creditCardID;
        }

        if (userID !== undefined) {
            queryParameters['userID'] = userID;
        }

        if (userGroupID !== undefined) {
            queryParameters['userGroupID'] = userGroupID;
        }

        if (level !== undefined) {
            queryParameters['level'] = level;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param creditCardID ID of the credit card.
     * @param card 
     */
    public patch (buyerID: string, creditCardID: string, card: CreditCard) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/creditcards/{creditCardID}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'creditCardID' + '}', String(creditCardID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling patch.');
        }

        // verify required parameter 'creditCardID' is not null or undefined
        if (creditCardID === null || creditCardID === undefined) {
            throw new Error('Required parameter creditCardID was null or undefined when calling patch.');
        }

        // verify required parameter 'card' is not null or undefined
        if (card === null || card === undefined) {
            throw new Error('Required parameter card was null or undefined when calling patch.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: card,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param assignment 
     */
    public saveAssignment (buyerID: string, assignment: CreditCardAssignment) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/creditcards/assignments'
            .replace('{' + 'buyerID' + '}', String(buyerID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling saveAssignment.');
        }

        // verify required parameter 'assignment' is not null or undefined
        if (assignment === null || assignment === undefined) {
            throw new Error('Required parameter assignment was null or undefined when calling saveAssignment.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: assignment,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param creditCardID ID of the credit card.
     * @param card 
     */
    public update (buyerID: string, creditCardID: string, card: CreditCard) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/creditcards/{creditCardID}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'creditCardID' + '}', String(creditCardID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling update.');
        }

        // verify required parameter 'creditCardID' is not null or undefined
        if (creditCardID === null || creditCardID === undefined) {
            throw new Error('Required parameter creditCardID was null or undefined when calling update.');
        }

        // verify required parameter 'card' is not null or undefined
        if (card === null || card === undefined) {
            throw new Error('Required parameter card was null or undefined when calling update.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: card,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EmailTemplateApiApiKeys {
}

export class EmailTemplateApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'auth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: EmailTemplateApiApiKeys, value: string) {
        this.authentications[EmailTemplateApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.auth.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param emailTemplateType Email template type of the email template. Possible values: OrderSubmittedForApproval, CustomerOrderSubmitted, OrderToApprove, OrderDeclined, OrderApproved, PriceRequestSubmitted, CustomerOrderShipped, ProductRequiresAttachment, InventoryPointReached, LineItemExceedsInventory, PriceRequestResponse, CustomerOrderUpdated, OrderCanceled, PriceRequestCanceled, NewOrderReceived, ApprovalNotification, EmailLoginVerificationCode.
     */
    public get (buyerID: string, emailTemplateType: string) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/emailtemplates/{emailTemplateType}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'emailTemplateType' + '}', String(emailTemplateType));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling get.');
        }

        // verify required parameter 'emailTemplateType' is not null or undefined
        if (emailTemplateType === null || emailTemplateType === undefined) {
            throw new Error('Required parameter emailTemplateType was null or undefined when calling get.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param emailTemplateType Email template type of the email template. Possible values: OrderSubmittedForApproval, CustomerOrderSubmitted, OrderToApprove, OrderDeclined, OrderApproved, PriceRequestSubmitted, CustomerOrderShipped, ProductRequiresAttachment, InventoryPointReached, LineItemExceedsInventory, PriceRequestResponse, CustomerOrderUpdated, OrderCanceled, PriceRequestCanceled, NewOrderReceived, ApprovalNotification, EmailLoginVerificationCode.
     * @param emailTemplate 
     */
    public patch (buyerID: string, emailTemplateType: string, emailTemplate: EmailTemplate) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/emailtemplates/{emailTemplateType}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'emailTemplateType' + '}', String(emailTemplateType));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling patch.');
        }

        // verify required parameter 'emailTemplateType' is not null or undefined
        if (emailTemplateType === null || emailTemplateType === undefined) {
            throw new Error('Required parameter emailTemplateType was null or undefined when calling patch.');
        }

        // verify required parameter 'emailTemplate' is not null or undefined
        if (emailTemplate === null || emailTemplate === undefined) {
            throw new Error('Required parameter emailTemplate was null or undefined when calling patch.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: emailTemplate,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param emailTemplateType Email template type of the email template. Possible values: OrderSubmittedForApproval, CustomerOrderSubmitted, OrderToApprove, OrderDeclined, OrderApproved, PriceRequestSubmitted, CustomerOrderShipped, ProductRequiresAttachment, InventoryPointReached, LineItemExceedsInventory, PriceRequestResponse, CustomerOrderUpdated, OrderCanceled, PriceRequestCanceled, NewOrderReceived, ApprovalNotification, EmailLoginVerificationCode.
     */
    public resetToDefault (buyerID: string, emailTemplateType: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/emailtemplates/{emailTemplateType}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'emailTemplateType' + '}', String(emailTemplateType));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling resetToDefault.');
        }

        // verify required parameter 'emailTemplateType' is not null or undefined
        if (emailTemplateType === null || emailTemplateType === undefined) {
            throw new Error('Required parameter emailTemplateType was null or undefined when calling resetToDefault.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param emailTemplateType Email template type of the email template. Possible values: OrderSubmittedForApproval, CustomerOrderSubmitted, OrderToApprove, OrderDeclined, OrderApproved, PriceRequestSubmitted, CustomerOrderShipped, ProductRequiresAttachment, InventoryPointReached, LineItemExceedsInventory, PriceRequestResponse, CustomerOrderUpdated, OrderCanceled, PriceRequestCanceled, NewOrderReceived, ApprovalNotification, EmailLoginVerificationCode.
     * @param emailTemplate 
     */
    public update (buyerID: string, emailTemplateType: string, emailTemplate: EmailTemplate) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/emailtemplates/{emailTemplateType}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'emailTemplateType' + '}', String(emailTemplateType));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling update.');
        }

        // verify required parameter 'emailTemplateType' is not null or undefined
        if (emailTemplateType === null || emailTemplateType === undefined) {
            throw new Error('Required parameter emailTemplateType was null or undefined when calling update.');
        }

        // verify required parameter 'emailTemplate' is not null or undefined
        if (emailTemplate === null || emailTemplate === undefined) {
            throw new Error('Required parameter emailTemplate was null or undefined when calling update.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: emailTemplate,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum FileApiApiKeys {
}

export class FileApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'auth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: FileApiApiKeys, value: string) {
        this.authentications[FileApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.auth.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * 
     * 
     * @param fileID ID of the file.
     */
    public get (fileID: string) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/files/{fileID}'
            .replace('{' + 'fileID' + '}', String(fileID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'fileID' is not null or undefined
        if (fileID === null || fileID === undefined) {
            throw new Error('Required parameter fileID was null or undefined when calling get.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public list (page?: number, pageSize?: number) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/files';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param filename Filename of the file.
     */
    public postFileData (filename?: string) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/files';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (filename !== undefined) {
            queryParameters['filename'] = filename;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum LineItemApiApiKeys {
}

export class LineItemApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'auth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: LineItemApiApiKeys, value: string) {
        this.authentications[LineItemApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.auth.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param lineItemID ID of the line item.
     */
    public _delete (buyerID: string, orderID: string, lineItemID: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/orders/{orderID}/lineitems/{lineItemID}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'orderID' + '}', String(orderID))
            .replace('{' + 'lineItemID' + '}', String(lineItemID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling _delete.');
        }

        // verify required parameter 'orderID' is not null or undefined
        if (orderID === null || orderID === undefined) {
            throw new Error('Required parameter orderID was null or undefined when calling _delete.');
        }

        // verify required parameter 'lineItemID' is not null or undefined
        if (lineItemID === null || lineItemID === undefined) {
            throw new Error('Required parameter lineItemID was null or undefined when calling _delete.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param lineItem 
     */
    public create (buyerID: string, orderID: string, lineItem: LineItem) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/orders/{orderID}/lineitems'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'orderID' + '}', String(orderID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling create.');
        }

        // verify required parameter 'orderID' is not null or undefined
        if (orderID === null || orderID === undefined) {
            throw new Error('Required parameter orderID was null or undefined when calling create.');
        }

        // verify required parameter 'lineItem' is not null or undefined
        if (lineItem === null || lineItem === undefined) {
            throw new Error('Required parameter lineItem was null or undefined when calling create.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: lineItem,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param lineItemID ID of the line item.
     */
    public get (buyerID: string, orderID: string, lineItemID: string) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/orders/{orderID}/lineitems/{lineItemID}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'orderID' + '}', String(orderID))
            .replace('{' + 'lineItemID' + '}', String(lineItemID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling get.');
        }

        // verify required parameter 'orderID' is not null or undefined
        if (orderID === null || orderID === undefined) {
            throw new Error('Required parameter orderID was null or undefined when calling get.');
        }

        // verify required parameter 'lineItemID' is not null or undefined
        if (lineItemID === null || lineItemID === undefined) {
            throw new Error('Required parameter lineItemID was null or undefined when calling get.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public list (buyerID: string, orderID: string, search?: string, searchOn?: string, sortBy?: string, page?: number, pageSize?: number) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/orders/{orderID}/lineitems'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'orderID' + '}', String(orderID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling list.');
        }

        // verify required parameter 'orderID' is not null or undefined
        if (orderID === null || orderID === undefined) {
            throw new Error('Required parameter orderID was null or undefined when calling list.');
        }

        if (search !== undefined) {
            queryParameters['search'] = search;
        }

        if (searchOn !== undefined) {
            queryParameters['searchOn'] = searchOn;
        }

        if (sortBy !== undefined) {
            queryParameters['sortBy'] = sortBy;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param lineItemID ID of the line item.
     * @param partialLineItem 
     */
    public patch (buyerID: string, orderID: string, lineItemID: string, partialLineItem: LineItem) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/orders/{orderID}/lineitems/{lineItemID}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'orderID' + '}', String(orderID))
            .replace('{' + 'lineItemID' + '}', String(lineItemID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling patch.');
        }

        // verify required parameter 'orderID' is not null or undefined
        if (orderID === null || orderID === undefined) {
            throw new Error('Required parameter orderID was null or undefined when calling patch.');
        }

        // verify required parameter 'lineItemID' is not null or undefined
        if (lineItemID === null || lineItemID === undefined) {
            throw new Error('Required parameter lineItemID was null or undefined when calling patch.');
        }

        // verify required parameter 'partialLineItem' is not null or undefined
        if (partialLineItem === null || partialLineItem === undefined) {
            throw new Error('Required parameter partialLineItem was null or undefined when calling patch.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: partialLineItem,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param lineItemID ID of the line item.
     * @param address 
     */
    public patchShippingAddress (buyerID: string, orderID: string, lineItemID: string, address: Address) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/orders/{orderID}/lineitems/{lineItemID}/shipto'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'orderID' + '}', String(orderID))
            .replace('{' + 'lineItemID' + '}', String(lineItemID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling patchShippingAddress.');
        }

        // verify required parameter 'orderID' is not null or undefined
        if (orderID === null || orderID === undefined) {
            throw new Error('Required parameter orderID was null or undefined when calling patchShippingAddress.');
        }

        // verify required parameter 'lineItemID' is not null or undefined
        if (lineItemID === null || lineItemID === undefined) {
            throw new Error('Required parameter lineItemID was null or undefined when calling patchShippingAddress.');
        }

        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
            throw new Error('Required parameter address was null or undefined when calling patchShippingAddress.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: address,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param lineItemID ID of the line item.
     * @param address 
     */
    public setShippingAddress (buyerID: string, orderID: string, lineItemID: string, address: Address) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/orders/{orderID}/lineitems/{lineItemID}/shipto'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'orderID' + '}', String(orderID))
            .replace('{' + 'lineItemID' + '}', String(lineItemID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling setShippingAddress.');
        }

        // verify required parameter 'orderID' is not null or undefined
        if (orderID === null || orderID === undefined) {
            throw new Error('Required parameter orderID was null or undefined when calling setShippingAddress.');
        }

        // verify required parameter 'lineItemID' is not null or undefined
        if (lineItemID === null || lineItemID === undefined) {
            throw new Error('Required parameter lineItemID was null or undefined when calling setShippingAddress.');
        }

        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
            throw new Error('Required parameter address was null or undefined when calling setShippingAddress.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: address,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param lineItemID ID of the line item.
     * @param lineItem 
     */
    public update (buyerID: string, orderID: string, lineItemID: string, lineItem: LineItem) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/orders/{orderID}/lineitems/{lineItemID}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'orderID' + '}', String(orderID))
            .replace('{' + 'lineItemID' + '}', String(lineItemID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling update.');
        }

        // verify required parameter 'orderID' is not null or undefined
        if (orderID === null || orderID === undefined) {
            throw new Error('Required parameter orderID was null or undefined when calling update.');
        }

        // verify required parameter 'lineItemID' is not null or undefined
        if (lineItemID === null || lineItemID === undefined) {
            throw new Error('Required parameter lineItemID was null or undefined when calling update.');
        }

        // verify required parameter 'lineItem' is not null or undefined
        if (lineItem === null || lineItem === undefined) {
            throw new Error('Required parameter lineItem was null or undefined when calling update.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: lineItem,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MeApiApiKeys {
}

export class MeApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'auth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: MeApiApiKeys, value: string) {
        this.authentications[MeApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.auth.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * 
     * 
     * @param address 
     */
    public createAddress (address: BuyerAddress) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/me/addresses';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
            throw new Error('Required parameter address was null or undefined when calling createAddress.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: address,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param creditCard 
     */
    public createCreditCard (creditCard: BuyerCreditCard) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/me/creditcards';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'creditCard' is not null or undefined
        if (creditCard === null || creditCard === undefined) {
            throw new Error('Required parameter creditCard was null or undefined when calling createCreditCard.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: creditCard,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param addressID ID of the address.
     */
    public deleteAddress (addressID: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/me/addresses/{addressID}'
            .replace('{' + 'addressID' + '}', String(addressID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'addressID' is not null or undefined
        if (addressID === null || addressID === undefined) {
            throw new Error('Required parameter addressID was null or undefined when calling deleteAddress.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param creditcardID ID of the creditcard.
     */
    public deleteCreditCard (creditcardID: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/me/creditcards/{creditcardID}'
            .replace('{' + 'creditcardID' + '}', String(creditcardID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'creditcardID' is not null or undefined
        if (creditcardID === null || creditcardID === undefined) {
            throw new Error('Required parameter creditcardID was null or undefined when calling deleteCreditCard.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     */
    public get () : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/me';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param addressID ID of the address.
     */
    public getAddress (addressID: string) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/me/addresses/{addressID}'
            .replace('{' + 'addressID' + '}', String(addressID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'addressID' is not null or undefined
        if (addressID === null || addressID === undefined) {
            throw new Error('Required parameter addressID was null or undefined when calling getAddress.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param creditcardID ID of the creditcard.
     */
    public getCreditCard (creditcardID: string) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/me/creditcards/{creditcardID}'
            .replace('{' + 'creditcardID' + '}', String(creditcardID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'creditcardID' is not null or undefined
        if (creditcardID === null || creditcardID === undefined) {
            throw new Error('Required parameter creditcardID was null or undefined when calling getCreditCard.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param orderID ID of the order.
     */
    public getOrder (orderID: string) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/me/orders/{orderID}'
            .replace('{' + 'orderID' + '}', String(orderID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'orderID' is not null or undefined
        if (orderID === null || orderID === undefined) {
            throw new Error('Required parameter orderID was null or undefined when calling getOrder.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param productID ID of the product.
     */
    public getProduct (productID: string) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/me/products/{productID}'
            .replace('{' + 'productID' + '}', String(productID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'productID' is not null or undefined
        if (productID === null || productID === undefined) {
            throw new Error('Required parameter productID was null or undefined when calling getProduct.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param promotionID ID of the promotion.
     */
    public getPromotion (promotionID: string) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/me/promotions/{promotionID}'
            .replace('{' + 'promotionID' + '}', String(promotionID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'promotionID' is not null or undefined
        if (promotionID === null || promotionID === undefined) {
            throw new Error('Required parameter promotionID was null or undefined when calling getPromotion.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param productID ID of the product.
     * @param specID ID of the spec.
     */
    public getSpec (productID: string, specID: string) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/me/products/{productID}/specs/{specID}'
            .replace('{' + 'productID' + '}', String(productID))
            .replace('{' + 'specID' + '}', String(specID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'productID' is not null or undefined
        if (productID === null || productID === undefined) {
            throw new Error('Required parameter productID was null or undefined when calling getSpec.');
        }

        // verify required parameter 'specID' is not null or undefined
        if (specID === null || specID === undefined) {
            throw new Error('Required parameter specID was null or undefined when calling getSpec.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public listAddresses (search?: string, searchOn?: string, sortBy?: string, page?: number, pageSize?: number) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/me/addresses';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (search !== undefined) {
            queryParameters['search'] = search;
        }

        if (searchOn !== undefined) {
            queryParameters['searchOn'] = searchOn;
        }

        if (sortBy !== undefined) {
            queryParameters['sortBy'] = sortBy;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param depth Depth of the category.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public listCategories (depth?: string, search?: string, searchOn?: string, sortBy?: string, page?: number, pageSize?: number) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/me/categories';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (depth !== undefined) {
            queryParameters['depth'] = depth;
        }

        if (search !== undefined) {
            queryParameters['search'] = search;
        }

        if (searchOn !== undefined) {
            queryParameters['searchOn'] = searchOn;
        }

        if (sortBy !== undefined) {
            queryParameters['sortBy'] = sortBy;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public listCostCenters (search?: string, searchOn?: string, sortBy?: string, page?: number, pageSize?: number) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/me/costcenters';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (search !== undefined) {
            queryParameters['search'] = search;
        }

        if (searchOn !== undefined) {
            queryParameters['searchOn'] = searchOn;
        }

        if (sortBy !== undefined) {
            queryParameters['sortBy'] = sortBy;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public listCreditCards (search?: string, searchOn?: string, sortBy?: string, page?: number, pageSize?: number) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/me/creditcards';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (search !== undefined) {
            queryParameters['search'] = search;
        }

        if (searchOn !== undefined) {
            queryParameters['searchOn'] = searchOn;
        }

        if (sortBy !== undefined) {
            queryParameters['sortBy'] = sortBy;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param from Lower bound of date range that the order was created (if outgoing) or submitted (if incoming).
     * @param to Upper bound of date range that the order was created (if outgoing) or submitted (if incoming).
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public listIncomingOrders (from?: string, to?: string, search?: string, searchOn?: string, sortBy?: string, page?: number, pageSize?: number) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/me/orders/incoming';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (from !== undefined) {
            queryParameters['from'] = from;
        }

        if (to !== undefined) {
            queryParameters['to'] = to;
        }

        if (search !== undefined) {
            queryParameters['search'] = search;
        }

        if (searchOn !== undefined) {
            queryParameters['searchOn'] = searchOn;
        }

        if (sortBy !== undefined) {
            queryParameters['sortBy'] = sortBy;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param from Lower bound of date range that the order was created (if outgoing) or submitted (if incoming).
     * @param to Upper bound of date range that the order was created (if outgoing) or submitted (if incoming).
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public listOutgoingOrders (from?: string, to?: string, search?: string, searchOn?: string, sortBy?: string, page?: number, pageSize?: number) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/me/orders/outgoing';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (from !== undefined) {
            queryParameters['from'] = from;
        }

        if (to !== undefined) {
            queryParameters['to'] = to;
        }

        if (search !== undefined) {
            queryParameters['search'] = search;
        }

        if (searchOn !== undefined) {
            queryParameters['searchOn'] = searchOn;
        }

        if (sortBy !== undefined) {
            queryParameters['sortBy'] = sortBy;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param categoryID ID of the category.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public listProducts (categoryID?: string, search?: string, searchOn?: string, sortBy?: string, page?: number, pageSize?: number) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/me/products';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (categoryID !== undefined) {
            queryParameters['categoryID'] = categoryID;
        }

        if (search !== undefined) {
            queryParameters['search'] = search;
        }

        if (searchOn !== undefined) {
            queryParameters['searchOn'] = searchOn;
        }

        if (sortBy !== undefined) {
            queryParameters['sortBy'] = sortBy;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public listPromotions (search?: string, searchOn?: string, sortBy?: string, page?: number, pageSize?: number) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/me/promotions';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (search !== undefined) {
            queryParameters['search'] = search;
        }

        if (searchOn !== undefined) {
            queryParameters['searchOn'] = searchOn;
        }

        if (sortBy !== undefined) {
            queryParameters['sortBy'] = sortBy;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param productID ID of the product.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public listSpecs (productID: string, search?: string, searchOn?: string, sortBy?: string, page?: number, pageSize?: number) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/me/products/{productID}/specs'
            .replace('{' + 'productID' + '}', String(productID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'productID' is not null or undefined
        if (productID === null || productID === undefined) {
            throw new Error('Required parameter productID was null or undefined when calling listSpecs.');
        }

        if (search !== undefined) {
            queryParameters['search'] = search;
        }

        if (searchOn !== undefined) {
            queryParameters['searchOn'] = searchOn;
        }

        if (sortBy !== undefined) {
            queryParameters['sortBy'] = sortBy;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param parentID ID of the parent.
     * @param depth Depth of the category.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public listSubcategories (parentID: string, depth?: string, search?: string, searchOn?: string, sortBy?: string, page?: number, pageSize?: number) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/me/categories/{parentID}/categories'
            .replace('{' + 'parentID' + '}', String(parentID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'parentID' is not null or undefined
        if (parentID === null || parentID === undefined) {
            throw new Error('Required parameter parentID was null or undefined when calling listSubcategories.');
        }

        if (depth !== undefined) {
            queryParameters['depth'] = depth;
        }

        if (search !== undefined) {
            queryParameters['search'] = search;
        }

        if (searchOn !== undefined) {
            queryParameters['searchOn'] = searchOn;
        }

        if (sortBy !== undefined) {
            queryParameters['sortBy'] = sortBy;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public listUserGroups (search?: string, searchOn?: string, sortBy?: string, page?: number, pageSize?: number) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/me/usergroups';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (search !== undefined) {
            queryParameters['search'] = search;
        }

        if (searchOn !== undefined) {
            queryParameters['searchOn'] = searchOn;
        }

        if (sortBy !== undefined) {
            queryParameters['sortBy'] = sortBy;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param user 
     */
    public patch (user: User) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/me';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'user' is not null or undefined
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling patch.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: user,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param addressID ID of the address.
     * @param address 
     */
    public patchAddress (addressID: string, address: BuyerAddress) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/me/addresses/{addressID}'
            .replace('{' + 'addressID' + '}', String(addressID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'addressID' is not null or undefined
        if (addressID === null || addressID === undefined) {
            throw new Error('Required parameter addressID was null or undefined when calling patchAddress.');
        }

        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
            throw new Error('Required parameter address was null or undefined when calling patchAddress.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: address,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param creditcardID ID of the creditcard.
     * @param creditCard 
     */
    public patchCreditCard (creditcardID: string, creditCard: BuyerCreditCard) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/me/creditcards/{creditcardID}'
            .replace('{' + 'creditcardID' + '}', String(creditcardID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'creditcardID' is not null or undefined
        if (creditcardID === null || creditcardID === undefined) {
            throw new Error('Required parameter creditcardID was null or undefined when calling patchCreditCard.');
        }

        // verify required parameter 'creditCard' is not null or undefined
        if (creditCard === null || creditCard === undefined) {
            throw new Error('Required parameter creditCard was null or undefined when calling patchCreditCard.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: creditCard,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param user 
     */
    public update (user: User) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/me';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'user' is not null or undefined
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling update.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: user,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param addressID ID of the address.
     * @param address 
     */
    public updateAddress (addressID: string, address: BuyerAddress) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/me/addresses/{addressID}'
            .replace('{' + 'addressID' + '}', String(addressID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'addressID' is not null or undefined
        if (addressID === null || addressID === undefined) {
            throw new Error('Required parameter addressID was null or undefined when calling updateAddress.');
        }

        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
            throw new Error('Required parameter address was null or undefined when calling updateAddress.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: address,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param creditcardID ID of the creditcard.
     * @param creditCard 
     */
    public updateCreditCard (creditcardID: string, creditCard: BuyerCreditCard) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/me/creditcards/{creditcardID}'
            .replace('{' + 'creditcardID' + '}', String(creditcardID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'creditcardID' is not null or undefined
        if (creditcardID === null || creditcardID === undefined) {
            throw new Error('Required parameter creditcardID was null or undefined when calling updateCreditCard.');
        }

        // verify required parameter 'creditCard' is not null or undefined
        if (creditCard === null || creditCard === undefined) {
            throw new Error('Required parameter creditCard was null or undefined when calling updateCreditCard.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: creditCard,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum OrderApiApiKeys {
}

export class OrderApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'auth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: OrderApiApiKeys, value: string) {
        this.authentications[OrderApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.auth.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     */
    public _delete (buyerID: string, orderID: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/orders/{orderID}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'orderID' + '}', String(orderID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling _delete.');
        }

        // verify required parameter 'orderID' is not null or undefined
        if (orderID === null || orderID === undefined) {
            throw new Error('Required parameter orderID was null or undefined when calling _delete.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param promoCode Promo code of the order.
     */
    public addPromotion (buyerID: string, orderID: string, promoCode: string) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/orders/{orderID}/promotions/{promoCode}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'orderID' + '}', String(orderID))
            .replace('{' + 'promoCode' + '}', String(promoCode));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling addPromotion.');
        }

        // verify required parameter 'orderID' is not null or undefined
        if (orderID === null || orderID === undefined) {
            throw new Error('Required parameter orderID was null or undefined when calling addPromotion.');
        }

        // verify required parameter 'promoCode' is not null or undefined
        if (promoCode === null || promoCode === undefined) {
            throw new Error('Required parameter promoCode was null or undefined when calling addPromotion.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param comments Comments to be saved with the order approval.
     */
    public approve (buyerID: string, orderID: string, comments?: string) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/orders/{orderID}/approve'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'orderID' + '}', String(orderID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling approve.');
        }

        // verify required parameter 'orderID' is not null or undefined
        if (orderID === null || orderID === undefined) {
            throw new Error('Required parameter orderID was null or undefined when calling approve.');
        }

        if (comments !== undefined) {
            queryParameters['comments'] = comments;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     */
    public cancel (buyerID: string, orderID: string) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/orders/{orderID}/cancel'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'orderID' + '}', String(orderID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling cancel.');
        }

        // verify required parameter 'orderID' is not null or undefined
        if (orderID === null || orderID === undefined) {
            throw new Error('Required parameter orderID was null or undefined when calling cancel.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param order 
     */
    public create (buyerID: string, order: Order) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/orders'
            .replace('{' + 'buyerID' + '}', String(buyerID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling create.');
        }

        // verify required parameter 'order' is not null or undefined
        if (order === null || order === undefined) {
            throw new Error('Required parameter order was null or undefined when calling create.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: order,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param comments Comments to be saved with the order denial.
     */
    public decline (buyerID: string, orderID: string, comments?: string) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/orders/{orderID}/decline'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'orderID' + '}', String(orderID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling decline.');
        }

        // verify required parameter 'orderID' is not null or undefined
        if (orderID === null || orderID === undefined) {
            throw new Error('Required parameter orderID was null or undefined when calling decline.');
        }

        if (comments !== undefined) {
            queryParameters['comments'] = comments;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     */
    public get (buyerID: string, orderID: string) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/orders/{orderID}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'orderID' + '}', String(orderID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling get.');
        }

        // verify required parameter 'orderID' is not null or undefined
        if (orderID === null || orderID === undefined) {
            throw new Error('Required parameter orderID was null or undefined when calling get.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public listApprovals (buyerID: string, orderID: string, search?: string, searchOn?: string, sortBy?: string, page?: number, pageSize?: number) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/orders/{orderID}/approvals'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'orderID' + '}', String(orderID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling listApprovals.');
        }

        // verify required parameter 'orderID' is not null or undefined
        if (orderID === null || orderID === undefined) {
            throw new Error('Required parameter orderID was null or undefined when calling listApprovals.');
        }

        if (search !== undefined) {
            queryParameters['search'] = search;
        }

        if (searchOn !== undefined) {
            queryParameters['searchOn'] = searchOn;
        }

        if (sortBy !== undefined) {
            queryParameters['sortBy'] = sortBy;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public listEligibleApprovers (buyerID: string, orderID: string, search?: string, searchOn?: string, sortBy?: string, page?: number, pageSize?: number) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/orders/{orderID}/eligibleapprovers'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'orderID' + '}', String(orderID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling listEligibleApprovers.');
        }

        // verify required parameter 'orderID' is not null or undefined
        if (orderID === null || orderID === undefined) {
            throw new Error('Required parameter orderID was null or undefined when calling listEligibleApprovers.');
        }

        if (search !== undefined) {
            queryParameters['search'] = search;
        }

        if (searchOn !== undefined) {
            queryParameters['searchOn'] = searchOn;
        }

        if (sortBy !== undefined) {
            queryParameters['sortBy'] = sortBy;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param from Lower bound of date range that the order was submitted.
     * @param to Upper bound of date range that the order was submitted.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public listIncoming (buyerID?: string, from?: string, to?: string, search?: string, searchOn?: string, sortBy?: string, page?: number, pageSize?: number) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/orders/incoming';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (buyerID !== undefined) {
            queryParameters['buyerID'] = buyerID;
        }

        if (from !== undefined) {
            queryParameters['from'] = from;
        }

        if (to !== undefined) {
            queryParameters['to'] = to;
        }

        if (search !== undefined) {
            queryParameters['search'] = search;
        }

        if (searchOn !== undefined) {
            queryParameters['searchOn'] = searchOn;
        }

        if (sortBy !== undefined) {
            queryParameters['sortBy'] = sortBy;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param from Lower bound of date range that the order was created.
     * @param to Upper bound of date range that the order was created.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public listOutgoing (buyerID?: string, from?: string, to?: string, search?: string, searchOn?: string, sortBy?: string, page?: number, pageSize?: number) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/orders/outgoing';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (buyerID !== undefined) {
            queryParameters['buyerID'] = buyerID;
        }

        if (from !== undefined) {
            queryParameters['from'] = from;
        }

        if (to !== undefined) {
            queryParameters['to'] = to;
        }

        if (search !== undefined) {
            queryParameters['search'] = search;
        }

        if (searchOn !== undefined) {
            queryParameters['searchOn'] = searchOn;
        }

        if (sortBy !== undefined) {
            queryParameters['sortBy'] = sortBy;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public listPromotions (buyerID: string, orderID: string, search?: string, searchOn?: string, sortBy?: string, page?: number, pageSize?: number) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/orders/{orderID}/promotions'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'orderID' + '}', String(orderID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling listPromotions.');
        }

        // verify required parameter 'orderID' is not null or undefined
        if (orderID === null || orderID === undefined) {
            throw new Error('Required parameter orderID was null or undefined when calling listPromotions.');
        }

        if (search !== undefined) {
            queryParameters['search'] = search;
        }

        if (searchOn !== undefined) {
            queryParameters['searchOn'] = searchOn;
        }

        if (sortBy !== undefined) {
            queryParameters['sortBy'] = sortBy;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param partialOrder 
     */
    public patch (buyerID: string, orderID: string, partialOrder: Order) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/orders/{orderID}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'orderID' + '}', String(orderID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling patch.');
        }

        // verify required parameter 'orderID' is not null or undefined
        if (orderID === null || orderID === undefined) {
            throw new Error('Required parameter orderID was null or undefined when calling patch.');
        }

        // verify required parameter 'partialOrder' is not null or undefined
        if (partialOrder === null || partialOrder === undefined) {
            throw new Error('Required parameter partialOrder was null or undefined when calling patch.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: partialOrder,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param address 
     */
    public patchBillingAddress (buyerID: string, orderID: string, address: Address) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/orders/{orderID}/billto'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'orderID' + '}', String(orderID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling patchBillingAddress.');
        }

        // verify required parameter 'orderID' is not null or undefined
        if (orderID === null || orderID === undefined) {
            throw new Error('Required parameter orderID was null or undefined when calling patchBillingAddress.');
        }

        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
            throw new Error('Required parameter address was null or undefined when calling patchBillingAddress.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: address,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param address 
     */
    public patchShippingAddress (buyerID: string, orderID: string, address: Address) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/orders/{orderID}/shipto'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'orderID' + '}', String(orderID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling patchShippingAddress.');
        }

        // verify required parameter 'orderID' is not null or undefined
        if (orderID === null || orderID === undefined) {
            throw new Error('Required parameter orderID was null or undefined when calling patchShippingAddress.');
        }

        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
            throw new Error('Required parameter address was null or undefined when calling patchShippingAddress.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: address,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param promoCode Promo code of the order.
     */
    public removePromotion (buyerID: string, orderID: string, promoCode: string) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/orders/{orderID}/promotions/{promoCode}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'orderID' + '}', String(orderID))
            .replace('{' + 'promoCode' + '}', String(promoCode));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling removePromotion.');
        }

        // verify required parameter 'orderID' is not null or undefined
        if (orderID === null || orderID === undefined) {
            throw new Error('Required parameter orderID was null or undefined when calling removePromotion.');
        }

        // verify required parameter 'promoCode' is not null or undefined
        if (promoCode === null || promoCode === undefined) {
            throw new Error('Required parameter promoCode was null or undefined when calling removePromotion.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param address 
     */
    public setBillingAddress (buyerID: string, orderID: string, address: Address) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/orders/{orderID}/billto'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'orderID' + '}', String(orderID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling setBillingAddress.');
        }

        // verify required parameter 'orderID' is not null or undefined
        if (orderID === null || orderID === undefined) {
            throw new Error('Required parameter orderID was null or undefined when calling setBillingAddress.');
        }

        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
            throw new Error('Required parameter address was null or undefined when calling setBillingAddress.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: address,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param address 
     */
    public setShippingAddress (buyerID: string, orderID: string, address: Address) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/orders/{orderID}/shipto'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'orderID' + '}', String(orderID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling setShippingAddress.');
        }

        // verify required parameter 'orderID' is not null or undefined
        if (orderID === null || orderID === undefined) {
            throw new Error('Required parameter orderID was null or undefined when calling setShippingAddress.');
        }

        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
            throw new Error('Required parameter address was null or undefined when calling setShippingAddress.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: address,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param shipment 
     */
    public ship (buyerID: string, orderID: string, shipment: Shipment) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/orders/{orderID}/ship'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'orderID' + '}', String(orderID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling ship.');
        }

        // verify required parameter 'orderID' is not null or undefined
        if (orderID === null || orderID === undefined) {
            throw new Error('Required parameter orderID was null or undefined when calling ship.');
        }

        // verify required parameter 'shipment' is not null or undefined
        if (shipment === null || shipment === undefined) {
            throw new Error('Required parameter shipment was null or undefined when calling ship.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: shipment,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     */
    public submit (buyerID: string, orderID: string) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/orders/{orderID}/submit'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'orderID' + '}', String(orderID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling submit.');
        }

        // verify required parameter 'orderID' is not null or undefined
        if (orderID === null || orderID === undefined) {
            throw new Error('Required parameter orderID was null or undefined when calling submit.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param tempUserToken Temp user token of the order.
     */
    public transferTempUserOrder (buyerID: string, tempUserToken: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/orders'
            .replace('{' + 'buyerID' + '}', String(buyerID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling transferTempUserOrder.');
        }

        // verify required parameter 'tempUserToken' is not null or undefined
        if (tempUserToken === null || tempUserToken === undefined) {
            throw new Error('Required parameter tempUserToken was null or undefined when calling transferTempUserOrder.');
        }

        if (tempUserToken !== undefined) {
            queryParameters['tempUserToken'] = tempUserToken;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param order 
     */
    public update (buyerID: string, orderID: string, order: Order) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/orders/{orderID}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'orderID' + '}', String(orderID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling update.');
        }

        // verify required parameter 'orderID' is not null or undefined
        if (orderID === null || orderID === undefined) {
            throw new Error('Required parameter orderID was null or undefined when calling update.');
        }

        // verify required parameter 'order' is not null or undefined
        if (order === null || order === undefined) {
            throw new Error('Required parameter order was null or undefined when calling update.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: order,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PasswordResetApiApiKeys {
}

export class PasswordResetApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'auth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: PasswordResetApiApiKeys, value: string) {
        this.authentications[PasswordResetApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.auth.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * 
     * 
     * @param verificationCode Verification code of the forgotten password.
     * @param passwordReset 
     */
    public resetPassword (verificationCode: string, passwordReset: PasswordReset) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/password/reset/{verificationCode}'
            .replace('{' + 'verificationCode' + '}', String(verificationCode));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'verificationCode' is not null or undefined
        if (verificationCode === null || verificationCode === undefined) {
            throw new Error('Required parameter verificationCode was null or undefined when calling resetPassword.');
        }

        // verify required parameter 'passwordReset' is not null or undefined
        if (passwordReset === null || passwordReset === undefined) {
            throw new Error('Required parameter passwordReset was null or undefined when calling resetPassword.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: passwordReset,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param passwordResetRequest 
     */
    public sendVerificationCode (passwordResetRequest: PasswordResetRequest) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/password/reset';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'passwordResetRequest' is not null or undefined
        if (passwordResetRequest === null || passwordResetRequest === undefined) {
            throw new Error('Required parameter passwordResetRequest was null or undefined when calling sendVerificationCode.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: passwordResetRequest,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PaymentApiApiKeys {
}

export class PaymentApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'auth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: PaymentApiApiKeys, value: string) {
        this.authentications[PaymentApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.auth.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param paymentID ID of the payment.
     */
    public _delete (buyerID: string, orderID: string, paymentID: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/orders/{orderID}/payments/{paymentID}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'orderID' + '}', String(orderID))
            .replace('{' + 'paymentID' + '}', String(paymentID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling _delete.');
        }

        // verify required parameter 'orderID' is not null or undefined
        if (orderID === null || orderID === undefined) {
            throw new Error('Required parameter orderID was null or undefined when calling _delete.');
        }

        // verify required parameter 'paymentID' is not null or undefined
        if (paymentID === null || paymentID === undefined) {
            throw new Error('Required parameter paymentID was null or undefined when calling _delete.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param payment 
     */
    public create (buyerID: string, orderID: string, payment: Payment) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/orders/{orderID}/payments'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'orderID' + '}', String(orderID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling create.');
        }

        // verify required parameter 'orderID' is not null or undefined
        if (orderID === null || orderID === undefined) {
            throw new Error('Required parameter orderID was null or undefined when calling create.');
        }

        // verify required parameter 'payment' is not null or undefined
        if (payment === null || payment === undefined) {
            throw new Error('Required parameter payment was null or undefined when calling create.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: payment,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param paymentID ID of the payment.
     * @param transaction 
     */
    public createTransaction (buyerID: string, orderID: string, paymentID: string, transaction: PaymentTransaction) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/orders/{orderID}/payments/{paymentID}/transactions'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'orderID' + '}', String(orderID))
            .replace('{' + 'paymentID' + '}', String(paymentID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling createTransaction.');
        }

        // verify required parameter 'orderID' is not null or undefined
        if (orderID === null || orderID === undefined) {
            throw new Error('Required parameter orderID was null or undefined when calling createTransaction.');
        }

        // verify required parameter 'paymentID' is not null or undefined
        if (paymentID === null || paymentID === undefined) {
            throw new Error('Required parameter paymentID was null or undefined when calling createTransaction.');
        }

        // verify required parameter 'transaction' is not null or undefined
        if (transaction === null || transaction === undefined) {
            throw new Error('Required parameter transaction was null or undefined when calling createTransaction.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: transaction,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param paymentID ID of the payment.
     * @param transactionID ID of the transaction.
     */
    public deleteTransaction (buyerID: string, orderID: string, paymentID: string, transactionID: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/orders/{orderID}/payments/{paymentID}/transactions/{transactionID}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'orderID' + '}', String(orderID))
            .replace('{' + 'paymentID' + '}', String(paymentID))
            .replace('{' + 'transactionID' + '}', String(transactionID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling deleteTransaction.');
        }

        // verify required parameter 'orderID' is not null or undefined
        if (orderID === null || orderID === undefined) {
            throw new Error('Required parameter orderID was null or undefined when calling deleteTransaction.');
        }

        // verify required parameter 'paymentID' is not null or undefined
        if (paymentID === null || paymentID === undefined) {
            throw new Error('Required parameter paymentID was null or undefined when calling deleteTransaction.');
        }

        // verify required parameter 'transactionID' is not null or undefined
        if (transactionID === null || transactionID === undefined) {
            throw new Error('Required parameter transactionID was null or undefined when calling deleteTransaction.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param paymentID ID of the payment.
     */
    public get (buyerID: string, orderID: string, paymentID: string) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/orders/{orderID}/payments/{paymentID}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'orderID' + '}', String(orderID))
            .replace('{' + 'paymentID' + '}', String(paymentID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling get.');
        }

        // verify required parameter 'orderID' is not null or undefined
        if (orderID === null || orderID === undefined) {
            throw new Error('Required parameter orderID was null or undefined when calling get.');
        }

        // verify required parameter 'paymentID' is not null or undefined
        if (paymentID === null || paymentID === undefined) {
            throw new Error('Required parameter paymentID was null or undefined when calling get.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public list (buyerID: string, orderID: string, search?: string, searchOn?: string, sortBy?: string, page?: number, pageSize?: number) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/orders/{orderID}/payments'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'orderID' + '}', String(orderID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling list.');
        }

        // verify required parameter 'orderID' is not null or undefined
        if (orderID === null || orderID === undefined) {
            throw new Error('Required parameter orderID was null or undefined when calling list.');
        }

        if (search !== undefined) {
            queryParameters['search'] = search;
        }

        if (searchOn !== undefined) {
            queryParameters['searchOn'] = searchOn;
        }

        if (sortBy !== undefined) {
            queryParameters['sortBy'] = sortBy;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param paymentID ID of the payment.
     * @param partialPayment 
     */
    public patch (buyerID: string, orderID: string, paymentID: string, partialPayment: Payment) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/orders/{orderID}/payments/{paymentID}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'orderID' + '}', String(orderID))
            .replace('{' + 'paymentID' + '}', String(paymentID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling patch.');
        }

        // verify required parameter 'orderID' is not null or undefined
        if (orderID === null || orderID === undefined) {
            throw new Error('Required parameter orderID was null or undefined when calling patch.');
        }

        // verify required parameter 'paymentID' is not null or undefined
        if (paymentID === null || paymentID === undefined) {
            throw new Error('Required parameter paymentID was null or undefined when calling patch.');
        }

        // verify required parameter 'partialPayment' is not null or undefined
        if (partialPayment === null || partialPayment === undefined) {
            throw new Error('Required parameter partialPayment was null or undefined when calling patch.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: partialPayment,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param paymentID ID of the payment.
     * @param transactionID ID of the transaction.
     * @param partialTransaction 
     */
    public patchTransaction (buyerID: string, orderID: string, paymentID: string, transactionID: string, partialTransaction: PaymentTransaction) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/orders/{orderID}/payments/{paymentID}/transactions/{transactionID}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'orderID' + '}', String(orderID))
            .replace('{' + 'paymentID' + '}', String(paymentID))
            .replace('{' + 'transactionID' + '}', String(transactionID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling patchTransaction.');
        }

        // verify required parameter 'orderID' is not null or undefined
        if (orderID === null || orderID === undefined) {
            throw new Error('Required parameter orderID was null or undefined when calling patchTransaction.');
        }

        // verify required parameter 'paymentID' is not null or undefined
        if (paymentID === null || paymentID === undefined) {
            throw new Error('Required parameter paymentID was null or undefined when calling patchTransaction.');
        }

        // verify required parameter 'transactionID' is not null or undefined
        if (transactionID === null || transactionID === undefined) {
            throw new Error('Required parameter transactionID was null or undefined when calling patchTransaction.');
        }

        // verify required parameter 'partialTransaction' is not null or undefined
        if (partialTransaction === null || partialTransaction === undefined) {
            throw new Error('Required parameter partialTransaction was null or undefined when calling patchTransaction.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: partialTransaction,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param paymentID ID of the payment.
     * @param payment 
     */
    public update (buyerID: string, orderID: string, paymentID: string, payment: Payment) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/orders/{orderID}/payments/{paymentID}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'orderID' + '}', String(orderID))
            .replace('{' + 'paymentID' + '}', String(paymentID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling update.');
        }

        // verify required parameter 'orderID' is not null or undefined
        if (orderID === null || orderID === undefined) {
            throw new Error('Required parameter orderID was null or undefined when calling update.');
        }

        // verify required parameter 'paymentID' is not null or undefined
        if (paymentID === null || paymentID === undefined) {
            throw new Error('Required parameter paymentID was null or undefined when calling update.');
        }

        // verify required parameter 'payment' is not null or undefined
        if (payment === null || payment === undefined) {
            throw new Error('Required parameter payment was null or undefined when calling update.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: payment,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param paymentID ID of the payment.
     * @param transactionID ID of the transaction.
     * @param transaction 
     */
    public updateTransaction (buyerID: string, orderID: string, paymentID: string, transactionID: string, transaction: PaymentTransaction) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/orders/{orderID}/payments/{paymentID}/transactions/{transactionID}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'orderID' + '}', String(orderID))
            .replace('{' + 'paymentID' + '}', String(paymentID))
            .replace('{' + 'transactionID' + '}', String(transactionID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling updateTransaction.');
        }

        // verify required parameter 'orderID' is not null or undefined
        if (orderID === null || orderID === undefined) {
            throw new Error('Required parameter orderID was null or undefined when calling updateTransaction.');
        }

        // verify required parameter 'paymentID' is not null or undefined
        if (paymentID === null || paymentID === undefined) {
            throw new Error('Required parameter paymentID was null or undefined when calling updateTransaction.');
        }

        // verify required parameter 'transactionID' is not null or undefined
        if (transactionID === null || transactionID === undefined) {
            throw new Error('Required parameter transactionID was null or undefined when calling updateTransaction.');
        }

        // verify required parameter 'transaction' is not null or undefined
        if (transaction === null || transaction === undefined) {
            throw new Error('Required parameter transaction was null or undefined when calling updateTransaction.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: transaction,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PriceScheduleApiApiKeys {
}

export class PriceScheduleApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'auth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: PriceScheduleApiApiKeys, value: string) {
        this.authentications[PriceScheduleApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.auth.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * 
     * 
     * @param priceScheduleID ID of the price schedule.
     */
    public _delete (priceScheduleID: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/priceschedules/{priceScheduleID}'
            .replace('{' + 'priceScheduleID' + '}', String(priceScheduleID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'priceScheduleID' is not null or undefined
        if (priceScheduleID === null || priceScheduleID === undefined) {
            throw new Error('Required parameter priceScheduleID was null or undefined when calling _delete.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param priceSchedule 
     */
    public create (priceSchedule: PriceSchedule) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/priceschedules';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'priceSchedule' is not null or undefined
        if (priceSchedule === null || priceSchedule === undefined) {
            throw new Error('Required parameter priceSchedule was null or undefined when calling create.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: priceSchedule,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param priceScheduleID ID of the price schedule.
     * @param quantity Quantity of the price schedule.
     */
    public deletePriceBreak (priceScheduleID: string, quantity: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/priceschedules/{priceScheduleID}/PriceBreaks'
            .replace('{' + 'priceScheduleID' + '}', String(priceScheduleID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'priceScheduleID' is not null or undefined
        if (priceScheduleID === null || priceScheduleID === undefined) {
            throw new Error('Required parameter priceScheduleID was null or undefined when calling deletePriceBreak.');
        }

        // verify required parameter 'quantity' is not null or undefined
        if (quantity === null || quantity === undefined) {
            throw new Error('Required parameter quantity was null or undefined when calling deletePriceBreak.');
        }

        if (quantity !== undefined) {
            queryParameters['quantity'] = quantity;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param priceScheduleID ID of the price schedule.
     */
    public get (priceScheduleID: string) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/priceschedules/{priceScheduleID}'
            .replace('{' + 'priceScheduleID' + '}', String(priceScheduleID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'priceScheduleID' is not null or undefined
        if (priceScheduleID === null || priceScheduleID === undefined) {
            throw new Error('Required parameter priceScheduleID was null or undefined when calling get.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public list (search?: string, searchOn?: string, sortBy?: string, page?: number, pageSize?: number) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/priceschedules';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (search !== undefined) {
            queryParameters['search'] = search;
        }

        if (searchOn !== undefined) {
            queryParameters['searchOn'] = searchOn;
        }

        if (sortBy !== undefined) {
            queryParameters['sortBy'] = sortBy;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param priceScheduleID ID of the price schedule.
     * @param priceSchedule 
     */
    public patch (priceScheduleID: string, priceSchedule: PriceSchedule) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/priceschedules/{priceScheduleID}'
            .replace('{' + 'priceScheduleID' + '}', String(priceScheduleID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'priceScheduleID' is not null or undefined
        if (priceScheduleID === null || priceScheduleID === undefined) {
            throw new Error('Required parameter priceScheduleID was null or undefined when calling patch.');
        }

        // verify required parameter 'priceSchedule' is not null or undefined
        if (priceSchedule === null || priceSchedule === undefined) {
            throw new Error('Required parameter priceSchedule was null or undefined when calling patch.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: priceSchedule,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param priceScheduleID ID of the price schedule.
     * @param priceBreak 
     */
    public savePriceBreak (priceScheduleID: string, priceBreak: PriceBreak) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/priceschedules/{priceScheduleID}/PriceBreaks'
            .replace('{' + 'priceScheduleID' + '}', String(priceScheduleID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'priceScheduleID' is not null or undefined
        if (priceScheduleID === null || priceScheduleID === undefined) {
            throw new Error('Required parameter priceScheduleID was null or undefined when calling savePriceBreak.');
        }

        // verify required parameter 'priceBreak' is not null or undefined
        if (priceBreak === null || priceBreak === undefined) {
            throw new Error('Required parameter priceBreak was null or undefined when calling savePriceBreak.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: priceBreak,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param priceScheduleID ID of the price schedule.
     * @param priceSchedule 
     */
    public update (priceScheduleID: string, priceSchedule: PriceSchedule) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/priceschedules/{priceScheduleID}'
            .replace('{' + 'priceScheduleID' + '}', String(priceScheduleID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'priceScheduleID' is not null or undefined
        if (priceScheduleID === null || priceScheduleID === undefined) {
            throw new Error('Required parameter priceScheduleID was null or undefined when calling update.');
        }

        // verify required parameter 'priceSchedule' is not null or undefined
        if (priceSchedule === null || priceSchedule === undefined) {
            throw new Error('Required parameter priceSchedule was null or undefined when calling update.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: priceSchedule,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ProductApiApiKeys {
}

export class ProductApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'auth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: ProductApiApiKeys, value: string) {
        this.authentications[ProductApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.auth.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * 
     * 
     * @param productID ID of the product.
     */
    public _delete (productID: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/products/{productID}'
            .replace('{' + 'productID' + '}', String(productID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'productID' is not null or undefined
        if (productID === null || productID === undefined) {
            throw new Error('Required parameter productID was null or undefined when calling _delete.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param product 
     */
    public create (product: Product) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/products';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'product' is not null or undefined
        if (product === null || product === undefined) {
            throw new Error('Required parameter product was null or undefined when calling create.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: product,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param productID ID of the product.
     * @param userID ID of the user.
     * @param userGroupID ID of the user group.
     */
    public deleteAssignment (buyerID: string, productID: string, userID?: string, userGroupID?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/products/{productID}/assignments/{buyerID}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'productID' + '}', String(productID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling deleteAssignment.');
        }

        // verify required parameter 'productID' is not null or undefined
        if (productID === null || productID === undefined) {
            throw new Error('Required parameter productID was null or undefined when calling deleteAssignment.');
        }

        if (userID !== undefined) {
            queryParameters['userID'] = userID;
        }

        if (userGroupID !== undefined) {
            queryParameters['userGroupID'] = userGroupID;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param productID ID of the product.
     * @param overwriteExisting Overwrite existing of the product.
     */
    public generateVariants (productID: string, overwriteExisting?: boolean) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/products/{productID}/variants/generate'
            .replace('{' + 'productID' + '}', String(productID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'productID' is not null or undefined
        if (productID === null || productID === undefined) {
            throw new Error('Required parameter productID was null or undefined when calling generateVariants.');
        }

        if (overwriteExisting !== undefined) {
            queryParameters['overwriteExisting'] = overwriteExisting;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param productID ID of the product.
     */
    public get (productID: string) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/products/{productID}'
            .replace('{' + 'productID' + '}', String(productID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'productID' is not null or undefined
        if (productID === null || productID === undefined) {
            throw new Error('Required parameter productID was null or undefined when calling get.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param productID ID of the product.
     */
    public getInventory (productID: string) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/products/{productID}/inventory'
            .replace('{' + 'productID' + '}', String(productID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'productID' is not null or undefined
        if (productID === null || productID === undefined) {
            throw new Error('Required parameter productID was null or undefined when calling getInventory.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param productID ID of the product.
     * @param variantID ID of the variant.
     */
    public getVariant (productID: string, variantID: string) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/products/{productID}/variants/{variantID}'
            .replace('{' + 'productID' + '}', String(productID))
            .replace('{' + 'variantID' + '}', String(variantID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'productID' is not null or undefined
        if (productID === null || productID === undefined) {
            throw new Error('Required parameter productID was null or undefined when calling getVariant.');
        }

        // verify required parameter 'variantID' is not null or undefined
        if (variantID === null || variantID === undefined) {
            throw new Error('Required parameter variantID was null or undefined when calling getVariant.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param productID ID of the product.
     * @param variantID ID of the variant.
     */
    public getVariantInventory (productID: string, variantID: string) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/products/{productID}/variants/inventory/{variantID}'
            .replace('{' + 'productID' + '}', String(productID))
            .replace('{' + 'variantID' + '}', String(variantID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'productID' is not null or undefined
        if (productID === null || productID === undefined) {
            throw new Error('Required parameter productID was null or undefined when calling getVariantInventory.');
        }

        // verify required parameter 'variantID' is not null or undefined
        if (variantID === null || variantID === undefined) {
            throw new Error('Required parameter variantID was null or undefined when calling getVariantInventory.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public list (search?: string, searchOn?: string, sortBy?: string, page?: number, pageSize?: number) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/products';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (search !== undefined) {
            queryParameters['search'] = search;
        }

        if (searchOn !== undefined) {
            queryParameters['searchOn'] = searchOn;
        }

        if (sortBy !== undefined) {
            queryParameters['sortBy'] = sortBy;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param productID ID of the product.
     * @param buyerID ID of the buyer.
     * @param userID ID of the user.
     * @param userGroupID ID of the user group.
     * @param level Level of the product.
     * @param priceScheduleID ID of the price schedule.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public listAssignments (productID?: string, buyerID?: string, userID?: string, userGroupID?: string, level?: string, priceScheduleID?: string, page?: number, pageSize?: number) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/products/assignments';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (productID !== undefined) {
            queryParameters['productID'] = productID;
        }

        if (buyerID !== undefined) {
            queryParameters['buyerID'] = buyerID;
        }

        if (userID !== undefined) {
            queryParameters['userID'] = userID;
        }

        if (userGroupID !== undefined) {
            queryParameters['userGroupID'] = userGroupID;
        }

        if (level !== undefined) {
            queryParameters['level'] = level;
        }

        if (priceScheduleID !== undefined) {
            queryParameters['priceScheduleID'] = priceScheduleID;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public listInventory (search?: string, searchOn?: string, sortBy?: string, page?: number, pageSize?: number) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/products/inventory';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (search !== undefined) {
            queryParameters['search'] = search;
        }

        if (searchOn !== undefined) {
            queryParameters['searchOn'] = searchOn;
        }

        if (sortBy !== undefined) {
            queryParameters['sortBy'] = sortBy;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param productID ID of the product.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public listVariantInventory (productID: string, search?: string, searchOn?: string, sortBy?: string, page?: number, pageSize?: number) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/products/{productID}/variants/inventory'
            .replace('{' + 'productID' + '}', String(productID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'productID' is not null or undefined
        if (productID === null || productID === undefined) {
            throw new Error('Required parameter productID was null or undefined when calling listVariantInventory.');
        }

        if (search !== undefined) {
            queryParameters['search'] = search;
        }

        if (searchOn !== undefined) {
            queryParameters['searchOn'] = searchOn;
        }

        if (sortBy !== undefined) {
            queryParameters['sortBy'] = sortBy;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param productID ID of the product.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public listVariants (productID: string, search?: string, searchOn?: string, sortBy?: string, page?: number, pageSize?: number) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/products/{productID}/variants'
            .replace('{' + 'productID' + '}', String(productID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'productID' is not null or undefined
        if (productID === null || productID === undefined) {
            throw new Error('Required parameter productID was null or undefined when calling listVariants.');
        }

        if (search !== undefined) {
            queryParameters['search'] = search;
        }

        if (searchOn !== undefined) {
            queryParameters['searchOn'] = searchOn;
        }

        if (sortBy !== undefined) {
            queryParameters['sortBy'] = sortBy;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param productID ID of the product.
     * @param product 
     */
    public patch (productID: string, product: Product) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/products/{productID}'
            .replace('{' + 'productID' + '}', String(productID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'productID' is not null or undefined
        if (productID === null || productID === undefined) {
            throw new Error('Required parameter productID was null or undefined when calling patch.');
        }

        // verify required parameter 'product' is not null or undefined
        if (product === null || product === undefined) {
            throw new Error('Required parameter product was null or undefined when calling patch.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: product,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param productID ID of the product.
     * @param variantID ID of the variant.
     * @param variant 
     */
    public patchVariant (productID: string, variantID: string, variant: Variant) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/products/{productID}/variants/{variantID}'
            .replace('{' + 'productID' + '}', String(productID))
            .replace('{' + 'variantID' + '}', String(variantID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'productID' is not null or undefined
        if (productID === null || productID === undefined) {
            throw new Error('Required parameter productID was null or undefined when calling patchVariant.');
        }

        // verify required parameter 'variantID' is not null or undefined
        if (variantID === null || variantID === undefined) {
            throw new Error('Required parameter variantID was null or undefined when calling patchVariant.');
        }

        // verify required parameter 'variant' is not null or undefined
        if (variant === null || variant === undefined) {
            throw new Error('Required parameter variant was null or undefined when calling patchVariant.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: variant,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param productAssignment 
     */
    public saveAssignment (productAssignment: ProductAssignment) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/products/assignments';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'productAssignment' is not null or undefined
        if (productAssignment === null || productAssignment === undefined) {
            throw new Error('Required parameter productAssignment was null or undefined when calling saveAssignment.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: productAssignment,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param productID ID of the product.
     * @param product 
     */
    public update (productID: string, product: Product) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/products/{productID}'
            .replace('{' + 'productID' + '}', String(productID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'productID' is not null or undefined
        if (productID === null || productID === undefined) {
            throw new Error('Required parameter productID was null or undefined when calling update.');
        }

        // verify required parameter 'product' is not null or undefined
        if (product === null || product === undefined) {
            throw new Error('Required parameter product was null or undefined when calling update.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: product,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param productID ID of the product.
     * @param inventory Inventory of the product.
     */
    public updateInventory (productID: string, inventory: number) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/products/{productID}/inventory/{inventory}'
            .replace('{' + 'productID' + '}', String(productID))
            .replace('{' + 'inventory' + '}', String(inventory));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'productID' is not null or undefined
        if (productID === null || productID === undefined) {
            throw new Error('Required parameter productID was null or undefined when calling updateInventory.');
        }

        // verify required parameter 'inventory' is not null or undefined
        if (inventory === null || inventory === undefined) {
            throw new Error('Required parameter inventory was null or undefined when calling updateInventory.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param productID ID of the product.
     * @param variantID ID of the variant.
     * @param variant 
     */
    public updateVariant (productID: string, variantID: string, variant: Variant) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/products/{productID}/variants/{variantID}'
            .replace('{' + 'productID' + '}', String(productID))
            .replace('{' + 'variantID' + '}', String(variantID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'productID' is not null or undefined
        if (productID === null || productID === undefined) {
            throw new Error('Required parameter productID was null or undefined when calling updateVariant.');
        }

        // verify required parameter 'variantID' is not null or undefined
        if (variantID === null || variantID === undefined) {
            throw new Error('Required parameter variantID was null or undefined when calling updateVariant.');
        }

        // verify required parameter 'variant' is not null or undefined
        if (variant === null || variant === undefined) {
            throw new Error('Required parameter variant was null or undefined when calling updateVariant.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: variant,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param productID ID of the product.
     * @param variantID ID of the variant.
     * @param inventory Inventory of the product.
     */
    public updateVariantInventory (productID: string, variantID: string, inventory: number) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/products/{productID}/variants/inventory/{variantID}/{inventory}'
            .replace('{' + 'productID' + '}', String(productID))
            .replace('{' + 'variantID' + '}', String(variantID))
            .replace('{' + 'inventory' + '}', String(inventory));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'productID' is not null or undefined
        if (productID === null || productID === undefined) {
            throw new Error('Required parameter productID was null or undefined when calling updateVariantInventory.');
        }

        // verify required parameter 'variantID' is not null or undefined
        if (variantID === null || variantID === undefined) {
            throw new Error('Required parameter variantID was null or undefined when calling updateVariantInventory.');
        }

        // verify required parameter 'inventory' is not null or undefined
        if (inventory === null || inventory === undefined) {
            throw new Error('Required parameter inventory was null or undefined when calling updateVariantInventory.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PromotionApiApiKeys {
}

export class PromotionApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'auth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: PromotionApiApiKeys, value: string) {
        this.authentications[PromotionApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.auth.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * 
     * 
     * @param promotionID ID of the promotion.
     */
    public _delete (promotionID: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/promotions/{promotionID}'
            .replace('{' + 'promotionID' + '}', String(promotionID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'promotionID' is not null or undefined
        if (promotionID === null || promotionID === undefined) {
            throw new Error('Required parameter promotionID was null or undefined when calling _delete.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param promo 
     */
    public create (promo: Promotion) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/promotions';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'promo' is not null or undefined
        if (promo === null || promo === undefined) {
            throw new Error('Required parameter promo was null or undefined when calling create.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: promo,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param promotionID ID of the promotion.
     * @param buyerID ID of the buyer.
     * @param userID ID of the user.
     * @param userGroupID ID of the user group.
     */
    public deleteAssignment (promotionID: string, buyerID: string, userID?: string, userGroupID?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/promotions/{promotionID}/assignments'
            .replace('{' + 'promotionID' + '}', String(promotionID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'promotionID' is not null or undefined
        if (promotionID === null || promotionID === undefined) {
            throw new Error('Required parameter promotionID was null or undefined when calling deleteAssignment.');
        }

        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling deleteAssignment.');
        }

        if (buyerID !== undefined) {
            queryParameters['buyerID'] = buyerID;
        }

        if (userID !== undefined) {
            queryParameters['userID'] = userID;
        }

        if (userGroupID !== undefined) {
            queryParameters['userGroupID'] = userGroupID;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param promotionID ID of the promotion.
     */
    public get (promotionID: string) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/promotions/{promotionID}'
            .replace('{' + 'promotionID' + '}', String(promotionID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'promotionID' is not null or undefined
        if (promotionID === null || promotionID === undefined) {
            throw new Error('Required parameter promotionID was null or undefined when calling get.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public list (search?: string, searchOn?: string, sortBy?: string, page?: number, pageSize?: number) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/promotions';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (search !== undefined) {
            queryParameters['search'] = search;
        }

        if (searchOn !== undefined) {
            queryParameters['searchOn'] = searchOn;
        }

        if (sortBy !== undefined) {
            queryParameters['sortBy'] = sortBy;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param promotionID ID of the promotion.
     * @param userID ID of the user.
     * @param userGroupID ID of the user group.
     * @param level Level of the promotion.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public listAssignments (buyerID: string, promotionID?: string, userID?: string, userGroupID?: string, level?: string, page?: number, pageSize?: number) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/promotions/assignments';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling listAssignments.');
        }

        if (buyerID !== undefined) {
            queryParameters['buyerID'] = buyerID;
        }

        if (promotionID !== undefined) {
            queryParameters['promotionID'] = promotionID;
        }

        if (userID !== undefined) {
            queryParameters['userID'] = userID;
        }

        if (userGroupID !== undefined) {
            queryParameters['userGroupID'] = userGroupID;
        }

        if (level !== undefined) {
            queryParameters['level'] = level;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param promotionID ID of the promotion.
     * @param partialPromotion 
     */
    public patch (promotionID: string, partialPromotion: Promotion) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/promotions/{promotionID}'
            .replace('{' + 'promotionID' + '}', String(promotionID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'promotionID' is not null or undefined
        if (promotionID === null || promotionID === undefined) {
            throw new Error('Required parameter promotionID was null or undefined when calling patch.');
        }

        // verify required parameter 'partialPromotion' is not null or undefined
        if (partialPromotion === null || partialPromotion === undefined) {
            throw new Error('Required parameter partialPromotion was null or undefined when calling patch.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: partialPromotion,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param assignment 
     */
    public saveAssignment (assignment: PromotionAssignment) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/promotions/assignments';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'assignment' is not null or undefined
        if (assignment === null || assignment === undefined) {
            throw new Error('Required parameter assignment was null or undefined when calling saveAssignment.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: assignment,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param promotionID ID of the promotion.
     * @param promo 
     */
    public update (promotionID: string, promo: Promotion) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/promotions/{promotionID}'
            .replace('{' + 'promotionID' + '}', String(promotionID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'promotionID' is not null or undefined
        if (promotionID === null || promotionID === undefined) {
            throw new Error('Required parameter promotionID was null or undefined when calling update.');
        }

        // verify required parameter 'promo' is not null or undefined
        if (promo === null || promo === undefined) {
            throw new Error('Required parameter promo was null or undefined when calling update.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: promo,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SecurityProfileApiApiKeys {
}

export class SecurityProfileApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'auth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: SecurityProfileApiApiKeys, value: string) {
        this.authentications[SecurityProfileApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.auth.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * 
     * 
     * @param securityProfileID ID of the security profile.
     */
    public get (securityProfileID: string) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/SecurityProfiles/{securityProfileID}'
            .replace('{' + 'securityProfileID' + '}', String(securityProfileID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'securityProfileID' is not null or undefined
        if (securityProfileID === null || securityProfileID === undefined) {
            throw new Error('Required parameter securityProfileID was null or undefined when calling get.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public list (search?: string, searchOn?: string, sortBy?: string, page?: number, pageSize?: number) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/SecurityProfiles';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (search !== undefined) {
            queryParameters['search'] = search;
        }

        if (searchOn !== undefined) {
            queryParameters['searchOn'] = searchOn;
        }

        if (sortBy !== undefined) {
            queryParameters['sortBy'] = sortBy;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ShipmentApiApiKeys {
}

export class ShipmentApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'auth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: ShipmentApiApiKeys, value: string) {
        this.authentications[ShipmentApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.auth.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param shipmentID ID of the shipment.
     */
    public _delete (buyerID: string, shipmentID: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/shipments/{shipmentID}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'shipmentID' + '}', String(shipmentID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling _delete.');
        }

        // verify required parameter 'shipmentID' is not null or undefined
        if (shipmentID === null || shipmentID === undefined) {
            throw new Error('Required parameter shipmentID was null or undefined when calling _delete.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param shipment 
     */
    public create (buyerID: string, shipment: Shipment) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/shipments'
            .replace('{' + 'buyerID' + '}', String(buyerID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling create.');
        }

        // verify required parameter 'shipment' is not null or undefined
        if (shipment === null || shipment === undefined) {
            throw new Error('Required parameter shipment was null or undefined when calling create.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: shipment,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param shipmentID ID of the shipment.
     * @param orderID ID of the order.
     * @param lineItemID ID of the line item.
     */
    public deleteItem (buyerID: string, shipmentID: string, orderID: string, lineItemID: string) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/shipments/{shipmentID}/items/{orderID}/{lineItemID}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'shipmentID' + '}', String(shipmentID))
            .replace('{' + 'orderID' + '}', String(orderID))
            .replace('{' + 'lineItemID' + '}', String(lineItemID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling deleteItem.');
        }

        // verify required parameter 'shipmentID' is not null or undefined
        if (shipmentID === null || shipmentID === undefined) {
            throw new Error('Required parameter shipmentID was null or undefined when calling deleteItem.');
        }

        // verify required parameter 'orderID' is not null or undefined
        if (orderID === null || orderID === undefined) {
            throw new Error('Required parameter orderID was null or undefined when calling deleteItem.');
        }

        // verify required parameter 'lineItemID' is not null or undefined
        if (lineItemID === null || lineItemID === undefined) {
            throw new Error('Required parameter lineItemID was null or undefined when calling deleteItem.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param shipmentID ID of the shipment.
     */
    public get (buyerID: string, shipmentID: string) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/shipments/{shipmentID}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'shipmentID' + '}', String(shipmentID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling get.');
        }

        // verify required parameter 'shipmentID' is not null or undefined
        if (shipmentID === null || shipmentID === undefined) {
            throw new Error('Required parameter shipmentID was null or undefined when calling get.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param orderID ID of the order.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public list (buyerID: string, orderID?: string, search?: string, searchOn?: string, sortBy?: string, page?: number, pageSize?: number) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/shipments'
            .replace('{' + 'buyerID' + '}', String(buyerID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling list.');
        }

        if (orderID !== undefined) {
            queryParameters['orderID'] = orderID;
        }

        if (search !== undefined) {
            queryParameters['search'] = search;
        }

        if (searchOn !== undefined) {
            queryParameters['searchOn'] = searchOn;
        }

        if (sortBy !== undefined) {
            queryParameters['sortBy'] = sortBy;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param shipmentID ID of the shipment.
     * @param shipment 
     */
    public patch (buyerID: string, shipmentID: string, shipment: Shipment) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/shipments/{shipmentID}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'shipmentID' + '}', String(shipmentID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling patch.');
        }

        // verify required parameter 'shipmentID' is not null or undefined
        if (shipmentID === null || shipmentID === undefined) {
            throw new Error('Required parameter shipmentID was null or undefined when calling patch.');
        }

        // verify required parameter 'shipment' is not null or undefined
        if (shipment === null || shipment === undefined) {
            throw new Error('Required parameter shipment was null or undefined when calling patch.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: shipment,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param shipmentID ID of the shipment.
     * @param item 
     */
    public saveItem (buyerID: string, shipmentID: string, item: ShipmentItem) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/shipments/{shipmentID}/items'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'shipmentID' + '}', String(shipmentID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling saveItem.');
        }

        // verify required parameter 'shipmentID' is not null or undefined
        if (shipmentID === null || shipmentID === undefined) {
            throw new Error('Required parameter shipmentID was null or undefined when calling saveItem.');
        }

        // verify required parameter 'item' is not null or undefined
        if (item === null || item === undefined) {
            throw new Error('Required parameter item was null or undefined when calling saveItem.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: item,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param shipmentID ID of the shipment.
     * @param shipment 
     */
    public update (buyerID: string, shipmentID: string, shipment: Shipment) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/shipments/{shipmentID}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'shipmentID' + '}', String(shipmentID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling update.');
        }

        // verify required parameter 'shipmentID' is not null or undefined
        if (shipmentID === null || shipmentID === undefined) {
            throw new Error('Required parameter shipmentID was null or undefined when calling update.');
        }

        // verify required parameter 'shipment' is not null or undefined
        if (shipment === null || shipment === undefined) {
            throw new Error('Required parameter shipment was null or undefined when calling update.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: shipment,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SpecApiApiKeys {
}

export class SpecApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'auth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: SpecApiApiKeys, value: string) {
        this.authentications[SpecApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.auth.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * 
     * 
     * @param specID ID of the spec.
     */
    public _delete (specID: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/specs/{specID}'
            .replace('{' + 'specID' + '}', String(specID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'specID' is not null or undefined
        if (specID === null || specID === undefined) {
            throw new Error('Required parameter specID was null or undefined when calling _delete.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param spec 
     */
    public create (spec: Spec) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/specs';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'spec' is not null or undefined
        if (spec === null || spec === undefined) {
            throw new Error('Required parameter spec was null or undefined when calling create.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: spec,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param specID ID of the spec.
     * @param option 
     */
    public createOption (specID: string, option: SpecOption) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/specs/{specID}/options'
            .replace('{' + 'specID' + '}', String(specID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'specID' is not null or undefined
        if (specID === null || specID === undefined) {
            throw new Error('Required parameter specID was null or undefined when calling createOption.');
        }

        // verify required parameter 'option' is not null or undefined
        if (option === null || option === undefined) {
            throw new Error('Required parameter option was null or undefined when calling createOption.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: option,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param specID ID of the spec.
     * @param optionID ID of the option.
     */
    public deleteOption (specID: string, optionID: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/specs/{specID}/options/{optionID}'
            .replace('{' + 'specID' + '}', String(specID))
            .replace('{' + 'optionID' + '}', String(optionID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'specID' is not null or undefined
        if (specID === null || specID === undefined) {
            throw new Error('Required parameter specID was null or undefined when calling deleteOption.');
        }

        // verify required parameter 'optionID' is not null or undefined
        if (optionID === null || optionID === undefined) {
            throw new Error('Required parameter optionID was null or undefined when calling deleteOption.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param specID ID of the spec.
     * @param productID ID of the product.
     */
    public deleteProductAssignment (specID: string, productID: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/specs/{specID}/productassignments/{productID}'
            .replace('{' + 'specID' + '}', String(specID))
            .replace('{' + 'productID' + '}', String(productID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'specID' is not null or undefined
        if (specID === null || specID === undefined) {
            throw new Error('Required parameter specID was null or undefined when calling deleteProductAssignment.');
        }

        // verify required parameter 'productID' is not null or undefined
        if (productID === null || productID === undefined) {
            throw new Error('Required parameter productID was null or undefined when calling deleteProductAssignment.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param specID ID of the spec.
     */
    public get (specID: string) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/specs/{specID}'
            .replace('{' + 'specID' + '}', String(specID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'specID' is not null or undefined
        if (specID === null || specID === undefined) {
            throw new Error('Required parameter specID was null or undefined when calling get.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param specID ID of the spec.
     * @param optionID ID of the option.
     */
    public getOption (specID: string, optionID: string) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/specs/{specID}/options/{optionID}'
            .replace('{' + 'specID' + '}', String(specID))
            .replace('{' + 'optionID' + '}', String(optionID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'specID' is not null or undefined
        if (specID === null || specID === undefined) {
            throw new Error('Required parameter specID was null or undefined when calling getOption.');
        }

        // verify required parameter 'optionID' is not null or undefined
        if (optionID === null || optionID === undefined) {
            throw new Error('Required parameter optionID was null or undefined when calling getOption.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public list (search?: string, searchOn?: string, sortBy?: string, page?: number, pageSize?: number) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/specs';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (search !== undefined) {
            queryParameters['search'] = search;
        }

        if (searchOn !== undefined) {
            queryParameters['searchOn'] = searchOn;
        }

        if (sortBy !== undefined) {
            queryParameters['sortBy'] = sortBy;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param specID ID of the spec.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public listOptions (specID: string, search?: string, searchOn?: string, sortBy?: string, page?: number, pageSize?: number) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/specs/{specID}/options'
            .replace('{' + 'specID' + '}', String(specID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'specID' is not null or undefined
        if (specID === null || specID === undefined) {
            throw new Error('Required parameter specID was null or undefined when calling listOptions.');
        }

        if (search !== undefined) {
            queryParameters['search'] = search;
        }

        if (searchOn !== undefined) {
            queryParameters['searchOn'] = searchOn;
        }

        if (sortBy !== undefined) {
            queryParameters['sortBy'] = sortBy;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param specID ID of the spec.
     * @param productID ID of the product.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public listProductAssignments (specID?: string, productID?: string, page?: number, pageSize?: number) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/specs/productassignments';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (specID !== undefined) {
            queryParameters['specID'] = specID;
        }

        if (productID !== undefined) {
            queryParameters['productID'] = productID;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param specID ID of the spec.
     * @param spec 
     */
    public patch (specID: string, spec: Spec) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/specs/{specID}'
            .replace('{' + 'specID' + '}', String(specID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'specID' is not null or undefined
        if (specID === null || specID === undefined) {
            throw new Error('Required parameter specID was null or undefined when calling patch.');
        }

        // verify required parameter 'spec' is not null or undefined
        if (spec === null || spec === undefined) {
            throw new Error('Required parameter spec was null or undefined when calling patch.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: spec,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param specID ID of the spec.
     * @param optionID ID of the option.
     * @param option 
     */
    public patchOption (specID: string, optionID: string, option: SpecOption) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/specs/{specID}/options/{optionID}'
            .replace('{' + 'specID' + '}', String(specID))
            .replace('{' + 'optionID' + '}', String(optionID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'specID' is not null or undefined
        if (specID === null || specID === undefined) {
            throw new Error('Required parameter specID was null or undefined when calling patchOption.');
        }

        // verify required parameter 'optionID' is not null or undefined
        if (optionID === null || optionID === undefined) {
            throw new Error('Required parameter optionID was null or undefined when calling patchOption.');
        }

        // verify required parameter 'option' is not null or undefined
        if (option === null || option === undefined) {
            throw new Error('Required parameter option was null or undefined when calling patchOption.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: option,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param productAssignment 
     */
    public saveProductAssignment (productAssignment: SpecProductAssignment) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/specs/productassignments';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'productAssignment' is not null or undefined
        if (productAssignment === null || productAssignment === undefined) {
            throw new Error('Required parameter productAssignment was null or undefined when calling saveProductAssignment.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: productAssignment,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param specID ID of the spec.
     * @param spec 
     */
    public update (specID: string, spec: Spec) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/specs/{specID}'
            .replace('{' + 'specID' + '}', String(specID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'specID' is not null or undefined
        if (specID === null || specID === undefined) {
            throw new Error('Required parameter specID was null or undefined when calling update.');
        }

        // verify required parameter 'spec' is not null or undefined
        if (spec === null || spec === undefined) {
            throw new Error('Required parameter spec was null or undefined when calling update.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: spec,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param specID ID of the spec.
     * @param optionID ID of the option.
     * @param option 
     */
    public updateOption (specID: string, optionID: string, option: SpecOption) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/specs/{specID}/options/{optionID}'
            .replace('{' + 'specID' + '}', String(specID))
            .replace('{' + 'optionID' + '}', String(optionID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'specID' is not null or undefined
        if (specID === null || specID === undefined) {
            throw new Error('Required parameter specID was null or undefined when calling updateOption.');
        }

        // verify required parameter 'optionID' is not null or undefined
        if (optionID === null || optionID === undefined) {
            throw new Error('Required parameter optionID was null or undefined when calling updateOption.');
        }

        // verify required parameter 'option' is not null or undefined
        if (option === null || option === undefined) {
            throw new Error('Required parameter option was null or undefined when calling updateOption.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: option,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SpendingAccountApiApiKeys {
}

export class SpendingAccountApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'auth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: SpendingAccountApiApiKeys, value: string) {
        this.authentications[SpendingAccountApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.auth.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param spendingAccountID ID of the spending account.
     */
    public _delete (buyerID: string, spendingAccountID: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/spendingaccounts/{spendingAccountID}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'spendingAccountID' + '}', String(spendingAccountID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling _delete.');
        }

        // verify required parameter 'spendingAccountID' is not null or undefined
        if (spendingAccountID === null || spendingAccountID === undefined) {
            throw new Error('Required parameter spendingAccountID was null or undefined when calling _delete.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param spendingAccount 
     */
    public create (buyerID: string, spendingAccount: SpendingAccount) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/spendingaccounts'
            .replace('{' + 'buyerID' + '}', String(buyerID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling create.');
        }

        // verify required parameter 'spendingAccount' is not null or undefined
        if (spendingAccount === null || spendingAccount === undefined) {
            throw new Error('Required parameter spendingAccount was null or undefined when calling create.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: spendingAccount,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param spendingAccountID ID of the spending account.
     * @param userID ID of the user.
     * @param userGroupID ID of the user group.
     */
    public deleteAssignment (buyerID: string, spendingAccountID: string, userID?: string, userGroupID?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/spendingaccounts/{spendingAccountID}/assignments'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'spendingAccountID' + '}', String(spendingAccountID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling deleteAssignment.');
        }

        // verify required parameter 'spendingAccountID' is not null or undefined
        if (spendingAccountID === null || spendingAccountID === undefined) {
            throw new Error('Required parameter spendingAccountID was null or undefined when calling deleteAssignment.');
        }

        if (userID !== undefined) {
            queryParameters['userID'] = userID;
        }

        if (userGroupID !== undefined) {
            queryParameters['userGroupID'] = userGroupID;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param spendingAccountID ID of the spending account.
     */
    public get (buyerID: string, spendingAccountID: string) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/spendingaccounts/{spendingAccountID}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'spendingAccountID' + '}', String(spendingAccountID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling get.');
        }

        // verify required parameter 'spendingAccountID' is not null or undefined
        if (spendingAccountID === null || spendingAccountID === undefined) {
            throw new Error('Required parameter spendingAccountID was null or undefined when calling get.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public list (buyerID: string, search?: string, searchOn?: string, sortBy?: string, page?: number, pageSize?: number) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/spendingaccounts'
            .replace('{' + 'buyerID' + '}', String(buyerID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling list.');
        }

        if (search !== undefined) {
            queryParameters['search'] = search;
        }

        if (searchOn !== undefined) {
            queryParameters['searchOn'] = searchOn;
        }

        if (sortBy !== undefined) {
            queryParameters['sortBy'] = sortBy;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param spendingAccountID ID of the spending account.
     * @param userID ID of the user.
     * @param userGroupID ID of the user group.
     * @param level Level of the spending account.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public listAssignments (buyerID: string, spendingAccountID?: string, userID?: string, userGroupID?: string, level?: string, page?: number, pageSize?: number) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/spendingaccounts/assignments'
            .replace('{' + 'buyerID' + '}', String(buyerID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling listAssignments.');
        }

        if (spendingAccountID !== undefined) {
            queryParameters['spendingAccountID'] = spendingAccountID;
        }

        if (userID !== undefined) {
            queryParameters['userID'] = userID;
        }

        if (userGroupID !== undefined) {
            queryParameters['userGroupID'] = userGroupID;
        }

        if (level !== undefined) {
            queryParameters['level'] = level;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param spendingAccountID ID of the spending account.
     * @param spendingAccount 
     */
    public patch (buyerID: string, spendingAccountID: string, spendingAccount: SpendingAccount) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/spendingaccounts/{spendingAccountID}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'spendingAccountID' + '}', String(spendingAccountID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling patch.');
        }

        // verify required parameter 'spendingAccountID' is not null or undefined
        if (spendingAccountID === null || spendingAccountID === undefined) {
            throw new Error('Required parameter spendingAccountID was null or undefined when calling patch.');
        }

        // verify required parameter 'spendingAccount' is not null or undefined
        if (spendingAccount === null || spendingAccount === undefined) {
            throw new Error('Required parameter spendingAccount was null or undefined when calling patch.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: spendingAccount,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param assignment 
     */
    public saveAssignment (buyerID: string, assignment: SpendingAccountAssignment) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/spendingaccounts/assignments'
            .replace('{' + 'buyerID' + '}', String(buyerID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling saveAssignment.');
        }

        // verify required parameter 'assignment' is not null or undefined
        if (assignment === null || assignment === undefined) {
            throw new Error('Required parameter assignment was null or undefined when calling saveAssignment.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: assignment,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param spendingAccountID ID of the spending account.
     * @param spendingAccount 
     */
    public update (buyerID: string, spendingAccountID: string, spendingAccount: SpendingAccount) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/spendingaccounts/{spendingAccountID}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'spendingAccountID' + '}', String(spendingAccountID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling update.');
        }

        // verify required parameter 'spendingAccountID' is not null or undefined
        if (spendingAccountID === null || spendingAccountID === undefined) {
            throw new Error('Required parameter spendingAccountID was null or undefined when calling update.');
        }

        // verify required parameter 'spendingAccount' is not null or undefined
        if (spendingAccount === null || spendingAccount === undefined) {
            throw new Error('Required parameter spendingAccount was null or undefined when calling update.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: spendingAccount,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UserApiApiKeys {
}

export class UserApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'auth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: UserApiApiKeys, value: string) {
        this.authentications[UserApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.auth.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param userID ID of the user.
     */
    public _delete (buyerID: string, userID: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/users/{userID}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'userID' + '}', String(userID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling _delete.');
        }

        // verify required parameter 'userID' is not null or undefined
        if (userID === null || userID === undefined) {
            throw new Error('Required parameter userID was null or undefined when calling _delete.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param user 
     */
    public create (buyerID: string, user: User) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/users'
            .replace('{' + 'buyerID' + '}', String(buyerID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling create.');
        }

        // verify required parameter 'user' is not null or undefined
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling create.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: user,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param userID ID of the user.
     */
    public get (buyerID: string, userID: string) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/users/{userID}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'userID' + '}', String(userID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling get.');
        }

        // verify required parameter 'userID' is not null or undefined
        if (userID === null || userID === undefined) {
            throw new Error('Required parameter userID was null or undefined when calling get.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param userID ID of the user.
     * @param tokenRequest 
     */
    public getAccessToken (buyerID: string, userID: string, tokenRequest: ImpersonateTokenRequest) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/users/{userID}/accesstoken'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'userID' + '}', String(userID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling getAccessToken.');
        }

        // verify required parameter 'userID' is not null or undefined
        if (userID === null || userID === undefined) {
            throw new Error('Required parameter userID was null or undefined when calling getAccessToken.');
        }

        // verify required parameter 'tokenRequest' is not null or undefined
        if (tokenRequest === null || tokenRequest === undefined) {
            throw new Error('Required parameter tokenRequest was null or undefined when calling getAccessToken.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: tokenRequest,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param userGroupID ID of the user group.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public list (buyerID: string, userGroupID?: string, search?: string, searchOn?: string, sortBy?: string, page?: number, pageSize?: number) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/users'
            .replace('{' + 'buyerID' + '}', String(buyerID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling list.');
        }

        if (userGroupID !== undefined) {
            queryParameters['userGroupID'] = userGroupID;
        }

        if (search !== undefined) {
            queryParameters['search'] = search;
        }

        if (searchOn !== undefined) {
            queryParameters['searchOn'] = searchOn;
        }

        if (sortBy !== undefined) {
            queryParameters['sortBy'] = sortBy;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param userID ID of the user.
     * @param user 
     */
    public patch (buyerID: string, userID: string, user: User) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/users/{userID}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'userID' + '}', String(userID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling patch.');
        }

        // verify required parameter 'userID' is not null or undefined
        if (userID === null || userID === undefined) {
            throw new Error('Required parameter userID was null or undefined when calling patch.');
        }

        // verify required parameter 'user' is not null or undefined
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling patch.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: user,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param userID ID of the user.
     * @param user 
     */
    public update (buyerID: string, userID: string, user: User) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/users/{userID}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'userID' + '}', String(userID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling update.');
        }

        // verify required parameter 'userID' is not null or undefined
        if (userID === null || userID === undefined) {
            throw new Error('Required parameter userID was null or undefined when calling update.');
        }

        // verify required parameter 'user' is not null or undefined
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling update.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: user,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UserGroupApiApiKeys {
}

export class UserGroupApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'auth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: UserGroupApiApiKeys, value: string) {
        this.authentications[UserGroupApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.auth.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param userGroupID ID of the user group.
     */
    public _delete (buyerID: string, userGroupID: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/usergroups/{userGroupID}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'userGroupID' + '}', String(userGroupID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling _delete.');
        }

        // verify required parameter 'userGroupID' is not null or undefined
        if (userGroupID === null || userGroupID === undefined) {
            throw new Error('Required parameter userGroupID was null or undefined when calling _delete.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param group 
     */
    public create (buyerID: string, group: UserGroup) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/usergroups'
            .replace('{' + 'buyerID' + '}', String(buyerID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling create.');
        }

        // verify required parameter 'group' is not null or undefined
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling create.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: group,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param userGroupID ID of the user group.
     * @param userID ID of the user.
     */
    public deleteUserAssignment (buyerID: string, userGroupID: string, userID: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/usergroups/{userGroupID}/assignments/{userID}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'userGroupID' + '}', String(userGroupID))
            .replace('{' + 'userID' + '}', String(userID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling deleteUserAssignment.');
        }

        // verify required parameter 'userGroupID' is not null or undefined
        if (userGroupID === null || userGroupID === undefined) {
            throw new Error('Required parameter userGroupID was null or undefined when calling deleteUserAssignment.');
        }

        // verify required parameter 'userID' is not null or undefined
        if (userID === null || userID === undefined) {
            throw new Error('Required parameter userID was null or undefined when calling deleteUserAssignment.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param userGroupID ID of the user group.
     */
    public get (buyerID: string, userGroupID: string) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/usergroups/{userGroupID}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'userGroupID' + '}', String(userGroupID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling get.');
        }

        // verify required parameter 'userGroupID' is not null or undefined
        if (userGroupID === null || userGroupID === undefined) {
            throw new Error('Required parameter userGroupID was null or undefined when calling get.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param search Word or phrase to search for.
     * @param searchOn Comma-delimited list of fields to search on.
     * @param sortBy Comma-delimited list of fields to sort by.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public list (buyerID: string, search?: string, searchOn?: string, sortBy?: string, page?: number, pageSize?: number) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/usergroups'
            .replace('{' + 'buyerID' + '}', String(buyerID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling list.');
        }

        if (search !== undefined) {
            queryParameters['search'] = search;
        }

        if (searchOn !== undefined) {
            queryParameters['searchOn'] = searchOn;
        }

        if (sortBy !== undefined) {
            queryParameters['sortBy'] = sortBy;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param userGroupID ID of the user group.
     * @param userID ID of the user.
     * @param page Page of results to return. Default: 1
     * @param pageSize Number of results to return per page. Default: 20, max: 100.
     */
    public listUserAssignments (buyerID: string, userGroupID?: string, userID?: string, page?: number, pageSize?: number) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/usergroups/assignments'
            .replace('{' + 'buyerID' + '}', String(buyerID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling listUserAssignments.');
        }

        if (userGroupID !== undefined) {
            queryParameters['userGroupID'] = userGroupID;
        }

        if (userID !== undefined) {
            queryParameters['userID'] = userID;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param userGroupID ID of the user group.
     * @param group 
     */
    public patch (buyerID: string, userGroupID: string, group: UserGroup) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/usergroups/{userGroupID}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'userGroupID' + '}', String(userGroupID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling patch.');
        }

        // verify required parameter 'userGroupID' is not null or undefined
        if (userGroupID === null || userGroupID === undefined) {
            throw new Error('Required parameter userGroupID was null or undefined when calling patch.');
        }

        // verify required parameter 'group' is not null or undefined
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling patch.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: group,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param userGroupAssignment 
     */
    public saveUserAssignment (buyerID: string, userGroupAssignment: UserGroupAssignment) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/usergroups/assignments'
            .replace('{' + 'buyerID' + '}', String(buyerID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling saveUserAssignment.');
        }

        // verify required parameter 'userGroupAssignment' is not null or undefined
        if (userGroupAssignment === null || userGroupAssignment === undefined) {
            throw new Error('Required parameter userGroupAssignment was null or undefined when calling saveUserAssignment.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: userGroupAssignment,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param buyerID ID of the buyer.
     * @param userGroupID ID of the user group.
     * @param group 
     */
    public update (buyerID: string, userGroupID: string, group: UserGroup) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/buyers/{buyerID}/usergroups/{userGroupID}'
            .replace('{' + 'buyerID' + '}', String(buyerID))
            .replace('{' + 'userGroupID' + '}', String(userGroupID));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'buyerID' is not null or undefined
        if (buyerID === null || buyerID === undefined) {
            throw new Error('Required parameter buyerID was null or undefined when calling update.');
        }

        // verify required parameter 'userGroupID' is not null or undefined
        if (userGroupID === null || userGroupID === undefined) {
            throw new Error('Required parameter userGroupID was null or undefined when calling update.');
        }

        // verify required parameter 'group' is not null or undefined
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling update.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: group,
        };

        this.authentications.auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
