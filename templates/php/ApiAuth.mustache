<?php
/**
 * ApiAuth
 *
 * PHP version 5
 *
 * @category Class
 * @package  {{invokerPackage}}
 * @author   http://github.com/swagger-api/swagger-codegen
 * @license  http://www.apache.org/licenses/LICENSE-2.0 Apache Licene v2
 * @link     https://github.com/swagger-api/swagger-codegen
 */

{{>partial_header}}
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace {{invokerPackage}};

/**
 * ApiAuth Class Doc Comment
 *
 * @category Class
 * @package  {{invokerPackage}}
 * @author   http://github.com/swagger-api/swagger-codegen
 * @license  http://www.apache.org/licenses/LICENSE-2.0 Apache Licene v2
 * @link     https://github.com/swagger-api/swagger-codegen
 */

class ApiAuth
{
  static private function _base_body_for_auth($grant_type, $client_secret = null)
  {
    $body = [ 
      "client_id" => Configuration::getDefaultConfiguration()->getClientId(),
      "grant_type" => $grant_type,
    ];

    if(Configuration::getDefaultConfiguration()->getScopes() != NULL)
      $body["scope"] = join('+', Configuration::getDefaultConfiguration()->getScopes());

    if($client_secret != NULL)
      $body["client_secret"] = $client_secret;

    return body;
  }
  
  static private function _request_access_token($body)
  {
        $postData = http_build_query($body);
        curl_setopt($curl, CURLOPT_POST, true);
        curl_setopt($curl, CURLOPT_POSTFIELDS, $postData);
        // debugging for curl
        if ($this->config->getDebug()) {
            error_log("[DEBUG] HTTP Request body  ~BEGIN~".PHP_EOL.print_r($postData, true).PHP_EOL."~END~".PHP_EOL, 3, $this->config->getDebugFile());

            curl_setopt($curl, CURLOPT_VERBOSE, 1);
            curl_setopt($curl, CURLOPT_STDERR, fopen(ApiClient.getConfig->getDebugFile(), 'a'));
        } else {
            curl_setopt($curl, CURLOPT_VERBOSE, 0);
        }

        $response = curl_exec($curl);
        $http_header_size = curl_getinfo($curl, CURLINFO_HEADER_SIZE);
        $http_header = $this->httpParseHeaders(substr($response, 0, $http_header_size));
        $http_body = substr($response, $http_header_size);
        $response_info = curl_getinfo($curl);

        // debug HTTP response body
        if ($this->config->getDebug()) {
            error_log("[DEBUG] HTTP Response body ~BEGIN~".PHP_EOL.print_r($http_body, true).PHP_EOL."~END~".PHP_EOL, 3, $this->config->getDebugFile());
        }

        // Handle the response
        if ($response_info['http_code'] == 0) {
            $curl_error_message = curl_error($curl);

            // curl_exec can sometimes fail but still return a blank message from curl_error().
            if (!empty($curl_error_message)) {
                $error_message = "API call to $url failed: $curl_error_message";
            } else {
                $error_message = "API call to $url failed, but for an unknown reason. " .
                    "This could happen if you are disconnected from the network.";
            }

            $exception = new ApiException($error_message, 0, null, null);
            $exception->setResponseObject($response_info);
            throw $exception;
        } elseif ($response_info['http_code'] >= 200 && $response_info['http_code'] <= 299) {
            // return raw body if response is a file
            if ($responseType == '\SplFileObject' || $responseType == 'string') {
                return array($http_body, $response_info['http_code'], $http_header);
            }

            $data = json_decode($http_body);
            if (json_last_error() > 0) { // if response is a string
                $data = $http_body;
            }
        } else {
            $data = json_decode($http_body);
            if (json_last_error() > 0) { // if response is a string
                $data = $http_body;
            }

            throw new ApiException(
                "[".$response_info['http_code']."] Error connecting to the API ($url)",
                $response_info['http_code'],
                $http_header,
                $data
            );
        }
        Configuration::getDefaultConfiguration()->setAccessToken(data["access_token"]);
  }

  static public function login($username, $password, $client_secret = null)
  {
    $body = ApiAuth._base_body_for_auth("password", $client_secret);
    $body["username"] = $username;
    $body["password"] = $password;

    return _request_access_token($body);
  }

  static public function authenticate($client_secret = null)
  {
    $body = ApiAuth._base_body_for_auth("client_credentials", $client_secret);

    return _request_access_token($body);
  }

  static public function start_impersonate($impersonation_access_token)
  {
    if($impersonation_token == NULL) {
      print("error");
    }
    
    Configuration::getDefaultConfiguration()->setImpersonationToken($impersonation_access_token);
  }

  static public function stop_impersonate()
  {
    Configuration::getDefaultConfiguration()->setImpersonationToken(NULL);
  }
}
